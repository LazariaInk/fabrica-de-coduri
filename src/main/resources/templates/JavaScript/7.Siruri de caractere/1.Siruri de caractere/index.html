<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">
 <head>
    <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      window.gtag = function () { dataLayer.push(arguments); };
      gtag('consent', 'default', {
        'wait_for_update': 500,
        'region': ['RO'],
        'ad_storage': 'denied',
        'analytics_storage': 'denied',
        'ad_user_data': 'denied',
        'ad_personalization': 'denied'
      });
      gtag('js', new Date());
      gtag('config', 'G-7Q2536ZKL2');
    </script>


  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title th:text="${lesson.title}">Lesson</title>
  <link rel="stylesheet" th:href="@{/css/styles.css}">
  <style>body { background: #ffffff; }</style>
 </head>
 <body th:with="activeTopic='JavaScript', activeChapter='7.Siruri de caractere', activeLesson='1.Siruri de caractere'">
  <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
  <div th:replace="~{fragments/nav :: nav}"></div>
  <div class="top-nav">
   <th:block th:each="topic : ${topics}">
    <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}" th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a>
   </th:block>
  </div>
  <div class="layout">
   <div class="mobile-sidebar" id="mobileSidebar">
    <button class="close-btn" onclick="toggleSidebar()">✖</button>
    <ul class="chapter-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-title" onclick="toggleChapter(this)">
        <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
       </div>
       <ul class="lesson-list">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </div>
   <aside class="sidebar">
    <ul class="sidebar-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-toggle" onclick="toggleLessons(this)">
        <span th:text="${chapter.title}">Chapter</span>
       </div>
       <ul class="lesson-list hidden">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </aside>
   <main class="content">
    <div class="document-container">
     <h1 class="main-title">Șiruri de caractere</h1>
     <h2 class="subtitle">Șiruri de caractere, obiectul String și metodele sale</h2>
     <p class="paragraph">Pentru a crea șiruri de caractere, putem să le atribuim direct unei variabile sau constante:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;message&nbsp;=&nbsp;"Hello";</code></pre>
     </div>
     <p class="paragraph">Pentru lucrul cu șiruri de caractere, există obiectul String, așa că putem folosi și constructorul String:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;message&nbsp;=&nbsp;new&nbsp;String("Hello");</code></pre>
     </div>
     <p class="paragraph">Dar de obicei, prima variantă mai scurtă este preferată. În primul caz, JavaScript va converti automat variabila de tip primitiv într-un obiect String, dacă este necesar.</p>
     <p class="paragraph">Prin intermediul indecșilor, putem accesa caractere individuale dintr-un șir, asemenea elementelor unui array (în JavaScript, indexarea începe de la zero):</p>
     <div class="code-inline">
      <pre><code>const&nbsp;message&nbsp;=&nbsp;"Hello";<br>console.log(message[0]);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;H<br>console.log(message[4]);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;o</code></pre>
     </div>
     <p class="paragraph">Obiectul String are un set extins de proprietăți și metode, cu ajutorul cărora putem manipula șirurile.</p>
     <h2 class="subtitle">Lungimea șirului</h2>
     <p class="paragraph">Proprietatea length indică lungimea șirului:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;message&nbsp;=&nbsp;"Hello";<br>console.log(message.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;5&nbsp;simboluri</code></pre>
     </div>
     <h2 class="subtitle">Repetarea șirului</h2>
     <p class="paragraph">Metoda repeat() permite crearea unui șir prin repetarea multiplă a altui șir. Numărul de repetări este transmis ca argument:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;message&nbsp;=&nbsp;"hello&nbsp;";<br>console.log(message.repeat(3));&nbsp;//&nbsp;hello&nbsp;hello&nbsp;hello</code></pre>
     </div>
     <h2 class="subtitle">Căutarea în șir</h2>
     <p class="paragraph">Pentru a căuta un subșir într-un șir se folosesc metodele indexOf() (indicele primei apariții a subșirului) și lastIndexOf() (indicele ultimei apariții a subșirului). Aceste metode primesc doi parametri:</p>
     <div class="code-inline">
      <pre><code>indexOf(str,&nbsp;index)<br>lastIndexOf(str,&nbsp;index)</code></pre>
     </div>
     <ul class="enumeration">
      <li>str: Subșirul de căutat</li>
      <li>index: Indexul de la care începe căutarea (parametru opțional)</li>
     </ul>
     <p class="paragraph">Ambele metode returnează indicele caracterului de la care începe subșirul în șir. Dacă subșirul nu este găsit, se returnează -1.</p>
     <div class="code-inline">
      <pre><code>const&nbsp;hello&nbsp;=&nbsp;"salut&nbsp;lume.&nbsp;la&nbsp;revedere&nbsp;lume";<br>const&nbsp;key&nbsp;=&nbsp;"lume";<br>const&nbsp;firstPos&nbsp;=&nbsp;hello.indexOf(key);<br>const&nbsp;lastPos&nbsp;=&nbsp;hello.lastIndexOf(key);<br>console.log("Prima&nbsp;apariție:&nbsp;",&nbsp;firstPos);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;7<br>console.log("Ultima&nbsp;apariție:&nbsp;",&nbsp;lastPos);&nbsp;&nbsp;//&nbsp;17</code></pre>
     </div>
     <p class="paragraph">Aplicăm căutarea relativ la un index, de exemplu, începând de la indexul 10:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;hello&nbsp;=&nbsp;"salut&nbsp;lume.&nbsp;la&nbsp;revedere&nbsp;lume";<br>const&nbsp;key&nbsp;=&nbsp;"lume";<br>const&nbsp;firstPos&nbsp;=&nbsp;hello.indexOf(key,&nbsp;10);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;căutare&nbsp;de&nbsp;la&nbsp;indexul&nbsp;10<br>console.log("Prima&nbsp;apariție:&nbsp;",&nbsp;firstPos);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;17</code></pre>
     </div>
     <p class="paragraph">Trebuie să ținem cont că căutarea este sensibilă la majuscule și minuscule:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;hello&nbsp;=&nbsp;"salut&nbsp;lume.&nbsp;la&nbsp;revedere&nbsp;lume";<br>const&nbsp;key&nbsp;=&nbsp;"Lume";<br>const&nbsp;firstPos&nbsp;=&nbsp;hello.indexOf(key);<br>console.log(firstPos);&nbsp;&nbsp;//&nbsp;-1</code></pre>
     </div>
     <h2 class="subtitle">Metoda includes</h2>
     <p class="paragraph">Încă o metodă - includes() returnează true dacă șirul conține un anumit subșir.</p>
     <div class="code-inline">
      <pre><code>const&nbsp;hello&nbsp;=&nbsp;"salut&nbsp;lume.&nbsp;la&nbsp;revedere&nbsp;lume";<br><br>console.log(hello.includes("lume"));&nbsp;//&nbsp;true<br>console.log(hello.includes("lumina"));&nbsp;//&nbsp;false</code></pre>
     </div>
     <p class="paragraph">Cu ajutorul celui de-al doilea parametru opțional, putem specifica indexul de la care începe căutarea subșirului:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;hello&nbsp;=&nbsp;"salut&nbsp;lume.&nbsp;la&nbsp;revedere&nbsp;lume";<br><br>console.log(hello.includes("lume",&nbsp;5));&nbsp;&nbsp;//&nbsp;true<br>console.log(hello.includes("salut",&nbsp;6));&nbsp;&nbsp;&nbsp;//&nbsp;false</code></pre>
     </div>
     <h2 class="subtitle">Alegerea unui subșir</h2>
     <p class="paragraph">Pentru a tăia un subșir dintr-un șir, se folosesc metodele substring() și slice().</p>
     <h2 class="subtitle">Metoda Substring</h2>
     <p class="paragraph">Metoda substring() primește doi parametri:</p>
     <div class="code-inline">
      <pre><code>substring(startIndex,&nbsp;endIndex)</code></pre>
     </div>
     <ul class="enumeration">
      <li>startIndex: Indexul caracterului din șir de la care să înceapă tăierea. Parametru obligatoriu.</li>
      <li>endIndex: Indexul până la care să se taie șirul. Parametru opțional - dacă nu este specificat, se taie restul șirului.</li>
     </ul>
     <div class="code-inline">
      <pre><code>const&nbsp;hello&nbsp;=&nbsp;"salut&nbsp;lume.&nbsp;la&nbsp;revedere&nbsp;lume";<br>const&nbsp;world&nbsp;=&nbsp;hello.substring(7,&nbsp;10);&nbsp;//&nbsp;de&nbsp;la&nbsp;indexul&nbsp;7&nbsp;la&nbsp;10<br>console.log(world);&nbsp;//&nbsp;lume<br>const&nbsp;bye&nbsp;=&nbsp;hello.substring(12);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;de&nbsp;la&nbsp;indexul&nbsp;12&nbsp;până&nbsp;la&nbsp;sfârșitul&nbsp;șirului<br>console.log(bye);&nbsp;//&nbsp;la&nbsp;revedere&nbsp;lume</code></pre>
     </div>
     <h2 class="subtitle">Metoda slice</h2>
     <p class="paragraph">Metoda slice permite, de asemenea, obținerea unei părți dintr-un șir. Aceasta primește doi parametri:</p>
     <div class="code-inline">
      <pre><code>slice(startIndex,&nbsp;endIndex)</code></pre>
     </div>
     <ul class="enumeration">
      <li>Indexul de început al subșirului în șir. Parametru obligatoriu.</li>
      <li>Indexul de sfârșit al subșirului în șir. Parametru opțional - dacă nu este specificat, se taie restul șirului.</li>
     </ul>
     <div class="code-inline">
      <pre><code>const&nbsp;hello&nbsp;=&nbsp;"salut&nbsp;lume.&nbsp;la&nbsp;revedere&nbsp;lume";<br>const&nbsp;world&nbsp;=&nbsp;hello.slice(6,&nbsp;10);&nbsp;//&nbsp;de&nbsp;la&nbsp;indexul&nbsp;6&nbsp;la&nbsp;10<br>console.log(world);&nbsp;//&nbsp;lume<br>const&nbsp;bye&nbsp;=&nbsp;hello.slice(12);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;de&nbsp;la&nbsp;indexul&nbsp;12&nbsp;până&nbsp;la&nbsp;sfârșitul&nbsp;șirului<br>console.log(bye);&nbsp;//&nbsp;la&nbsp;revedere&nbsp;lume</code></pre>
     </div>
     <p class="paragraph">Se poate observa că această metodă este similară cu metoda substring(). Cu toate acestea, există mici diferențe între ele. În primul rând, în slice(), indexul de început trebuie să fie mai mic decât indexul de sfârșit. În substring(), dacă indexul de început este mai mare decât indexul de sfârșit, acestea sunt schimbate (adică substring(5, 1) va fi echivalent cu substring(1, 5)):</p>
     <div class="code-inline">
      <pre><code>const&nbsp;hello&nbsp;=&nbsp;"salut&nbsp;lume.&nbsp;la&nbsp;revedere&nbsp;lume";<br>const&nbsp;world1&nbsp;=&nbsp;hello.slice(6,&nbsp;0);&nbsp;//&nbsp;nu&nbsp;funcționează<br>console.log(world1);&nbsp;//&nbsp;șir&nbsp;gol<br>const&nbsp;world2&nbsp;=&nbsp;hello.substring(6,&nbsp;0);&nbsp;//&nbsp;echivalent&nbsp;cu&nbsp;hello.substring(0,&nbsp;6)<br>console.log(world2);&nbsp;//&nbsp;salut</code></pre>
     </div>
     <p class="paragraph">O altă diferență este că slice() permite utilizarea de indecși negativi. Un index negativ indică indexul caracterului față de sfârșitul șirului. substring() nu suportă însă indecșii negativi:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;hello&nbsp;=&nbsp;"salut&nbsp;lume.&nbsp;la&nbsp;revedere&nbsp;lume";<br>const&nbsp;bye1&nbsp;=&nbsp;hello.slice(-8,&nbsp;-4);&nbsp;//&nbsp;de&nbsp;la&nbsp;indexul&nbsp;8&nbsp;de&nbsp;la&nbsp;sfârșit&nbsp;până&nbsp;la&nbsp;4&nbsp;de&nbsp;la&nbsp;sfârșit<br>console.log(bye1);&nbsp;//&nbsp;la<br>const&nbsp;bye2&nbsp;=&nbsp;hello.substring(-8,&nbsp;-4);&nbsp;//&nbsp;nu&nbsp;funcționează<br>console.log(bye2);&nbsp;//</code></pre>
     </div>
     <h2 class="subtitle">Metoda substr</h2>
     <p class="paragraph">Trebuie de menționat că există și metoda substr(). Această metodă nu face parte din standard și, în general, nu este recomandată pentru utilizare. Cu toate acestea, încă poate fi acceptată de browsere și o puteți întâlni în diferite programe. Aceasta primește doi parametri:</p>
     <div class="code-inline">
      <pre><code>substr(startIndex,&nbsp;count)</code></pre>
     </div>
     <ul class="enumeration">
      <li>startIndex: Indexul caracterului din șir de la care să înceapă selectarea. Parametru obligatoriu.</li>
      <li>count: Numărul de caractere de selectat. Parametru opțional - dacă nu este specificat, se selectează restul șirului.</li>
     </ul>
     <p class="paragraph">Exemplu:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;hello&nbsp;=&nbsp;"salut&nbsp;lume.&nbsp;la&nbsp;revedere&nbsp;lume";<br>const&nbsp;world&nbsp;=&nbsp;hello.substr(6,&nbsp;3);&nbsp;//&nbsp;de&nbsp;la&nbsp;indexul&nbsp;6,&nbsp;3&nbsp;caractere<br>console.log(world);&nbsp;//&nbsp;lume<br>const&nbsp;bye&nbsp;=&nbsp;hello.substr(12);&nbsp;//&nbsp;de&nbsp;la&nbsp;indexul&nbsp;12&nbsp;până&nbsp;la&nbsp;sfârșitul&nbsp;șirului<br>console.log(bye);&nbsp;//&nbsp;la&nbsp;revedere&nbsp;lume</code></pre>
     </div>
     <h2 class="subtitle">Controlul majusculelor și minusculelor</h2>
     <p class="paragraph">Pentru a schimba registrul caracterelor, există metodele toLowerCase() (pentru a converti la litere mici) și toUpperCase() (pentru a converti la litere mari).</p>
     <div class="code-inline">
      <pre><code>const&nbsp;hello&nbsp;=&nbsp;"Salut&nbsp;Tom";<br>console.log(hello.toLowerCase());&nbsp;//&nbsp;salut&nbsp;tom<br>console.log(hello.toUpperCase());&nbsp;//&nbsp;SALUT&nbsp;TOM</code></pre>
     </div>
     <h2 class="subtitle">Obținerea unui caracter după index</h2>
     <p class="paragraph">Pentru a obține un anumit caracter în șir la un anumit index, se poate utiliza sintaxa de array. Totuși, JavaScript oferă și metodele charAt() și charCodeAt(). Ambele metode primesc indexul caracterului ca parametru:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;hello&nbsp;=&nbsp;"Salut&nbsp;Tom";<br>console.log(hello.charAt(2));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;i<br>console.log(hello.charCodeAt(2));&nbsp;&nbsp;&nbsp;//&nbsp;108</code></pre>
     </div>
     <p class="paragraph">Dar în timp ce metoda charAt() returnează caracterul însuși ca rezultat, metoda charCodeAt() returnează codul numeric al acelui caracter.</p>
     <h2 class="subtitle">Eliminarea spațiilor goale</h2>
     <p class="paragraph">Pentru a elimina spațiile goale inițiale și finale dintr-un șir, se utilizează metoda trim():</p>
     <div class="code-inline">
      <pre><code>let&nbsp;hello&nbsp;=&nbsp;"&nbsp;&nbsp;&nbsp;Salut&nbsp;Tom&nbsp;&nbsp;";<br>const&nbsp;beforeLength&nbsp;=&nbsp;hello.length;<br>hello&nbsp;=&nbsp;hello.trim();<br>const&nbsp;afterLength&nbsp;=&nbsp;hello.length;<br>console.log("Lungimea&nbsp;șirului&nbsp;înainte:&nbsp;",&nbsp;beforeLength);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;17<br>console.log("Lungimea&nbsp;șirului&nbsp;după:&nbsp;",&nbsp;afterLength);&nbsp;&nbsp;&nbsp;//&nbsp;10</code></pre>
     </div>
     <p class="paragraph">Eliminarea spațiilor goale de la începutul și sfârșitul șirului:</p>
     <ul class="enumeration">
      <li>trimStart(): elimină spațiul gol de la începutul șirului (în funcție de direcția de scriere, acesta poate fi marginea dreaptă sau stângă a șirului)</li>
      <li>trimEnd(): elimină spațiul gol de la sfârșitul șirului (în funcție de direcția de scriere, acesta poate fi marginea dreaptă sau stângă a șirului)</li>
      <li>trimLeft(): elimină spațiul gol de la stânga șirului</li>
      <li>trimRight(): elimină spațiul gol de la dreapta șirului</li>
     </ul>
     <h2 class="subtitle">Concatenarea șirurilor</h2>
     <p class="paragraph">Metoda concat() unește două șiruri:</p>
     <div class="code-inline">
      <pre><code>let&nbsp;hello&nbsp;=&nbsp;"Salut&nbsp;";<br>const&nbsp;world&nbsp;=&nbsp;"Tom";<br>hello&nbsp;=&nbsp;hello.concat(world);<br>console.log(hello);&nbsp;//&nbsp;Salut&nbsp;Tom</code></pre>
     </div>
     <h2 class="subtitle">Înlocuirea unui subșir</h2>
     <p class="paragraph">Metoda replace() înlocuiește prima apariție a unui subșir cu altul:</p>
     <div class="code-inline">
      <pre><code>let&nbsp;hello&nbsp;=&nbsp;"Bună&nbsp;ziua";<br>hello&nbsp;=&nbsp;hello.replace("ziua",&nbsp;"seară");<br>console.log(hello);&nbsp;//&nbsp;Bună&nbsp;seară</code></pre>
     </div>
     <p class="paragraph">Primul parametru al metodei indică subșirul care trebuie înlocuit, iar al doilea parametru indică subșirul cu care trebuie înlocuit.</p>
     <p class="paragraph">Cu toate acestea, această metodă are o caracteristică - înlocuiește doar prima apariție a subșirului:</p>
     <div class="code-inline">
      <pre><code>let&nbsp;menu&nbsp;=&nbsp;"Mic&nbsp;dejun:&nbsp;fulgi&nbsp;de&nbsp;ovăz,&nbsp;ceai.&nbsp;Prânz:&nbsp;supă,&nbsp;ceai.&nbsp;Cină:&nbsp;salată,&nbsp;ceai.";<br>menu&nbsp;=&nbsp;menu.replace("ceai",&nbsp;"cafea");<br>console.log(menu);&nbsp;&nbsp;//&nbsp;Mic&nbsp;dejun:&nbsp;fulgi&nbsp;de&nbsp;ovăz,&nbsp;cafea.&nbsp;Prânz:&nbsp;supă,&nbsp;ceai.&nbsp;Cină:&nbsp;salată,&nbsp;ceai.</code></pre>
     </div>
     <p class="paragraph">Cu toate acestea, o altă metodă - replaceAll() - permite înlocuirea tuturor aparițiilor ale subșirului:</p>
     <div class="code-inline">
      <pre><code>let&nbsp;menu&nbsp;=&nbsp;"Mic&nbsp;dejun:&nbsp;fulgi&nbsp;de&nbsp;ovăz,&nbsp;ceai.&nbsp;Prânz:&nbsp;supă,&nbsp;ceai.&nbsp;Cină:&nbsp;salată,&nbsp;ceai.";<br>menu&nbsp;=&nbsp;menu.replaceAll("ceai",&nbsp;"cafea");<br>console.log(menu);&nbsp;&nbsp;//&nbsp;Mic&nbsp;dejun:&nbsp;fulgi&nbsp;de&nbsp;ovăz,&nbsp;cafea.&nbsp;Prânz:&nbsp;supă,&nbsp;cafea.&nbsp;Cină:&nbsp;salată,&nbsp;cafea.</code></pre>
     </div>
     <h2 class="subtitle">Despărțirea șirului</h2>
     <p class="paragraph">Metoda split() împarte un șir într-un array de subșiruri, folosind un anumit separator. Separatorul este transmis ca argument:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;message&nbsp;=&nbsp;"Astăzi&nbsp;a&nbsp;fost&nbsp;vreme&nbsp;frumoasă";<br>const&nbsp;messageParts&nbsp;=&nbsp;message.split("&nbsp;");<br>console.log(messageParts);&nbsp;&nbsp;//&nbsp;["Astăzi",&nbsp;"a",&nbsp;"fost",&nbsp;"vreme",&nbsp;"frumoasă"]</code></pre>
     </div>
     <p class="paragraph">În acest caz, șirul este despărțit în funcție de spațiu, astfel încât array-ul messageParts conține patru elemente.</p>
     <h2 class="subtitle">Verificarea începutului și sfârșitului șirului</h2>
     <p class="paragraph">Metoda startsWith() returnează true dacă șirul începe cu un anumit subșir. Metoda endsWith() returnează true dacă șirul se termină cu un anumit subșir.</p>
     <div class="code-inline">
      <pre><code>const&nbsp;hello&nbsp;=&nbsp;"let&nbsp;me&nbsp;speak&nbsp;from&nbsp;my&nbsp;heart";<br>console.log(hello.startsWith("let"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;true<br>console.log(hello.startsWith("Let"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;false<br>console.log(hello.startsWith("lets"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;false<br><br>console.log(hello.endsWith("heart"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;true<br>console.log(hello.startsWith("bart"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;false</code></pre>
     </div>
     <p class="paragraph">Joacă un rol și sensibilitatea la majuscule și minuscule, și din exemplul de mai sus vedem că "let" nu este echivalent cu "Let".</p>
     <p class="paragraph">Un al doilea parametru suplimentar permite specificarea unui index (pentru startsWith - index de la început și pentru endsWith - index de la sfârșitul șirului) în raport cu care se va face comparația:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;hello&nbsp;=&nbsp;"let&nbsp;me&nbsp;speak&nbsp;from&nbsp;my&nbsp;heart";<br>console.log(hello.startsWith("me",&nbsp;4));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;true,&nbsp;"me"&nbsp;-&nbsp;index&nbsp;4&nbsp;de&nbsp;la&nbsp;începutul&nbsp;șirului<br><br>console.log(hello.startsWith("my",&nbsp;hello.length-8));&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;true,&nbsp;"my"&nbsp;-&nbsp;index&nbsp;8&nbsp;de&nbsp;la&nbsp;sfârșit</code></pre>
     </div>
     <h2 class="subtitle">Umplerea șirului</h2>
     <p class="paragraph">Metodele padStart() și padEnd() extind un șir la un număr specific de caractere și umplu șirul la stânga și, respectiv, la dreapta.</p>
     <div class="code-inline">
      <pre><code>let&nbsp;hello&nbsp;=&nbsp;"hello".padStart(8);&nbsp;&nbsp;//&nbsp;"&nbsp;&nbsp;&nbsp;hello"<br>console.log(hello);<br>hello&nbsp;=&nbsp;"hello".padEnd(8);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;"hello&nbsp;&nbsp;&nbsp;"<br>console.log(hello);</code></pre>
     </div>
     <p class="paragraph">Apelul "hello".padStart(8) va extinde șirul "hello" la 8 caractere. Adică inițial în șirul "hello" sunt 5 caractere, astfel că vor fi adăugate 3 caractere. Acestea vor fi adăugate la începutul șirului. În mod implicit, caracterele adăugate spații goale. Similar, apelul "hello".padEnd(8) va extinde șirul la 8 caractere, dar caracterele rămase sub formă de spații goale vor fi adăugate la sfârșitul șirului.</p>
     <p class="paragraph">În mod implicit, aceste metode utilizează spații goale pentru umplere, dar ca al doilea parametru putem furniza metodelor valoarea cu care să umplem șirul:</p>
     <div class="code-inline">
      <pre><code>let&nbsp;hello&nbsp;=&nbsp;"hello".padStart(17,&nbsp;"JavaScript,&nbsp;");&nbsp;&nbsp;//&nbsp;"JavaScript,&nbsp;hello"<br>hello&nbsp;=&nbsp;"hello".padEnd(12,&nbsp;"&nbsp;Eugene");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;"hello&nbsp;Eugene"</code></pre>
     </div>
     <p class="paragraph">Dacă numărul de caractere adăugate este mai mare decât lungimea șirului adăugat, atunci șirul adăugat se repetă:</p>
     <div class="code-inline">
      <pre><code>let&nbsp;hello&nbsp;=&nbsp;"123".padStart(6,&nbsp;"0");&nbsp;&nbsp;//&nbsp;"000123"<br>hello&nbsp;=&nbsp;"123".padEnd(6,&nbsp;"0");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;"123000"</code></pre>
     </div>
    </div>
   </main>
   <aside class="ad-section">
    <div class="ad-box">
     <p>Google Ad Here</p>
    </div>
    <div class="ad-box">
     <p>Promo: SQL Beginner Guide</p>
    </div>
   </aside>
  </div>
  <div class="lesson-navigation">
   <th:block th:if="${previousLesson != null}">
    <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția anterioară</a>
   </th:block> <th:block th:if="${nextLesson != null}">
    <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția următoare →</a>
   </th:block>
  </div>
  <div th:replace="~{fragments/footer :: footer}"></div>
  <script th:src="@{/js/script.js}" defer></script>
 </body>
</html>
