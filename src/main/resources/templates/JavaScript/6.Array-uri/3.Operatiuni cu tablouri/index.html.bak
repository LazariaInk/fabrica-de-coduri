<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">
 <head>
    <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      window.gtag = function () { dataLayer.push(arguments); };
      gtag('consent', 'default', {
        'wait_for_update': 500,
        'region': ['RO'],
        'ad_storage': 'denied',
        'analytics_storage': 'denied',
        'ad_user_data': 'denied',
        'ad_personalization': 'denied'
      });
      gtag('js', new Date());
      gtag('config', 'G-7Q2536ZKL2');
    </script>


  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title th:text="${lesson.title}">Lesson</title>
  <link rel="stylesheet" th:href="@{/css/styles.css}">
  <style>body { background: #ffffff; }</style>
 </head>
 <body th:with="activeTopic='JavaScript', activeChapter='6.Array-uri', activeLesson='3.Operatiuni cu tablouri'">
  <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
  <div th:replace="~{fragments/nav :: nav}"></div>
  <div class="top-nav">
   <th:block th:each="topic : ${topics}">
    <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}" th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a>
   </th:block>
  </div>
  <div class="layout">
   <div class="mobile-sidebar" id="mobileSidebar">
    <button class="close-btn" onclick="toggleSidebar()">✖</button>
    <ul class="chapter-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-title" onclick="toggleChapter(this)">
        <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
       </div>
       <ul class="lesson-list">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lessons/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </div>
   <aside class="sidebar">
    <ul class="sidebar-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-toggle" onclick="toggleLessons(this)">
        <span th:text="${chapter.title}">Chapter</span>
       </div>
       <ul class="lesson-list hidden">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lessons/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </aside>
   <main class="content">
    <div class="document-container">
     <h1 class="main-title">Operațiuni cu tablouri</h1>
     <p class="paragraph">JavaScript oferă ample posibilități pentru manipularea tablourilor, realizate prin intermediul metodelor obiectului Array:</p>
     <ul class="enumeration">
      <li>concat(): unifică elementele a două tablouri într-un singur tablou</li>
      <li>every(): verifică dacă toate elementele corespund unei anumite condiții</li>
      <li>filter(): filtrează elementele unui tablou</li>
      <li>find(): returnează primul element al unui tablou care satisface o anumită condiție</li>
      <li>findLast(): returnează ultimul element care satisface o condiție</li>
      <li>findIndex(): returnează indexul primului element dintr-un tablou care satisface o condiție</li>
      <li>findLastIndex(): returnează indexul ultimului element care satisface o condiție</li>
      <li>flat(): simplifică structura elementelor tabloului în mod recursiv</li>
      <li>forEach(): aplică o funcție specifică fiecărui element al tabloului</li>
      <li>includes(): verifică dacă o valoare există în tablou</li>
      <li>indexOf(): returnează indexul primei apariții a unui element în tablou</li>
      <li>join(): unește elementele tabloului într-un șir de caractere</li>
      <li>lastIndexOf(): returnează indexul ultimei apariții a unui element în tablou</li>
      <li>map(): transformă fiecare element al tabloului în altă valoare în funcție de o funcție de proiecție</li>
      <li>pop(): elimină ultimul element al tabloului</li>
      <li>push(): adaugă un element la sfârșitul tabloului</li>
      <li>reduce(): combină elementele tabloului într-o singură valoare</li>
      <li>reverse(): inversează ordinea elementelor în tablou</li>
      <li>shift(): elimină primul element al tabloului</li>
      <li>slice(): extrage porțiuni de elemente din tablou</li>
      <li>splice(): adaugă sau elimină elemente la/din anumite poziții din tablou</li>
      <li>some(): verifică dacă cel puțin un element corespunde unei condiții</li>
      <li>sort(): sortează elementele tabloului</li>
      <li>unshift(): adaugă un nou element la începutul tabloului</li>
     </ul>
     <p class="paragraph">Să analizăm aplicarea acestor metode.</p>
     <h2 class="subtitle">Adăugarea de date</h2>
     <p class="paragraph">push()</p>
     <p class="paragraph">Metoda push() adaugă un element la sfârșitul unui array.</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;[];<br>people.push("Tom");<br>people.push("Sam");<br>people.push("Bob",&nbsp;"Mike");<br><br>console.log("În&nbsp;tabloul&nbsp;people&nbsp;există&nbsp;elemente:&nbsp;",&nbsp;people.length);<br>console.log(people);&nbsp;//&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bob",&nbsp;"Mike"]</code></pre>
     </div>
     <p class="paragraph">unshift()</p>
     <p class="paragraph">Metoda unshift() adaugă un nou element la începutul unui array.</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;["Bob"];<br><br>people.unshift("Alice");<br>console.log(people);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Alice",&nbsp;"Bob"]<br><br>people.unshift("Tom",&nbsp;"Sam");<br>console.log(people);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Alice",&nbsp;"Bob"]</code></pre>
     </div>
     <h2 class="subtitle">Adăugarea datelor la un anumit index</h2>
     <p class="paragraph">Metoda splice permite inserarea de elemente la o anumită poziție. Primul argument reprezintă indexul în tablou unde trebuie adăugate noile elemente. Al doilea argument reprezintă numărul de elemente care trebuie eliminate (această metodă este de asemenea folosită și pentru ștergere). Pentru adăugare, acest argument este setat la valoarea 0. Toate celelalte argumente reprezintă elementele care trebuie adăugate în tablou.</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bob"];<br>people.splice(1,&nbsp;0,&nbsp;"Alice");&nbsp;&nbsp;//&nbsp;Adăugăm&nbsp;elementul&nbsp;"Alice"&nbsp;la&nbsp;indexul&nbsp;1.<br>console.log(people);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Tom",&nbsp;"Alice",&nbsp;"Sam",&nbsp;"Bob"]</code></pre>
     </div>
     <p class="paragraph">În această situație, adăugăm elementul "Alice" la indexul 1.</p>
     <p class="paragraph">De asemenea, se poate adăuga un set de elemente începând de la un anumit index:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bob"];<br>people.splice(1,&nbsp;0,&nbsp;"Alice",&nbsp;"Alex",&nbsp;"Kate");&nbsp;&nbsp;//&nbsp;&nbsp;Adăugăm&nbsp;elementul&nbsp;"Alice"&nbsp;la&nbsp;indexul&nbsp;1.<br>console.log(people);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Tom",&nbsp;"Alice",&nbsp;"Alex",&nbsp;"Kate",&nbsp;"Sam",&nbsp;"Bob"]</code></pre>
     </div>
     <h2 class="subtitle">Eliminarea datelor</h2>
     <p class="paragraph">pop()</p>
     <p class="paragraph">Metoda pop() elimină ultimul element dintr-un array.</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bob",&nbsp;"Mike"];<br><br>const&nbsp;lastPerson&nbsp;=&nbsp;people.pop();&nbsp;//Extragem&nbsp;ultimul&nbsp;element&nbsp;dintr-un&nbsp;array.<br>console.log(lastPerson&nbsp;);&nbsp;&nbsp;&nbsp;//&nbsp;Mike<br>console.log(people);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bob"]</code></pre>
     </div>
     <p class="paragraph">În calitate de rezultat, metoda pop returnează elementul eliminat.</p>
     <p class="paragraph">shift()</p>
     <p class="paragraph">Metoda shift() extrage și elimină primul element dintr-un array:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bob",&nbsp;"Mike"];<br><br>const&nbsp;first&nbsp;=&nbsp;people.shift();&nbsp;//Extragem&nbsp;primul&nbsp;element&nbsp;dintr-un&nbsp;array.<br>console.log(first);&nbsp;//&nbsp;Tom<br>console.log(people);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Sam",&nbsp;"Bob",&nbsp;"Mike"]</code></pre>
     </div>
     <h2 class="subtitle">Eliminarea unui element după index.splice()</h2>
     <p class="paragraph">Metoda splice() elimină, de asemenea, elemente de la un anumit index. De exemplu, eliminarea elementelor de la indexul al treilea:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bill",&nbsp;"Alice",&nbsp;"Kate"];<br>const&nbsp;deleted&nbsp;=&nbsp;people.splice(3);<br>console.log(deleted);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;[&nbsp;"Alice",&nbsp;"Kate"&nbsp;]<br>console.log(people);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;[&nbsp;"Tom",&nbsp;"Sam",&nbsp;"Bill"&nbsp;]</code></pre>
     </div>
     <p class="paragraph">Metoda splice() returnează elementele eliminate sub forma unui nou array.</p>
     <p class="paragraph">În această situație, eliminarea începe de la începutul tabloului. Dacă se furnizează un index negativ, eliminarea va începe de la sfârșitul tabloului. De exemplu, să eliminăm ultimul element:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bill",&nbsp;"Alice",&nbsp;"Kate"];<br>const&nbsp;deleted&nbsp;=&nbsp;people.splice(-1);<br>console.log(deleted);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;[&nbsp;"Kate"&nbsp;]<br>console.log(people);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bill",&nbsp;"Alice"]</code></pre>
     </div>
     <p class="paragraph">Varianta suplimentară a metodei permite specificarea numărului de elemente de eliminat. De exemplu, să eliminăm trei elemente de la primul index:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bill",&nbsp;"Alice",&nbsp;"Kate"];<br>const&nbsp;deleted&nbsp;=&nbsp;people.splice(1,&nbsp;3);<br>console.log(deleted);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Sam",&nbsp;"Bill",&nbsp;"Alice"]<br>console.log(people);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Tom",&nbsp;"Kate"]</code></pre>
     </div>
     <h2 class="subtitle">Înlocuirea elementelor</h2>
     <p class="paragraph">Metoda splice() permite atât adăugarea, cât și eliminarea elementelor. Putem combina aceste două funcționalități pentru a înlocui unii elemente dintr-un tablou cu alții. De exemplu:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bob",&nbsp;"Alice",&nbsp;"Kate"];<br>const&nbsp;deleted&nbsp;=&nbsp;people.splice(1,&nbsp;3,&nbsp;"Alex",&nbsp;"Mike");<br>console.log(deleted);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Sam",&nbsp;"Bob",&nbsp;"Alice"]<br>console.log(people);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Tom",&nbsp;"Alex",&nbsp;"Mike",&nbsp;"Kate"]</code></pre>
     </div>
     <p class="paragraph">În acest caz, eliminăm de la indexul 1 (primul parametru al lui splice) 3 elemente (al doilea parametru al lui splice) și, în locul lor, inserăm două elemente - "Alex" și "Mike".</p>
     <h2 class="subtitle">Copierea unui tablou</h2>
     <p class="paragraph">Metoda slice()</p>
     <p class="paragraph">Copierea unui tablou poate fi superficială (shallow copy) sau adâncă (deep copy).</p>
     <p class="paragraph">În cazul copierii superficiale, este suficient să atribuim variabilei valoarea altei variabile care stochează tabloul:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;users&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bill"];<br>console.log(users);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bill"]<br>const&nbsp;people&nbsp;=&nbsp;users;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;copiere&nbsp;superficială<br><br>people[1]&nbsp;=&nbsp;"Mike";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;modificăm&nbsp;al&nbsp;doilea&nbsp;element<br>console.log(users);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;["Tom",&nbsp;"Mike",&nbsp;"Bill"]</code></pre>
     </div>
     <p class="paragraph">În acest caz, variabila "people", după copiere, va face referire la același tablou ca și variabila "users". Prin urmare, atunci când modificăm elementele în "people", se vor modifica și elementele în "users", deoarece acestea sunt, de fapt, același tablou.</p>
     <p class="paragraph">Un astfel de comportament nu este întotdeauna dorit. De exemplu, putem dori ca, după copiere, variabilele să facă referire la tablouri separate. În acest caz, putem utiliza o copie profundă folosind metoda slice().</p>
     <div class="code-inline">
      <pre><code>const&nbsp;users&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bill"];<br>console.log(users);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bill"]<br>const&nbsp;people&nbsp;=&nbsp;users.slice();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;copiere&nbsp;adâncă<br><br>people[1]&nbsp;=&nbsp;"Mike";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;modificăm&nbsp;al&nbsp;doilea&nbsp;element<br>console.log(users);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bill"]<br>console.log(people);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;["Tom",&nbsp;"Mike",&nbsp;"Bill"]</code></pre>
     </div>
     <p class="paragraph">În acest caz, după copiere, variabilele vor face referire la tablouri diferite, și vom putea să le modificăm separat.</p>
     <p class="paragraph">Totuși, merită de menționat că aceeași copiere se poate realiza, de fapt, și cu ajutorul operatorului spread ...:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;users&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bill"];<br>console.log(users);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bill"]<br>const&nbsp;people&nbsp;=&nbsp;[...users];<br>&nbsp;<br>people[1]&nbsp;=&nbsp;"Mike";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;modificăm&nbsp;al&nbsp;doilea&nbsp;element<br>console.log(users);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bill"]<br>console.log(people);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;["Tom",&nbsp;"Mike",&nbsp;"Bill"]</code></pre>
     </div>
     <p class="paragraph">De asemenea, metoda slice() permite copierea unei părți a unui array. Pentru aceasta, acceptă doi parametri:</p>
     <div class="code-inline">
      <pre><code>slice(începutul_indexului,&nbsp;sfârșitul_indexului)</code></pre>
     </div>
     <p class="paragraph">Primul parametru indică indexul de început al elementului de la care se începe extragerea valorilor din array. Al doilea parametru reprezintă indexul final, până la care se face copierea.</p>
     <p class="paragraph">Dacă este specificat doar începutul indexului și acesta este un număr pozitiv, atunci copierea se face de la acest index până la sfârșitul array-ului:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;users&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bill",&nbsp;"Alice",&nbsp;"Kate"];<br>const&nbsp;people&nbsp;=&nbsp;users.slice(2);&nbsp;&nbsp;//&nbsp;de&nbsp;la&nbsp;al&nbsp;2-lea&nbsp;index&nbsp;până&nbsp;la&nbsp;sfîrșit<br>console.log(people);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Bill",&nbsp;"Alice",&nbsp;"Kate"]</code></pre>
     </div>
     <p class="paragraph">Dacă este specificat doar începutul indexului și acesta este un număr negativ, indexul este numărat de la sfârșitul array-ului, iar copierea se face de la sfârșitul array-ului până la acest index:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;users&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bill",&nbsp;"Alice",&nbsp;"Kate"];<br>const&nbsp;people&nbsp;=&nbsp;users.slice(-2);&nbsp;&nbsp;//&nbsp;până&nbsp;la&nbsp;al&nbsp;2-lea&nbsp;index&nbsp;de&nbsp;la&nbsp;sfîrșit<br>console.log(people);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Alice",&nbsp;"Kate"]</code></pre>
     </div>
     <p class="paragraph">Al doilea parametru permite să restricționați selecția elementelor copiate. De exemplu, să alegem într-un nou array elementele începând cu indexul 1 până la indexul 4, fără a-l include:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;users&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bill",&nbsp;"Alice",&nbsp;"Kate"];<br>const&nbsp;people&nbsp;=&nbsp;users.slice(1,&nbsp;4);<br>console.log(people);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Sam",&nbsp;"Bill",&nbsp;"Alice"]</code></pre>
     </div>
     <p class="paragraph">Și deoarece indexarea array-urilor începe de la zero, atunci în noul array vor fi incluse al doilea, al treilea și al patrulea element.</p>
     <p class="paragraph">De asemenea, al doilea parametru poate fi negativ. În acest caz, al doilea index este numărat de la sfârșit:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;users&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bill",&nbsp;"Alice",&nbsp;"Kate"];<br>const&nbsp;people&nbsp;=&nbsp;users.slice(2,&nbsp;-1);&nbsp;&nbsp;//&nbsp;De&nbsp;la&nbsp;indexul&nbsp;2&nbsp;până&nbsp;la&nbsp;indexul&nbsp;1&nbsp;de&nbsp;la&nbsp;sfârșit:<br>console.log(people);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Bill",&nbsp;"Alice"]</code></pre>
     </div>
     <p class="paragraph">copyWithin()</p>
     <p class="paragraph">Metoda copyWithin() permite copierea elementelor în interiorul unui array. Aceasta acceptă trei parametri:</p>
     <div class="code-inline">
      <pre><code>copyWithin(index1,&nbsp;&nbsp;//&nbsp;poziția&nbsp;la&nbsp;care&nbsp;sunt&nbsp;copiate&nbsp;elementele<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index2,&nbsp;&nbsp;//&nbsp;poziția&nbsp;de&nbsp;start&nbsp;de&nbsp;la&nbsp;care&nbsp;vor&nbsp;fi&nbsp;copiate&nbsp;elementele<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index3&nbsp;&nbsp;&nbsp;//&nbsp;poziția&nbsp;finală&nbsp;până&nbsp;la&nbsp;care&nbsp;vor&nbsp;fi&nbsp;copiate&nbsp;elementele<br>)</code></pre>
     </div>
     <p class="paragraph">Exemplu de utilizare:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;users&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bob",&nbsp;"Alice",&nbsp;"Kate"];<br>const&nbsp;people&nbsp;=&nbsp;users.copyWithin(1,&nbsp;3,&nbsp;5);&nbsp;&nbsp;//&nbsp;elementele&nbsp;de&nbsp;la&nbsp;indexul&nbsp;3&nbsp;la&nbsp;indexul&nbsp;4&nbsp;(două&nbsp;elemente)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;sunt&nbsp;copiate&nbsp;la&nbsp;indexul&nbsp;1<br>console.log(people);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Tom",&nbsp;"Alice",&nbsp;"Kate",&nbsp;"Alice",&nbsp;"Kate"]</code></pre>
     </div>
     <h2 class="subtitle">Obținerea elementelor în afara intervalului. toSpliced()</h2>
     <p class="paragraph">Dar, poate că dorim doar să obținem elementele în afara unui anumit interval fără a modifica array-ul curent. În acest caz, putem utiliza metoda toSpliced(). Această metodă returnează un array format din elementele care se află în afara intervalului specificat:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bill",&nbsp;"Alice",&nbsp;"Kate"];<br>const&nbsp;range&nbsp;=&nbsp;people.toSpliced(1,&nbsp;3);<br>console.log(range);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Tom",&nbsp;"Kate"]<br>console.log(people);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bill",&nbsp;"Alice",&nbsp;"Kate"]</code></pre>
     </div>
     <p class="paragraph">concat()</p>
     <p class="paragraph">Metoda concat() este folosită pentru a uni array-uri. Ca rezultat, returnează array-ul unit:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;men&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bob"];<br>const&nbsp;women&nbsp;=&nbsp;["Alice",&nbsp;"Kate"];<br>const&nbsp;people&nbsp;=&nbsp;men.concat(women);<br>console.log(people);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bob",&nbsp;"Alice",&nbsp;"Kate"]</code></pre>
     </div>
     <p class="paragraph">join()</p>
     <p class="paragraph">Metoda join() concatenează toate elementele unui array într-un singur șir, folosind un separator specificat, care este transmis prin parametru:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bob"];<br><br>const&nbsp;peopleToString&nbsp;=&nbsp;people.join(";&nbsp;");<br>console.log(peopleToString);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Tom;&nbsp;Sam;&nbsp;Bob</code></pre>
     </div>
     <p class="paragraph">În metoda join(), se furnizează un separator între elementele array-ului. În acest caz, ca separator va fi utilizată virgula și spațiul ("; ").</p>
     <h2 class="subtitle">sort() și toSorted.</h2>
     <p class="paragraph">Metoda sort() sortează array-ul în ordine crescătoare:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bob"];<br><br>people.sort();<br>console.log(people);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Bob",&nbsp;"Sam",&nbsp;"Tom"]</code></pre>
     </div>
     <p class="paragraph">Merită de menționat că, în mod implicit, metoda sort() tratează elementele array-ului ca șiruri și le sortează în ordine alfabetică. Acest lucru poate duce la rezultate neașteptate, de exemplu:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;numbers&nbsp;=&nbsp;[200,&nbsp;15,&nbsp;5,&nbsp;35];<br><br>numbers.sort();<br>console.log(numbers);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;[15,&nbsp;200,&nbsp;35,&nbsp;5]</code></pre>
     </div>
     <p class="paragraph">Aici vrem să sortăm un array de numere, dar rezultatul poate fi dezamăgitor: [15, 200, 35, 5]. În acest caz, putem personaliza metoda, transmițându-i o funcție de sortare. Logica funcției de sortare este definită de noi înșine:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;numbers&nbsp;=&nbsp;[200,&nbsp;15,&nbsp;5,&nbsp;35];<br><br>numbers.sort(&nbsp;(a,&nbsp;b)&nbsp;=&gt;&nbsp;&nbsp;a&nbsp;-&nbsp;b);<br>console.log(numbers);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;[5,&nbsp;15,&nbsp;35,&nbsp;200]</code></pre>
     </div>
     <p class="paragraph">Funcția de sortare primește două elemente consecutive ale array-ului. Aceasta returnează un număr negativ dacă primul element trebuie să fie înaintea celui de-al doilea element. Dacă primul element trebuie să fie după cel de-al doilea, atunci se returnează un număr pozitiv. Dacă elementele sunt egale, se returnează 0.</p>
     <p class="paragraph">JavaScript oferă, de asemenea, metoda toSorted(), care returnează elementele sortate sub forma unui nou array, fără a modifica array-ul curent:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;numbers&nbsp;=&nbsp;[200,&nbsp;15,&nbsp;5,&nbsp;35];<br><br>const&nbsp;sorted&nbsp;=&nbsp;numbers.toSorted();<br>console.log(sorted);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;[15,&nbsp;200,&nbsp;35,&nbsp;5]</code></pre>
     </div>
     <p class="paragraph">Implicit, metoda toSorted() sortează și ea în ordine alfabetică. Cu toate acestea, puteți furniza metodei o funcție de comparație pentru a personaliza modul în care elementele sunt sortate:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;numbers&nbsp;=&nbsp;[200,&nbsp;15,&nbsp;5,&nbsp;35];<br>const&nbsp;sorted&nbsp;=&nbsp;numbers.toSorted(&nbsp;(a,&nbsp;b)&nbsp;=&gt;&nbsp;&nbsp;a&nbsp;-&nbsp;b);<br>console.log(sorted);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;[5,&nbsp;15,&nbsp;35,&nbsp;200]</code></pre>
     </div>
     <h2 class="subtitle">reverse() și toReversed().</h2>
     <p class="paragraph">Metoda reverse() inversează ordinea elementelor într-un array:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bob"];<br><br>people.reverse();<br>console.log(people);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Bob",&nbsp;"Sam",&nbsp;"Tom"]</code></pre>
     </div>
     <p class="paragraph">Metoda toReversed() face, de asemenea, inversarea ordinii elementelor, dar le returnează sub formă de un nou array, fără a modifica array-ul curent:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bob"];<br><br>const&nbsp;reversed&nbsp;=&nbsp;people.toReversed();<br>console.log(people);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bob"]<br>console.log(reversed);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Bob",&nbsp;"Sam",&nbsp;"Tom"]</code></pre>
     </div>
     <h2 class="subtitle">Căutarea indexului unui element</h2>
     <p class="paragraph">Metodele indexOf() și lastIndexOf() returnează indexul primei și ultimei apariții a unui element într-un array. De exemplu:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bob",&nbsp;"Tom",&nbsp;"Alice",&nbsp;"Sam"];<br><br>const&nbsp;firstIndex&nbsp;=&nbsp;people.indexOf("Tom");<br>const&nbsp;lastIndex&nbsp;=&nbsp;people.lastIndexOf("Tom");<br>const&nbsp;otherIndex&nbsp;=&nbsp;people.indexOf("Mike");<br>console.log(firstIndex);&nbsp;//&nbsp;0<br>console.log(lastIndex);&nbsp;&nbsp;//&nbsp;3<br>console.log(otherIndex);&nbsp;//&nbsp;-1</code></pre>
     </div>
     <p class="paragraph">firstIndex are valoarea 0, deoarece prima apariție a șirului "Tom" în array are loc la indexul 0, iar ultima la indexul 3.</p>
     <p class="paragraph">Dacă elementul lipsește din array, atunci în acest caz, metodele **indexOf()** și **lastIndexOf()** returnează valoarea -1.</p>
     <h2 class="subtitle">Verificarea existenței unui element</h2>
     <p class="paragraph">Metoda includes() verifică dacă există o valoare în array, transmisă ca parametru. Dacă această valoare există, metoda returnează true, în caz contrar returnează false. De exemplu:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bob",&nbsp;"Tom",&nbsp;"Alice",&nbsp;"Sam"];<br><br>console.log(people.includes("Tom"));&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;true&nbsp;-&nbsp;"Tom"&nbsp;se&nbsp;află&nbsp;în&nbsp;array<br>console.log(people.includes("Kate"));&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;false&nbsp;-&nbsp;"Kate"&nbsp;nu&nbsp;se&nbsp;află&nbsp;în&nbsp;array</code></pre>
     </div>
     <p class="paragraph">Ca al doilea parametru, metoda includes() primește un index de la care să înceapă căutarea:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bob",&nbsp;"Tom",&nbsp;"Alice",&nbsp;"Sam"];<br><br>console.log(people.includes("Bob",&nbsp;2));&nbsp;//&nbsp;true<br>console.log(people.includes("Bob",&nbsp;4))&nbsp;&nbsp;//&nbsp;false</code></pre>
     </div>
     <p class="paragraph">În acest caz, observăm că la căutarea începând cu indexul 2, în array există șirul "Bob", în timp ce începând cu indexul 4, acest șir lipsește.</p>
     <p class="paragraph">Dacă acest parametru nu este furnizat, căutarea are loc începând cu indexul 0 în mod implicit.</p>
     <p class="paragraph">La furnizarea unei valori negative, căutarea are loc de la sfârșit.</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bob",&nbsp;"Tom",&nbsp;"Alice",&nbsp;"Sam"];<br><br>console.log(people.includes("Tom",&nbsp;-2));&nbsp;//&nbsp;false&nbsp;-&nbsp;al&nbsp;2-lea&nbsp;index&nbsp;de&nbsp;la&nbsp;sfârșit<br>console.log(people.includes("Tom",&nbsp;-3));&nbsp;//&nbsp;true&nbsp;-&nbsp;al&nbsp;3-lea&nbsp;index&nbsp;de&nbsp;la&nbsp;sfârșit</code></pre>
     </div>
     <p class="paragraph">every()</p>
     <p class="paragraph">Metoda every() verifică dacă toate elementele corespund unei anumite condiții:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;numbers&nbsp;=&nbsp;[&nbsp;1,&nbsp;-12,&nbsp;8,&nbsp;-4,&nbsp;25,&nbsp;42&nbsp;];<br>const&nbsp;passed&nbsp;=&nbsp;numbers.every(n&nbsp;=&gt;&nbsp;n&nbsp;&gt;&nbsp;0);<br>console.log(passed);&nbsp;//&nbsp;false</code></pre>
     </div>
     <p class="paragraph">În metoda every(), se furnizează o funcție ca parametru, care reprezintă condiția. Această funcție primește un element ca parametru și returnează true (dacă elementul corespunde condiției) sau false (dacă nu corespunde).</p>
     <p class="paragraph">Dacă cel puțin un element nu corespunde condiției, metoda every() returnează valoarea false.</p>
     <p class="paragraph">În acest caz, condiția este definită folosind expresia lambda n =&gt; n &gt; 0, care verifică dacă elementul este mai mare decât zero.</p>
     <p class="paragraph">some()</p>
     <p class="paragraph">Metoda some() este similară cu metoda every(), dar verifică dacă cel puțin un element corespunde condiției. În acest caz, metoda some() returnează true. Dacă nu există elemente care să corespundă condiției, se returnează valoarea false.</p>
     <div class="code-inline">
      <pre><code>const&nbsp;numbers&nbsp;=&nbsp;[&nbsp;1,&nbsp;-12,&nbsp;8,&nbsp;-4,&nbsp;25,&nbsp;42&nbsp;];<br>const&nbsp;passed&nbsp;=&nbsp;numbers.some(n&nbsp;=&gt;&nbsp;n&nbsp;&gt;&nbsp;0);<br>console.log(passed);&nbsp;//&nbsp;true</code></pre>
     </div>
     <p class="paragraph">filter()</p>
     <p class="paragraph">Metoda filter(), asemănătoare cu some() și every(), primește o funcție condițională.</p>
     <div class="code-inline">
      <pre><code>filter(callbackFn)<br>filter(callbackFn,&nbsp;thisArg)</code></pre>
     </div>
     <p class="paragraph">În calitate de parametru pentru forEach, se furnizează o funcție de tip callback, care va fi apelată pentru fiecare element al array-ului în curs de traversare. Această funcție de callback poate avea până la trei parametri:</p>
     <div class="code-inline">
      <pre><code>callback(element,&nbsp;index,&nbsp;array)</code></pre>
     </div>
     <p class="paragraph">În cadrul funcției de tip callback, sunt furnizate în mod consecutiv trei parametri: elementul curent (element), indexul elementului (index) și o referință la array-ul care este iterat (array).</p>
     <p class="paragraph">Opțional, poți furniza un al doilea parametru pentru metoda forEach(), care este un obiect și poate fi accesat în interiorul funcției de callback prin intermediul cuvântului cheie this.</p>
     <p class="paragraph">Metoda filter() returnează ca rezultat un array format din elementele care îndeplinesc condiția specificată.</p>
     <div class="code-inline">
      <pre><code>const&nbsp;numbers&nbsp;=&nbsp;[&nbsp;1,&nbsp;-12,&nbsp;8,&nbsp;-4,&nbsp;25,&nbsp;42&nbsp;];<br>const&nbsp;filteredNumbers&nbsp;=&nbsp;numbers.filter(n&nbsp;=&gt;&nbsp;n&nbsp;&gt;&nbsp;0);<br>console.log(filteredNumbers);&nbsp;//&nbsp;[1,&nbsp;8,&nbsp;25,&nbsp;42]</code></pre>
     </div>
     <h2 class="subtitle">Iterarea prin elemente folosind forEach()</h2>
     <p class="paragraph">Metoda forEach() iterează prin elementele și aplică o acțiune specifică fiecăruia dintre ele.</p>
     <div class="code-inline">
      <pre><code>forEach(callbackFn)<br>forEach(callbackFn,&nbsp;thisArg)</code></pre>
     </div>
     <p class="paragraph">Ca parametru pentru forEach, se furnizează o funcție de tip callback, care va fi apelată pentru fiecare element al array-ului în curs de iterare. Această funcție callback poate avea până la trei parametri:</p>
     <div class="code-inline">
      <pre><code>callback(element,&nbsp;index,&nbsp;array)</code></pre>
     </div>
     <p class="paragraph">În funcția de tip callback, în mod consecutiv, sunt furnizate elementul curent (element), indexul elementului (index), și referința la array-ul iterat (array).</p>
     <p class="paragraph">Opțional, ca al doilea parametru în metoda forEach(), poți furniza un obiect, pe care îl poți accesa în funcția de tip callback folosind cuvântul cheie this.</p>
     <p class="paragraph">De exemplu, să folosim metoda forEach() pentru a calcula pătratele numerelor dintr-un array:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;numbers&nbsp;=&nbsp;[1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6];<br><br>numbers.forEach(n&nbsp;=&gt;<br>&nbsp;&nbsp;&nbsp;console.log("Pătraul&nbsp;numărului&nbsp;",&nbsp;n,&nbsp;"este",&nbsp;n&nbsp;*&nbsp;n)<br>);</code></pre>
     </div>
     <p class="paragraph">Metoda forEach() primește ca parametru o funcție, care are un singur parametru - elementul curent al array-ului iterat. În corpul funcției, se pot efectua diverse operații asupra acestui element.</p>
     <p class="paragraph">Iată rezultatul afișat în consolă al programului:</p>
     <div class="code-inline">
      <pre><code>Pătratul&nbsp;numărului&nbsp;1&nbsp;este&nbsp;1<br>Pătratul&nbsp;numărului&nbsp;2&nbsp;este&nbsp;4<br>Pătratul&nbsp;numărului&nbsp;3&nbsp;este&nbsp;9<br>Pătratul&nbsp;numărului&nbsp;4&nbsp;este&nbsp;16<br>Pătratul&nbsp;numărului&nbsp;5&nbsp;este&nbsp;25<br>Pătratul&nbsp;numărului&nbsp;6&nbsp;este&nbsp;36</code></pre>
     </div>
     <h2 class="subtitle">Transformarea array-ului cu map()</h2>
     <p class="paragraph">Metoda map() este similară cu metoda forEach, ea primește aceiași parametri:</p>
     <div class="code-inline">
      <pre><code>map(callbackFn)<br>map(callbackFn,&nbsp;thisArg)</code></pre>
     </div>
     <p class="paragraph">Primul parametru - de asemenea, o funcție de tip callback, căreia i se furnizează elementul curent, indexul acestuia și referința la array. Cel de-al doilea parametru - valoarea pentru cuvântul cheie this în interiorul funcției de tip callback. Cu toate acestea, metoda map() returnează un nou array cu rezultatele operațiilor asupra elementelor array-ului.</p>
     <p class="paragraph">De exemplu, să aplicăm metoda map() pentru a calcula pătratele numerelor din array:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;numbers&nbsp;=&nbsp;[&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6];<br><br>const&nbsp;squares&nbsp;=&nbsp;numbers.map(n&nbsp;=&gt;&nbsp;n&nbsp;*&nbsp;n);<br>console.log(squares);&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;[1,&nbsp;4,&nbsp;9,&nbsp;16,&nbsp;25,&nbsp;36]</code></pre>
     </div>
     <p class="paragraph">Funcția furnizată metodei map() primește elementul curent al array-ului, efectuează operațiile asupra acestuia și returnează o anumită valoare. Această valoare este apoi adăugată în noul array rezultat, numit squares.</p>
     <h2 class="subtitle">Căutare în array</h2>
     <p class="paragraph">Metoda find() returnează primul element al array-ului care îndeplinește o anumită condiție. În calitate de parametru, metoda find() primește o funcție condiție:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;numbers&nbsp;=&nbsp;[1,&nbsp;2,&nbsp;3,&nbsp;5,&nbsp;8,&nbsp;13,&nbsp;21,&nbsp;34];<br><br>//&nbsp;obținem&nbsp;primul&nbsp;element&nbsp;care&nbsp;este&nbsp;mai&nbsp;mare&nbsp;de&nbsp;10<br>let&nbsp;found&nbsp;=&nbsp;numbers.find(n&nbsp;=&gt;&nbsp;n&nbsp;&gt;&nbsp;10&nbsp;);<br>console.log(found);&nbsp;//&nbsp;13</code></pre>
     </div>
     <p class="paragraph">În acest caz, obținem primul element care este mai mare de 10. Dacă nu se găsește niciun element care să îndeplinească condiția, atunci este returnat undefined.</p>
     <p class="paragraph">Similar, metoda findLast() returnează ultimul element care îndeplinește condiția:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;numbers&nbsp;=&nbsp;[1,&nbsp;2,&nbsp;3,&nbsp;5,&nbsp;8,&nbsp;13,&nbsp;21,&nbsp;34];<br><br>//&nbsp;obținem&nbsp;ultimul&nbsp;element&nbsp;care&nbsp;este&nbsp;mai&nbsp;mic&nbsp;ca&nbsp;10<br>let&nbsp;found&nbsp;=&nbsp;numbers.find(n&nbsp;=&gt;&nbsp;n&nbsp;&lt;&nbsp;10&nbsp;);<br>console.log(found);&nbsp;//&nbsp;8</code></pre>
     </div>
     <p class="paragraph">Metoda findIndex() primește, de asemenea, o funcție condiție și returnează indexul primului element din array care îndeplinește această condiție:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;numbers&nbsp;=&nbsp;[1,&nbsp;2,&nbsp;3,&nbsp;5,&nbsp;8,&nbsp;13,&nbsp;21,&nbsp;34];<br><br>//&nbsp;obținem&nbsp;indexul&nbsp;primului&nbsp;element&nbsp;care&nbsp;este&nbsp;mai&nbsp;mare&nbsp;de&nbsp;10<br>let&nbsp;foundIndex&nbsp;=&nbsp;numbers.findIndex(n&nbsp;=&gt;&nbsp;n&nbsp;&gt;&nbsp;10&nbsp;);<br>console.log(foundIndex);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;5</code></pre>
     </div>
     <p class="paragraph">Dacă elementul nu este găsit, este returnat numărul -1.</p>
     <p class="paragraph">Similar, metoda findLastIndex() returnează indexul ultimului element care îndeplinește condiția:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;numbers&nbsp;=&nbsp;[1,&nbsp;2,&nbsp;3,&nbsp;5,&nbsp;8,&nbsp;13,&nbsp;21,&nbsp;34];<br><br>//&nbsp;obținem&nbsp;indexul&nbsp;ultimului&nbsp;element&nbsp;care&nbsp;este&nbsp;mai&nbsp;mic&nbsp;de&nbsp;10<br>let&nbsp;foundIndex&nbsp;=&nbsp;numbers.findLastIndex(n&nbsp;=&gt;&nbsp;n&nbsp;&lt;&nbsp;10&nbsp;);<br>console.log(foundIndex);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;4</code></pre>
     </div>
     <h2 class="subtitle">Metoda flat() și transformarea array-ului</h2>
     <p class="paragraph">Metoda flat() simplifică array-ul, având în vedere nivelul specificat de înțelegere a înglobării elementelor:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;["Tom",&nbsp;"Bob",&nbsp;["Alice",&nbsp;"Kate",&nbsp;["Sam",&nbsp;"Ann"]]];<br>const&nbsp;flattenPeople&nbsp;=&nbsp;people.flat();<br>console.log(flattenPeople);&nbsp;//&nbsp;["Tom",&nbsp;"Bob",&nbsp;"Alice",&nbsp;"Kate",&nbsp;["Sam",&nbsp;"Ann"]]</code></pre>
     </div>
     <p class="paragraph"></p>
     <p class="paragraph">Adică, metoda flat() efectuează o conversie a elementelor din array-urile înglobate în array-ul de pe cel mai înalt nivel. Cu toate acestea, observăm că elementele array-ului de pe cel de-al doilea nivel de înțelegere au fost mutate în array-ul de pe primul nivel de înțelegere, dar rămân în continuare înglobate într-un array. Motivul este că metoda flat() este aplicată implicit doar asupra array-urilor înglobate la primul nivel. Cu toate acestea, putem furniza metodei un nivel specific de înțelegere:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;["Tom",&nbsp;"Bob",&nbsp;["Alice",&nbsp;"Kate",&nbsp;["Sam",&nbsp;"Ann"]]];<br>const&nbsp;flattenPeople&nbsp;=&nbsp;people.flat(2);<br>console.log(flattenPeople);&nbsp;//&nbsp;["Tom",&nbsp;"Bob",&nbsp;"Alice",&nbsp;"Kate",&nbsp;"Sam",&nbsp;"Ann"]</code></pre>
     </div>
     <p class="paragraph">with()</p>
     <p class="paragraph">Uneori este necesar să modifici un element dintr-un array, dar totuși să păstrezi starea veche a array-ului. Metoda with() creează automat o copie a vechiului array, schimbă elementul în această copie și returnează un nou array cu elementul modificat:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;["Tom",&nbsp;"Bob",&nbsp;"Sam"];<br>const&nbsp;modified&nbsp;=&nbsp;people.with(0,&nbsp;"Tomas");&nbsp;&nbsp;&nbsp;//&nbsp;modificăm&nbsp;"Tom"&nbsp;în&nbsp;"Tomas"<br>console.log(people);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;["Tom",&nbsp;"Bob",&nbsp;"Sam"]&nbsp;-&nbsp;array-ul&nbsp;inițial&nbsp;nu&nbsp;a&nbsp;fost&nbsp;modificat<br>console.log(modified);&nbsp;&nbsp;//&nbsp;["Tomas",&nbsp;"Bob",&nbsp;"Sam"]&nbsp;-&nbsp;copia&nbsp;a&nbsp;fost&nbsp;modificată</code></pre>
     </div>
     <h2 class="subtitle">Metoda reduce</h2>
     <p class="paragraph">Metoda reduce permite reducerea tuturor valorilor unui array la o singură valoare, care este returnată de către metoda. Ca parametru, metoda primește o funcție cu 4 parametri:</p>
     <div class="code-inline">
      <pre><code>function&nbsp;(prev,current,&nbsp;curIndex,&nbsp;array){&nbsp;....&nbsp;}</code></pre>
     </div>
     <p class="paragraph">Parametri:</p>
     <ul class="enumeration">
      <li>prev: elementul anterior (în mod inițial, primul element)</li>
      <li>current: elementul curent (în mod inițial, al doilea element)</li>
      <li>curIndex: indexul elementului curent</li>
      <li>array: array-ul pentru care este apelată funcția</li>
     </ul>
     <p class="paragraph">Aplicați metoda reduce() pentru a găsi suma unui array de numere:</p>
     <div class="code-inline">
      <pre><code><br>const&nbsp;numbers&nbsp;=&nbsp;[1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5];<br>const&nbsp;sum&nbsp;=&nbsp;numbers.reduce((prev,current)&nbsp;=&gt;&nbsp;prev&nbsp;+=current);<br>console.log(sum);&nbsp;&nbsp;&nbsp;//&nbsp;15</code></pre>
     </div>
     <p class="paragraph">În acest caz, în metoda reduce() este transmisă funcția (prev, current) =&gt; prev += current, care adună elementul anterior cu cel curent și returnează suma lor.</p>
     <p class="paragraph">O altă formă a metodei reduce() primește doi parametri. Al doilea parametru este valoarea inițială de la care începe calculul:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;numbers&nbsp;=&nbsp;[1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5];<br>const&nbsp;sum&nbsp;=&nbsp;numbers.reduce((prev,current)&nbsp;=&gt;&nbsp;prev&nbsp;+current,&nbsp;10);<br>console.log(sum);&nbsp;&nbsp;&nbsp;//&nbsp;25</code></pre>
     </div>
     <p class="paragraph">În acest caz, valoarea inițială a lui prev va fi 10.</p>
     <p class="paragraph">Dacă metoda reduce parcurge elementele array-ului de la început (de la stânga la dreapta), atunci metoda reduceRight() face acest lucru în ordine inversă - de la dreapta la stânga:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;numbers&nbsp;=&nbsp;[1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5];<br>const&nbsp;reduced1&nbsp;=&nbsp;numbers.reduce((prev,current)&nbsp;=&gt;&nbsp;prev&nbsp;+=current.toString());<br>console.log(reduced1);&nbsp;&nbsp;&nbsp;//&nbsp;12345<br>const&nbsp;reduced2&nbsp;=&nbsp;numbers.reduceRight((prev,current)&nbsp;=&gt;&nbsp;prev&nbsp;+=current.toString());<br>console.log(reduced2);&nbsp;&nbsp;&nbsp;//&nbsp;54321</code></pre>
     </div>
     <h2 class="subtitle">Combinația de metode</h2>
     <p class="paragraph">La nevoie, putem să combinăm mai multe operații într-un lanț de metode. De exemplu, avem un array de utilizatori:</p>
     <div class="code-inline">
      <pre><code>function&nbsp;Person(name,&nbsp;age){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.age&nbsp;=&nbsp;age;<br>}<br>const&nbsp;people&nbsp;=&nbsp;[<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Person("Tom",&nbsp;38),&nbsp;new&nbsp;Person("Kate",&nbsp;31),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Person("Bob",&nbsp;42),&nbsp;new&nbsp;Person("Alice",&nbsp;34),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Person("Sam",&nbsp;25)<br>&nbsp;&nbsp;&nbsp;];</code></pre>
     </div>
     <p class="paragraph">Vom afișa din array-ul people numele tuturor utilizatorilor care au vârsta mai mare de 33 de ani:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;isAgeMoreThan33&nbsp;=&nbsp;(p)=&gt;p.age&nbsp;&gt;&nbsp;33;<br>const&nbsp;getPersonName&nbsp;=&nbsp;(p)=&gt;p.name;<br>const&nbsp;printPersonName&nbsp;=&nbsp;(p)=&gt;console.log(p);<br>//&nbsp;Obținem&nbsp;din&nbsp;obiectul&nbsp;Person&nbsp;un&nbsp;șir&nbsp;de&nbsp;caractere&nbsp;cu&nbsp;numele<br>const&nbsp;view&nbsp;=&nbsp;people<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.filter(isAgeMoreThan33)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.map(getPersonName)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.forEach(printPersonName);</code></pre>
     </div>
    </div>
   </main>
   <aside class="ad-section">
    <div class="ad-box">
     <p>Google Ad Here</p>
    </div>
    <div class="ad-box">
     <p>Promo: SQL Beginner Guide</p>
    </div>
   </aside>
  </div>
  <div class="lesson-navigation">
   <th:block th:if="${previousLesson != null}">
    <a th:href="@{'/lessons/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția anterioară</a>
   </th:block> <th:block th:if="${nextLesson != null}">
    <a th:href="@{'/lessons/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția următoare →</a>
   </th:block>
  </div>
  <div th:replace="~{fragments/footer :: footer}"></div>
  <script th:src="@{/js/script.js}" defer></script>
 </body>
</html>
