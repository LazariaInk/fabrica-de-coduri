<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">
 <head>
    <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      window.gtag = function () { dataLayer.push(arguments); };
      gtag('consent', 'default', {
        'wait_for_update': 500,
        'region': ['RO'],
        'ad_storage': 'denied',
        'analytics_storage': 'denied',
        'ad_user_data': 'denied',
        'ad_personalization': 'denied'
      });
      gtag('js', new Date());
      gtag('config', 'G-7Q2536ZKL2');
    </script>


  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title th:text="${lesson.title}">Lesson</title>
  <link rel="stylesheet" th:href="@{/css/styles.css}">
  <style>body { background: #ffffff; }</style>
 </head>
 <body th:with="activeTopic='JavaScript', activeChapter='2.Fundamentele JavaScript', activeLesson='10.Bucle'">
  <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
  <div th:replace="~{fragments/nav :: nav}"></div>
  <div class="top-nav">
   <th:block th:each="topic : ${topics}">
    <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}" th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a>
   </th:block>
  </div>
  <div class="layout">
   <div class="mobile-sidebar" id="mobileSidebar">
    <button class="close-btn" onclick="toggleSidebar()">✖</button>
    <ul class="chapter-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-title" onclick="toggleChapter(this)">
        <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
       </div>
       <ul class="lesson-list">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </div>
   <aside class="sidebar">
    <ul class="sidebar-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-toggle" onclick="toggleLessons(this)">
        <span th:text="${chapter.title}">Chapter</span>
       </div>
       <ul class="lesson-list hidden">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </aside>
   <main class="content">
    <div class="document-container">
     <h1 class="main-title">Bucle</h1>
     <p class="paragraph">Bucla permite executarea unei acțiuni de mai multe ori, în funcție de anumite condiții. În JavaScript, există următoarele tipuri de bucle:</p>
     <ul class="enumeration">
      <li>for</li>
      <li>for..in</li>
      <li>for..of</li>
      <li>while</li>
      <li>do..while</li>
     </ul>
     <h2 class="subtitle">Bucla for</h2>
     <p class="paragraph">Bucla for are următoarea definiție formală:</p>
     <div class="code-inline">
      <pre><code>for&nbsp;([inițializarea&nbsp;contorului];&nbsp;[condiția];&nbsp;[modificarea&nbsp;contorului]){<br><br>&nbsp;&nbsp;&nbsp;//&nbsp;acțiuni<br>}</code></pre>
     </div>
     <p class="paragraph">De exemplu, folosim bucla for pentru a itera prin numerele de la 0 la 4:</p>
     <div class="code-inline">
      <pre><code>for(let&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&lt;5;&nbsp;i++){<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;console.log(i);<br>}<br>console.log("Sfârșitul&nbsp;execuției");</code></pre>
     </div>
     <p class="paragraph">Prima parte a declarației buclei - let i = 0 - creează și inițializează un contor - variabila i. Înainte de executarea buclei, valoarea sa va fi 0. Practic, este echivalentă cu declararea unei variabile.</p>
     <p class="paragraph">A doua parte - condiția sub care bucla va fi executată: i &lt; 5. În acest caz, bucla va fi executată atât timp cât valoarea lui i nu atinge 5.</p>
     <p class="paragraph">A treia parte - i++ - incrementarea contorului cu unu.</p>
     <p class="paragraph">Prin urmare, la început, variabila i are valoarea 0. Această valoare satisface condiția i &lt; 5, astfel că blocul buclei va fi executat, adică linia de cod.</p>
     <div class="code-inline">
      <pre><code>console.log(i);</code></pre>
     </div>
     <p class="paragraph">După executarea blocului buclei, se efectuează a treia parte a declarației buclei - incrementarea contorului. Cu alte cuvinte, variabila i devine egală cu 1. Această valoare, de asemenea, satisface condiția, astfel că blocul buclei va fi din nou executat. Astfel, blocul buclei va fi executat de 5 ori, până când valoarea lui i devine 5.</p>
     <p class="paragraph">Această valoare NU satisface condiția, așa că bucla se încheie. Controlul programului va trece la instrucțiunile care urmează după blocul buclei. Iată output-ul la consolă al programului:</p>
     <p class="paragraph">0 1 2 3 4 Sfârșitul execuției</p>
     <p class="paragraph">Fiecare repetare individuală a buclei este numită o iterație. În acest caz, vor avea loc 5 iterații.</p>
     <p class="paragraph">Nu este obligatoriu să incrementăm contorul cu 1; putem efectua și alte acțiuni cu el, de exemplu, să îl decrementăm cu 1:</p>
     <div class="code-inline">
      <pre><code>for(let&nbsp;i&nbsp;=&nbsp;10;&nbsp;i&nbsp;&gt;&nbsp;5;&nbsp;i--){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;console.log(i);<br>}</code></pre>
     </div>
     <p class="paragraph">În acest caz, sunt afișate pe consolă numerele de la 10 la 6.</p>
     <p class="paragraph">Sau putem crește contorul cu 2:</p>
     <div class="code-inline">
      <pre><code><br>for&nbsp;(let&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i&nbsp;+=&nbsp;2){<br>&nbsp;&nbsp;&nbsp;console.log(i);<br>}</code></pre>
     </div>
     <p class="paragraph">Aici sunt afișate pe consolă toate numerele pare de la 0 la 8.</p>
     <p class="paragraph">În același timp, este posibil să omitem diferite părți ale declarației buclei:</p>
     <div class="code-inline">
      <pre><code>let&nbsp;i&nbsp;=&nbsp;0;<br>for&nbsp;(;&nbsp;i&nbsp;&lt;&nbsp;60;){<br>&nbsp;&nbsp;&nbsp;console.log(i);<br>&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;i&nbsp;+&nbsp;10;<br>}</code></pre>
     </div>
     <p class="paragraph">În acest caz, variabila i este definită în afara buclei. În declarația buclei, există doar condiția, celelalte două părți lipsesc. Modificarea variabilei are loc în blocul buclei: aceasta crește cu 10. În final, vor fi afișate pe consolă numerele 0, 10, 20, 30, 40, 50.</p>
     <p class="paragraph">Contorul este convenabil de utilizat ca indice pentru elementele unui array și astfel să parcurgem array-ul:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bob"];<br>for&nbsp;(let&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;3;&nbsp;i++){<br>&nbsp;&nbsp;&nbsp;console.log(people[i]);<br>}<br><br></code></pre>
     </div>
     <p class="paragraph">Afișarea în consolă a browser-ului va fi:</p>
     <p class="paragraph">Tom Sam Bob</p>
     <p class="paragraph">Pentru a utiliza mai mulți contori într-o buclă, putem face așa:</p>
     <div class="code-inline">
      <pre><code>for&nbsp;(let&nbsp;i&nbsp;=&nbsp;1,&nbsp;j&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;&nbsp;5&nbsp;&amp;&amp;&nbsp;j&nbsp;&lt;&nbsp;4;&nbsp;i++,&nbsp;j++){<br>&nbsp;&nbsp;&nbsp;console.log(i&nbsp;+&nbsp;j);<br>}<br>//&nbsp;1&nbsp;iterație:&nbsp;i=1,&nbsp;j=1;&nbsp;i&nbsp;+&nbsp;j&nbsp;=&nbsp;2<br>//&nbsp;2&nbsp;iterație:&nbsp;i=2,&nbsp;j=2;&nbsp;i&nbsp;+&nbsp;j&nbsp;=&nbsp;4<br>//&nbsp;3&nbsp;iterație:&nbsp;i=3,&nbsp;j=3;&nbsp;i&nbsp;+&nbsp;j&nbsp;=&nbsp;6</code></pre>
     </div>
     <p class="paragraph">Aici sunt folosiți doi contori și două condiții. Să analizăm pas cu pas ce se întâmplă aici:</p>
     <ul class="enumeration">
      <li>Prima iterație. Valorile inițiale ale variabilelor i și j:</li>
     </ul>
     <div class="code-inline">
      <pre><code>i=1,&nbsp;j=1;</code></pre>
     </div>
     <p class="paragraph">Pentru fiecare variabilă, sunt stabilite condițiile ei. La început, valorile inițiale ale variabilelor corespund acestor condiții:</p>
     <div class="code-inline">
      <pre><code>i&nbsp;&lt;&nbsp;5,&nbsp;j&nbsp;&lt;&nbsp;4;</code></pre>
     </div>
     <p class="paragraph">În blocul buclei, este afișată suma acestor variabile. Ulterior, valorile ambelor variabile sunt incrementate cu unu. Ele devin:</p>
     <div class="code-inline">
      <pre><code>i=2,&nbsp;j=2;</code></pre>
     </div>
     <p class="paragraph">Aceste valori corespund, de asemenea, condițiilor, așa că se execută a doua iterație.</p>
     <ul class="enumeration">
      <li>A doua iterație. Valorile variabilelor i și j:</li>
     </ul>
     <div class="code-inline">
      <pre><code>i=2,&nbsp;j=2;</code></pre>
     </div>
     <p class="paragraph">După executarea blocului buclei, valorile ambelor variabile sunt incrementate cu unu. Ele devin:</p>
     <div class="code-inline">
      <pre><code>i=3,&nbsp;j=3;</code></pre>
     </div>
     <p class="paragraph">Aceste valori corespund, de asemenea, condițiilor, așa că se execută a treia iterație.</p>
     <ul class="enumeration">
      <li>A treia iterație.*Valorile variabilelor i și j:</li>
     </ul>
     <div class="code-inline">
      <pre><code>i=3,&nbsp;j=3;</code></pre>
     </div>
     <p class="paragraph">După executarea blocului buclei, valorile ambelor variabile sunt incrementate cu unu. Ele devin:</p>
     <div class="code-inline">
      <pre><code>i=4,&nbsp;j=4;</code></pre>
     </div>
     <p class="paragraph">Valoarea variabilei i se conformează condiției i &lt; 5, dar valoarea variabilei j (4) NU se conformează condiției j &lt; 4. Prin urmare, bucla se încheie. Execuția ei s-a încheiat.</p>
     <h2 class="subtitle">Execuția acțiunilor în declarația buclei</h2>
     <p class="paragraph">Este demn de menționat că a treia parte a buclei, unde de obicei are loc modificarea contorului, de fapt, reprezintă o acțiune arbitrară care se execută după încheierea buclei. Astfel, putem scrie astfel:</p>
     <div class="code-inline">
      <pre><code>for(let&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;5;&nbsp;console.log(i++));<br>console.log("Sfârșitul&nbsp;execuției");</code></pre>
     </div>
     <p class="paragraph">Aici nu este definit un bloc de buclă, iar acțiunile buclei sunt definite în a treia parte a antetului buclei - console.log(i++).</p>
     <p class="paragraph">Similar, în prima parte a declarației buclei - inițializarea, putem efectua anumite acțiuni, nu doar să declarăm contorul:</p>
     <div class="code-inline">
      <pre><code>let&nbsp;i&nbsp;=&nbsp;0;<br>for(console.log("Inițializare");&nbsp;i&nbsp;&lt;&nbsp;5;&nbsp;i++){<br>&nbsp;&nbsp;&nbsp;console.log(i);<br>}</code></pre>
     </div>
     <p class="paragraph">Aici, definirea contorului este scoasă în afara buclei, iar în partea de inițializare a buclei se afișează un șir pe consolă. Output-ul în consolă va fi:</p>
     <p class="paragraph">Inițializare 0 1 2 3 4 Buclele înglobate.</p>
     <p class="paragraph">Unele bucle pot să conțină altele în interiorul lor:</p>
     <div class="code-inline">
      <pre><code>for(let&nbsp;i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;=&nbsp;5;&nbsp;i++){<br>&nbsp;&nbsp;&nbsp;&nbsp;for(let&nbsp;j&nbsp;=&nbsp;1;&nbsp;j&nbsp;&lt;=&nbsp;5;&nbsp;j++){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(i&nbsp;*&nbsp;j);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br></code></pre>
     </div>
     <p class="paragraph">Aici, un ciclu este inclus în altul. În ciclul exterior, variabila i este definită. Inițial, aceasta este egală cu 1 și această valoare corespunde condiției ciclului (i &lt;= 5), astfel că blocul ciclului va fi executat, iar acesta conține ciclul interior.</p>
     <p class="paragraph">În ciclul interior, este definită variabila contor j, care inițial este egală cu 1, și apoi ciclul interior execută 5 iterații până când variabila j devine 5.</p>
     <p class="paragraph">După ce blocul ciclului exterior se încheie, variabila i este incrementată cu 1 și devine 2, ceea ce din nou corespunde condiției. Și din nou, blocul ciclului exterior este executat. În acest bloc, din nou, sunt efectuate cinci iterații ale ciclului interior. Și așa mai departe. În final, ciclul interior va fi executat de 25 de ori.</p>
     <p class="paragraph">Prin utilizarea buclelor înglobate și a mai multor contoare, se poate itera matricele multidimensionale:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;[["Tom",&nbsp;39],&nbsp;["Sam",&nbsp;28],["Bob",&nbsp;42]];<br>for(let&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;3;&nbsp;i++){&nbsp;&nbsp;&nbsp;//&nbsp;iterăm&nbsp;prin&nbsp;matricea&nbsp;bidimensională<br>&nbsp;&nbsp;&nbsp;for(let&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;2;&nbsp;j++){&nbsp;//&nbsp;iterăm&nbsp;prin&nbsp;submatrice<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(people[i][j]);<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;console.log("=================");&nbsp;&nbsp;&nbsp;//&nbsp;pentru&nbsp;separarea&nbsp;elementelor<br>}</code></pre>
     </div>
     <p class="paragraph">Aici, matricea people reprezintă o matrice bidimensională de 3 elemente, unde fiecare element reprezintă, la rândul său, o submatrice de 2 elemente - aproximativ numele și vârsta utilizatorului.</p>
     <p class="paragraph">n ciclul exterior, definim contorul i pentru a parcurge toate submatricele din matricea bidimensională people, iar în ciclul interior definim contorul j pentru a parcurge toate elementele fiecărei submatrice. Afișarea în consolă:</p>
     <p class="paragraph">Tom 39 ================= Sam 28 ================= Bob 42 =================</p>
     <h2 class="subtitle">Buclele while</h2>
     <p class="paragraph">Ciclul while se execută până când o anumită condiție este adevărată. Definiția formală este:</p>
     <div class="code-inline">
      <pre><code>while&nbsp;(condiție)&nbsp;{<br>&nbsp;&nbsp;&nbsp;//&nbsp;acțiuni<br>}</code></pre>
     </div>
     <p class="paragraph">Să afișăm, din nou, numerele de la 1 la 5:</p>
     <div class="code-inline">
      <pre><code>let&nbsp;i&nbsp;=&nbsp;1;<br>while&nbsp;(i&nbsp;&lt;=&nbsp;5)&nbsp;{<br>&nbsp;&nbsp;&nbsp;console.log(i);<br>&nbsp;&nbsp;&nbsp;i++;<br>}</code></pre>
     </div>
     <p class="paragraph">Ciclul while va continua să se execute până când valoarea lui i devine 6.</p>
     <h2 class="subtitle">do..while</h2>
     <p class="paragraph">În ciclul do, codul ciclului este executat în primul rând, iar apoi se verifică condiția în instrucția while. În timp ce această condiție este adevărată, ciclul se repetă. De exemplu:</p>
     <div class="code-inline">
      <pre><code>let&nbsp;i&nbsp;=&nbsp;1;<br>do&nbsp;{<br>&nbsp;&nbsp;&nbsp;console.log(i);<br>&nbsp;&nbsp;&nbsp;i++;<br>}&nbsp;while&nbsp;(i&nbsp;&lt;=&nbsp;5)</code></pre>
     </div>
     <p class="paragraph">Aici, blocul ciclului va funcționa de 5 ori, până când i devine 5. Cu toate acestea, ciclul do garantează executarea acțiunilor cel puțin o dată, chiar dacă condiția din instrucțiunea while nu este adevărată.</p>
     <h2 class="subtitle">Operatorii continue și break</h2>
     <p class="paragraph">Uneori este necesar să ieșim dintr-un ciclu înainte de a-l finaliza. În acest caz, putem folosi operatorul break:</p>
     <div class="code-inline">
      <pre><code>for&nbsp;(let&nbsp;i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;=&nbsp;6;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;===&nbsp;4)&nbsp;break;<br>&nbsp;&nbsp;&nbsp;console.log(i);<br>}<br>console.log("Sfârșitul&nbsp;execuției");</code></pre>
     </div>
     <p class="paragraph">Acest ciclu crește variabila i de la 1 la 6 inclusiv. Prin urmare, conform condiției ciclului, blocul ciclului ar trebui să fie executat de 6 ori, adică să efectueze 6 iterații. Cu toate acestea, deoarece în blocul ciclului se verifică if(i===4) break;, când valoarea variabilei i ajunge la 4, această condiție întrerupe execuția ciclului cu ajutorul operatorului break. Și ciclul se încheie.</p>
     <div class="code-inline">
      <pre><code>for&nbsp;(let&nbsp;i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;=&nbsp;6;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;===&nbsp;4)&nbsp;continue;<br>&nbsp;&nbsp;&nbsp;console.log(i);<br>}<br>console.log("Sfârșitul&nbsp;execuției");</code></pre>
     </div>
     <p class="paragraph">Output-ul va fi: 1 2 3 Sfârșitul execuției</p>
     <p class="paragraph">Dacă dorim să trecem pur și simplu la următoarea iterație, fără a ieși din ciclu, putem utiliza operatorul continue. De exemplu, să modificăm exemplul anterior, înlocuind break cu continue:</p>
     <div class="code-inline">
      <pre><code>for&nbsp;(let&nbsp;i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;=&nbsp;6;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;===&nbsp;4)&nbsp;continue;<br>&nbsp;&nbsp;&nbsp;console.log(i);<br>}<br>console.log("Sfârșitul&nbsp;execuției");</code></pre>
     </div>
     <p class="paragraph">În acest caz, când valoarea variabilei i devine 4, expresia i===4 returnează true, astfel încât construcția if(i===4) continue; va întrerupe iterația curentă. Ulterior, instrucțiunile ciclului care urmează nu vor fi executate, iar controlul va trece la următoarea iterație.</p>
     <p class="paragraph">1 2 3 5 6 Sfârșitul execuției</p>
     <h2 class="subtitle">for..in</h2>
     <p class="paragraph">Ciclul for..in este folosit în primul rând pentru a parcurge obiecte. Definiția sa formală este:</p>
     <div class="code-inline">
      <pre><code>for&nbsp;(proprietate&nbsp;in&nbsp;obiect)&nbsp;{<br>&nbsp;&nbsp;&nbsp;//&nbsp;acțiuni<br>}</code></pre>
     </div>
     <p class="paragraph">Acest ciclu parcurge toate proprietățile obiectului. De exemplu:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;persoana&nbsp;=&nbsp;{&nbsp;nume:&nbsp;"Tom",&nbsp;vârstă:&nbsp;37&nbsp;};<br>for&nbsp;(proprietate&nbsp;in&nbsp;persoana)&nbsp;{<br>&nbsp;&nbsp;&nbsp;console.log(proprietate);<br>}</code></pre>
     </div>
     <p class="paragraph">Aici, se parcurge obiectul persoana, care are două proprietăți - nume și vârstă. Prin urmare, în consolă vom vedea:</p>
     <p class="paragraph">nume vârstă</p>
     <p class="paragraph">Obținând proprietățile și folosind o sintaxă specială obiect[proprietate], putem obține valoarea fiecărei proprietăți:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;persoana&nbsp;=&nbsp;{&nbsp;nume:&nbsp;"Tom",&nbsp;vârstă:&nbsp;37&nbsp;};<br>for&nbsp;(proprietate&nbsp;in&nbsp;persoana)&nbsp;{<br>&nbsp;&nbsp;&nbsp;console.log(proprietate,&nbsp;persoana[proprietate]);<br>}</code></pre>
     </div>
     <p class="paragraph">Output-ul în consolă va fi:</p>
     <p class="paragraph">nume Tom vârstă 37</p>
     <h2 class="subtitle">for...of</h2>
     <p class="paragraph">Ciclul for...of este destinat pentru parcurgerea seturilor de date. De exemplu, un șir reprezintă, de fapt, un set de caractere. Prin intermediul acestui ciclu, putem parcurge șirul astfel:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;text&nbsp;=&nbsp;"Salut";<br>for&nbsp;(char&nbsp;of&nbsp;text)&nbsp;{<br>&nbsp;&nbsp;&nbsp;console.log(char);<br>}</code></pre>
     </div>
     <p class="paragraph">În consecință, ciclul parcurge toate caracterele șirului text, iar fiecare caracter curent este plasat în variabila char, a cărei valoare este apoi afișată pe consolă.</p>
     <p class="paragraph">S a l u t</p>
     <p class="paragraph">Un alt exemplu poate fi parcurgerea unui array:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;people&nbsp;=&nbsp;["Tom",&nbsp;"Sam",&nbsp;"Bob"];<br>for&nbsp;(const&nbsp;person&nbsp;of&nbsp;people)&nbsp;{<br>&nbsp;&nbsp;&nbsp;console.log(person);<br>}</code></pre>
     </div>
     <p class="paragraph">În acest caz, ciclul parcurge elementele array-ului people. Fiecare element este plasat consecutiv în constanta person. Ulterior, putem afișa valoarea acesteia pe consolă:</p>
     <p class="paragraph">Tom Sam Bob</p>
    </div>
   </main>
   <aside class="ad-section">
    <div class="ad-box">
     <p>Google Ad Here</p>
    </div>
    <div class="ad-box">
     <p>Promo: SQL Beginner Guide</p>
    </div>
   </aside>
  </div>
  <div class="lesson-navigation">
   <th:block th:if="${previousLesson != null}">
    <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția anterioară</a>
   </th:block> <th:block th:if="${nextLesson != null}">
    <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția următoare →</a>
   </th:block>
  </div>
  <div th:replace="~{fragments/footer :: footer}"></div>
  <script th:src="@{/js/script.js}" defer></script>
 </body>
</html>
