<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">
 <head>
    <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      window.gtag = function () { dataLayer.push(arguments); };
      gtag('consent', 'default', {
        'wait_for_update': 500,
        'region': ['RO'],
        'ad_storage': 'denied',
        'analytics_storage': 'denied',
        'ad_user_data': 'denied',
        'ad_personalization': 'denied'
      });
      gtag('js', new Date());
      gtag('config', 'G-7Q2536ZKL2');
    </script>


  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title th:text="${lesson.title}">Lesson</title>
  <link rel="stylesheet" th:href="@{/css/styles.css}">
  <style>body { background: #ffffff; }</style>
 </head>
 <body th:with="activeTopic='Java', activeChapter='3.Clase. Programare orientata pe obiecte in Java', activeLesson='10.Interfete'">
  <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
  <div th:replace="~{fragments/nav :: nav}"></div>
  <div class="top-nav">
   <th:block th:each="topic : ${topics}">
    <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}" th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a>
   </th:block>
  </div>
  <div class="layout">
   <div class="mobile-sidebar" id="mobileSidebar">
    <button class="close-btn" onclick="toggleSidebar()">✖</button>
    <ul class="chapter-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-title" onclick="toggleChapter(this)">
        <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
       </div>
       <ul class="lesson-list">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lessons/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </div>
   <aside class="sidebar">
    <ul class="sidebar-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-toggle" onclick="toggleLessons(this)">
        <span th:text="${chapter.title}">Chapter</span>
       </div>
       <ul class="lesson-list hidden">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lessons/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </aside>
   <main class="content">
    <div class="document-container">
     <h1 class="main-title">Interfețe</h1>
     <p class="paragraph">Mecanismul de moștenire este foarte convenabil, dar are limitările sale. În special, putem moșteni doar de la o singură clasă, spre deosebire de limbajul C++, de exemplu, unde există moștenire multiplă.</p>
     <p class="paragraph">În limbajul Java, această problemă este parțial rezolvată prin interfețe. Interfețele definesc o funcționalitate fără o implementare concretă, care este apoi implementată de clasele ce aplică aceste interfețe. O clasă poate aplica mai multe interfețe.</p>
     <p class="paragraph">Pentru a defini o interfață, se folosește cuvântul cheie interface. De exemplu:</p>
     <div class="code-inline">
      <pre><code>interface&nbsp;Printable&nbsp;{<br>&nbsp;&nbsp;&nbsp;void&nbsp;print();<br>}</code></pre>
     </div>
     <p class="paragraph">Această interfață se numește Printable. Interfața poate defini constante și metode, care pot avea sau nu implementare. Metodele fără implementare sunt similare cu metodele abstracte din clasele abstracte. În acest caz, este declarată o metodă fără implementare.</p>
     <p class="paragraph">Toate metodele unei interfețe nu au modificatori de acces, dar, de fapt, implicit accesul este public, deoarece scopul interfeței este să definească funcționalitatea pentru a fi implementată de o clasă. Prin urmare, întreaga funcționalitate trebuie să fie deschisă pentru implementare.</p>
     <p class="paragraph">Pentru ca o clasă să aplice o interfață, trebuie folosit cuvântul cheie implements:</p>
     <div class="code-inline">
      <pre><code>public&nbsp;class&nbsp;Program&nbsp;{<br>&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Book&nbsp;b1&nbsp;=&nbsp;new&nbsp;Book("Java.&nbsp;Complete&nbsp;Reference",&nbsp;"H.&nbsp;Shildt");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b1.print();<br>&nbsp;&nbsp;&nbsp;}<br>}<br><br>interface&nbsp;Printable&nbsp;{<br>&nbsp;&nbsp;&nbsp;void&nbsp;print();<br>}<br><br>class&nbsp;Book&nbsp;implements&nbsp;Printable&nbsp;{<br>&nbsp;&nbsp;&nbsp;String&nbsp;name;<br>&nbsp;&nbsp;&nbsp;String&nbsp;author;<br><br>&nbsp;&nbsp;&nbsp;Book(String&nbsp;name,&nbsp;String&nbsp;author)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.author&nbsp;=&nbsp;author;<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;print()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.printf("%s&nbsp;(%s)&nbsp;\n",&nbsp;name,&nbsp;author);<br>&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">În acest exemplu, clasa Book implementează interfața Printable. Dacă o clasă aplică o interfață, aceasta trebuie să implementeze toate metodele interfeței, ca în exemplul de mai sus unde metoda print este implementată. Dacă o clasă nu implementează toate metodele interfeței, atunci acea clasă trebuie definită ca fiind abstractă, iar clasele derivate neabstracte trebuie să implementeze aceste metode.</p>
     <p class="paragraph">În același timp, nu putem crea direct obiecte de interfețe, astfel codul următor nu va funcționa:</p>
     <div class="code-inline">
      <pre><code>Printable&nbsp;pr&nbsp;=&nbsp;new&nbsp;Printable();<br>pr.print();</code></pre>
     </div>
     <p class="paragraph">Unul dintre avantajele utilizării interfețelor este că ele adaugă flexibilitate aplicației. De exemplu, pe lângă clasa Book, vom defini o altă clasă care implementează interfața Printable:</p>
     <div class="code-inline">
      <pre><code>class&nbsp;Journal&nbsp;implements&nbsp;Printable&nbsp;{<br>&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;name;<br><br>&nbsp;&nbsp;&nbsp;String&nbsp;getName()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;name;<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;Journal(String&nbsp;name)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;print()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(name);<br>&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">Clasa Book și clasa Journal sunt legate prin faptul că implementează interfața Printable. Prin urmare, în program putem crea dinamic obiecte Printable ca instanțe ale ambelor clase:</p>
     <div class="code-inline">
      <pre><code>public&nbsp;class&nbsp;Program&nbsp;{<br>&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Printable&nbsp;printable&nbsp;=&nbsp;new&nbsp;Book("Java.&nbsp;Complete&nbsp;Reference",&nbsp;"H.&nbsp;Shildt");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printable.print();&nbsp;&nbsp;//&nbsp;Java.&nbsp;Complete&nbsp;Reference&nbsp;(H.&nbsp;Shildt)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printable&nbsp;=&nbsp;new&nbsp;Journal("Foreign&nbsp;Policy");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printable.print();&nbsp;&nbsp;//&nbsp;Foreign&nbsp;Policy<br>&nbsp;&nbsp;&nbsp;}<br>}<br><br>interface&nbsp;Printable&nbsp;{<br>&nbsp;&nbsp;&nbsp;void&nbsp;print();<br>}<br><br>class&nbsp;Book&nbsp;implements&nbsp;Printable&nbsp;{<br>&nbsp;&nbsp;&nbsp;String&nbsp;name;<br>&nbsp;&nbsp;&nbsp;String&nbsp;author;<br><br>&nbsp;&nbsp;&nbsp;Book(String&nbsp;name,&nbsp;String&nbsp;author)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.author&nbsp;=&nbsp;author;<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;print()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.printf("%s&nbsp;(%s)&nbsp;\n",&nbsp;name,&nbsp;author);<br>&nbsp;&nbsp;&nbsp;}<br>}<br><br>class&nbsp;Journal&nbsp;implements&nbsp;Printable&nbsp;{<br>&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;name;<br><br>&nbsp;&nbsp;&nbsp;String&nbsp;getName()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;name;<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;Journal(String&nbsp;name)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;print()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(name);<br>&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <h2 class="subtitle">Interfețe în conversia tipurilor</h2>
     <p class="paragraph">Tot ceea ce s-a spus despre conversia tipurilor este valabil și pentru interfețe. De exemplu, deoarece clasa Journal implementează interfața Printable, variabila de tip Printable poate stoca o referință la un obiect de tip Journal:</p>
     <div class="code-inline">
      <pre><code>Printable&nbsp;p&nbsp;=&nbsp;new&nbsp;Journal("Foreign&nbsp;Affairs");<br>p.print();&nbsp;&nbsp;<br>//&nbsp;Interfața&nbsp;nu&nbsp;are&nbsp;metoda&nbsp;getName,&nbsp;este&nbsp;necesară&nbsp;o&nbsp;conversie&nbsp;explicită<br>String&nbsp;name&nbsp;=&nbsp;((Journal)p).getName();<br>System.out.println(name);</code></pre>
     </div>
     <p class="paragraph">Dacă dorim să accesăm metodele clasei Journal, care nu sunt definite în interfața Printable, trebuie să facem o conversie explicită de tip: ((Journal)p).getName();.</p>
     <h2 class="subtitle">Metode implicite</h2>
     <p class="paragraph">Până la JDK 8, atunci când implementam o interfață, trebuia să implementăm obligatoriu toate metodele ei în clasă. Interfața putea conține doar definiții ale metodelor fără o implementare concretă. În JDK 8 a fost introdusă funcționalitatea metodelor implicite.</p>
     <p class="paragraph">Acum, interfețele pot avea metode cu implementare implicită, care sunt utilizate dacă o clasă ce implementează acea interfață nu implementează metoda respectivă. De exemplu, să creăm o metodă implicită în interfața Printable:</p>
     <div class="code-inline">
      <pre><code>interface&nbsp;Printable&nbsp;{<br>&nbsp;&nbsp;&nbsp;default&nbsp;void&nbsp;print(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Undefined&nbsp;printable");<br>&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">Metoda implicită este o metodă normală, fără modificatori, marcată cu cuvântul cheie default. În clasa Journal, nu este obligatoriu să implementăm această metodă, deși o putem suprascrie:</p>
     <div class="code-inline">
      <pre><code>class&nbsp;Journal&nbsp;implements&nbsp;Printable&nbsp;{<br>&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;name;<br><br>&nbsp;&nbsp;&nbsp;String&nbsp;getName(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;name;<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;Journal(String&nbsp;name){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;<br>&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <h2 class="subtitle">Metode statice</h2>
     <p class="paragraph">Începând cu JDK 8, interfețele pot conține metode statice, similare cu metodele unei clase:</p>
     <div class="code-inline">
      <pre><code>interface&nbsp;Printable&nbsp;{<br>&nbsp;&nbsp;&nbsp;void&nbsp;print();<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;static&nbsp;void&nbsp;read(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Read&nbsp;printable");<br>&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">Pentru a apela o metodă statică a unei interfețe, la fel ca în cazul claselor, se folosește numele interfeței și numele metodei:</p>
     <div class="code-inline">
      <pre><code>public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br>&nbsp;&nbsp;&nbsp;Printable.read();<br>}</code></pre>
     </div>
     <h2 class="subtitle">Metode private</h2>
     <p class="paragraph">Implicit, toate metodele dintr-o interfață au modificatorul public. Însă, începând cu Java 9, putem defini în interfețe metode cu modificatorul private. Acestea pot fi statice sau non-statice, dar nu pot avea o implementare implicită.</p>
     <p class="paragraph">Astfel de metode pot fi utilizate doar în interiorul interfeței în care sunt definite. De exemplu, dacă avem nevoie să efectuăm anumite acțiuni repetitive într-o interfață, le putem extrage în metode private:</p>
     <div class="code-inline">
      <pre><code>public&nbsp;class&nbsp;Program&nbsp;{<br>&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculatable&nbsp;c&nbsp;=&nbsp;new&nbsp;Calculation();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(c.sum(1,&nbsp;2));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(c.sum(1,&nbsp;2,&nbsp;4));<br>&nbsp;&nbsp;&nbsp;}<br>}<br><br>class&nbsp;Calculation&nbsp;implements&nbsp;Calculatable&nbsp;{}<br><br>interface&nbsp;Calculatable&nbsp;{<br>&nbsp;&nbsp;&nbsp;default&nbsp;int&nbsp;sum(int&nbsp;a,&nbsp;int&nbsp;b)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;sumAll(a,&nbsp;b);<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;default&nbsp;int&nbsp;sum(int&nbsp;a,&nbsp;int&nbsp;b,&nbsp;int&nbsp;c)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;sumAll(a,&nbsp;b,&nbsp;c);<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;sumAll(int...&nbsp;values)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;n&nbsp;:&nbsp;values){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;+=&nbsp;n;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;<br>&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <h2 class="subtitle">Constante în interfețe</h2>
     <p class="paragraph">Pe lângă metode, interfețele pot defini și constante statice:</p>
     <div class="code-inline">
      <pre><code>interface&nbsp;Stateable&nbsp;{<br>&nbsp;&nbsp;&nbsp;int&nbsp;OPEN&nbsp;=&nbsp;1;<br>&nbsp;&nbsp;&nbsp;int&nbsp;CLOSED&nbsp;=&nbsp;0;<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;void&nbsp;printState(int&nbsp;n);<br>}</code></pre>
     </div>
     <p class="paragraph">Deși aceste constante nu au modificatori expliciți, ele au implicit modificatorii public static final, deci valoarea lor este accesibilă din orice parte a programului.</p>
     <p class="paragraph">Utilizarea constantelor:</p>
     <div class="code-inline">
      <pre><code>public&nbsp;class&nbsp;Program&nbsp;{<br>&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WaterPipe&nbsp;pipe&nbsp;=&nbsp;new&nbsp;WaterPipe();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pipe.printState(1);<br>&nbsp;&nbsp;&nbsp;}<br>}<br><br>class&nbsp;WaterPipe&nbsp;implements&nbsp;Stateable&nbsp;{<br>&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;printState(int&nbsp;n)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(n&nbsp;==&nbsp;OPEN)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Water&nbsp;is&nbsp;opened");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if(n&nbsp;==&nbsp;CLOSED)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Water&nbsp;is&nbsp;closed");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("State&nbsp;is&nbsp;invalid");<br>&nbsp;&nbsp;&nbsp;}<br>}<br><br>interface&nbsp;Stateable&nbsp;{<br>&nbsp;&nbsp;&nbsp;int&nbsp;OPEN&nbsp;=&nbsp;1;<br>&nbsp;&nbsp;&nbsp;int&nbsp;CLOSED&nbsp;=&nbsp;0;<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;void&nbsp;printState(int&nbsp;n);<br>}</code></pre>
     </div>
     <h2 class="subtitle">Implementarea multiplă a interfețelor</h2>
     <p class="paragraph">Dacă dorim să aplicăm mai multe interfețe într-o clasă, toate sunt enumerate prin virgulă după cuvântul implements:</p>
     <div class="code-inline">
      <pre><code>interface&nbsp;Printable&nbsp;{<br>&nbsp;&nbsp;&nbsp;//&nbsp;metodele&nbsp;interfeței<br>}<br><br>interface&nbsp;Searchable&nbsp;{<br>&nbsp;&nbsp;&nbsp;//&nbsp;metodele&nbsp;interfeței<br>}<br><br>class&nbsp;Book&nbsp;implements&nbsp;Printable,&nbsp;Searchable&nbsp;{<br>&nbsp;&nbsp;&nbsp;//&nbsp;implementarea&nbsp;clasei<br>}</code></pre>
     </div>
     <h2 class="subtitle">Moștenirea interfețelor</h2>
     <p class="paragraph">La fel ca și clasele, interfețele pot moșteni alte interfețe:</p>
     <div class="code-inline">
      <pre><code>interface&nbsp;BookPrintable&nbsp;extends&nbsp;Printable&nbsp;{<br>&nbsp;&nbsp;&nbsp;void&nbsp;paint();<br>}</code></pre>
     </div>
     <p class="paragraph">Când aplicăm această interfață, clasa Book va trebui să implementeze atât metodele interfeței BookPrintable, cât și metodele interfeței de bază Printable.</p>
     <h2 class="subtitle">Interfețe imbricate</h2>
     <p class="paragraph">Ca și clasele, interfețele pot fi imbricate, adică pot fi definite în clase sau alte interfețe. De exemplu:</p>
     <div class="code-inline">
      <pre><code>class&nbsp;Printer&nbsp;{<br>&nbsp;&nbsp;&nbsp;interface&nbsp;Printable&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;print();<br>&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">Atunci când aplicăm o astfel de interfață, trebuie să specificăm numele complet împreună cu numele clasei:</p>
     <div class="code-inline">
      <pre><code>public&nbsp;class&nbsp;Journal&nbsp;implements&nbsp;Printer.Printable&nbsp;{<br>&nbsp;&nbsp;&nbsp;String&nbsp;name;<br><br>&nbsp;&nbsp;&nbsp;Journal(String&nbsp;name)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;print()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(name);<br>&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">Utilizarea interfeței va fi similară cu cazurile anterioare:</p>
     <div class="code-inline">
      <pre><code>Printer.Printable&nbsp;p&nbsp;=&nbsp;new&nbsp;Journal("Foreign&nbsp;Affairs");<br>p.print();</code></pre>
     </div>
     <h2 class="subtitle">Interfețele ca parametri și rezultate ale metodelor</h2>
     <p class="paragraph">La fel ca și în cazul claselor, interfețele pot fi utilizate ca tip de parametru al metodei sau ca tip returnat:</p>
     <div class="code-inline">
      <pre><code>public&nbsp;class&nbsp;Program&nbsp;{<br>&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Printable&nbsp;printable&nbsp;=&nbsp;createPrintable("Foreign&nbsp;Affairs",&nbsp;false);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printable.print();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read(new&nbsp;Book("Java&nbsp;for&nbsp;Impatients",&nbsp;"Cay&nbsp;Horstmann"));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read(new&nbsp;Journal("Java&nbsp;Daily&nbsp;News"));<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;static&nbsp;void&nbsp;read(Printable&nbsp;p)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.print();<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;static&nbsp;Printable&nbsp;createPrintable(String&nbsp;name,&nbsp;boolean&nbsp;option)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(option)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;Book(name,&nbsp;"Undefined");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;Journal(name);<br>&nbsp;&nbsp;&nbsp;}<br>}<br><br>interface&nbsp;Printable&nbsp;{<br>&nbsp;&nbsp;&nbsp;void&nbsp;print();<br>}<br><br>class&nbsp;Book&nbsp;implements&nbsp;Printable&nbsp;{<br>&nbsp;&nbsp;&nbsp;String&nbsp;name;<br>&nbsp;&nbsp;&nbsp;String&nbsp;author;<br><br>&nbsp;&nbsp;&nbsp;Book(String&nbsp;name,&nbsp;String&nbsp;author)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.author&nbsp;=&nbsp;author;<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;print()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.printf("%s&nbsp;(%s)&nbsp;\n",&nbsp;name,&nbsp;author);<br>&nbsp;&nbsp;&nbsp;}<br>}<br><br>class&nbsp;Journal&nbsp;implements&nbsp;Printable&nbsp;{<br>&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;name;<br><br>&nbsp;&nbsp;&nbsp;String&nbsp;getName()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;name;<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;Journal(String&nbsp;name)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;print()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(name);<br>&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">Metoda read() primește ca parametru un obiect al interfeței Printable, deci putem transmite atât un obiect Book, cât și un obiect Journal.</p>
     <p class="paragraph">Metoda createPrintable() returnează un obiect Printable, astfel încât putem returna fie un obiect Book, fie un obiect Journal.</p>
     <p class="paragraph">Rezultatul afișat în consolă:</p>
     <div class="code-inline">
      <pre><code>Foreign&nbsp;Affairs<br>Java&nbsp;for&nbsp;Impatients&nbsp;(Cay&nbsp;Horstmann)<br>Java&nbsp;Daily&nbsp;News</code></pre>
     </div>
    </div>
   </main>
   <aside class="ad-section">
    <div class="ad-box">
     <p>Google Ad Here</p>
    </div>
    <div class="ad-box">
     <p>Promo: SQL Beginner Guide</p>
    </div>
   </aside>
  </div>
  <div class="lesson-navigation">
   <th:block th:if="${previousLesson != null}">
    <a th:href="@{'/lessons/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția anterioară</a>
   </th:block> <th:block th:if="${nextLesson != null}">
    <a th:href="@{'/lessons/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția următoare →</a>
   </th:block>
  </div>
  <div th:replace="~{fragments/footer :: footer}"></div>
  <script th:src="@{/js/script.js}" defer></script>
 </body>
</html>
