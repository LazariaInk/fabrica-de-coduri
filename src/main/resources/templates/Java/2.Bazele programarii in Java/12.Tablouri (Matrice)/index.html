<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">
 <head>
    <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      window.gtag = function () { dataLayer.push(arguments); };
      gtag('consent', 'default', {
        'wait_for_update': 500,
        'region': ['RO'],
        'ad_storage': 'denied',
        'analytics_storage': 'denied',
        'ad_user_data': 'denied',
        'ad_personalization': 'denied'
      });
      gtag('js', new Date());
      gtag('config', 'G-7Q2536ZKL2');
    </script>


  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title th:text="${lesson.title}">Lesson</title>
  <link rel="stylesheet" th:href="@{/css/styles.css}">
  <style>body { background: #ffffff; }</style>
 </head>
 <body th:with="activeTopic='Java', activeChapter='2.Bazele programarii in Java', activeLesson='12.Tablouri (Matrice)'">
  <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
  <div th:replace="~{fragments/nav :: nav}"></div>
  <div class="top-nav">
   <th:block th:each="topic : ${topics}">
    <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}" th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a>
   </th:block>
  </div>
  <div class="layout">
   <div class="mobile-sidebar" id="mobileSidebar">
    <button class="close-btn" onclick="toggleSidebar()">✖</button>
    <ul class="chapter-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-title" onclick="toggleChapter(this)">
        <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
       </div>
       <ul class="lesson-list">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </div>
   <aside class="sidebar">
    <ul class="sidebar-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-toggle" onclick="toggleLessons(this)">
        <span th:text="${chapter.title}">Chapter</span>
       </div>
       <ul class="lesson-list hidden">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </aside>
   <main class="content">
    <div class="document-container">
     <h1 class="main-title">Tablouri (Matrice)</h1>
     <p class="paragraph">Un tablou (sau matrice) reprezintă un set de valori de același tip. Declarația unui tablou este similară cu declarația unei variabile care stochează o singură valoare, iar în Java există două moduri de a declara un tablou:</p>
     <div class="code-inline">
      <pre><code>tip_date&nbsp;nume_tablou[];<br>//&nbsp;sau<br>tip_date[]&nbsp;nume_tablou;</code></pre>
     </div>
     <p class="paragraph">De exemplu, putem defini un tablou de numere astfel:</p>
     <div class="code-inline">
      <pre><code>int&nbsp;nums[];<br>int[]&nbsp;nums2;</code></pre>
     </div>
     <p class="paragraph">După declararea tabloului, acesta trebuie inițializat:</p>
     <div class="code-inline">
      <pre><code>int&nbsp;nums[];<br>nums&nbsp;=&nbsp;new&nbsp;int[4];&nbsp;&nbsp;//&nbsp;tablou&nbsp;de&nbsp;4&nbsp;numere</code></pre>
     </div>
     <p class="paragraph">Crearea unui tablou se face prin următoarea sintaxă: new tip_date[număr_elemente], unde new este cuvântul cheie care alocă memorie pentru numărul specificat de elemente. De exemplu, nums = new int[4]; creează un tablou cu patru elemente de tip int, fiecare având valoarea implicită 0.</p>
     <p class="paragraph">Putem inițializa tabloul și în momentul declarării:</p>
     <div class="code-inline">
      <pre><code>int&nbsp;nums[]&nbsp;=&nbsp;new&nbsp;int[4];&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;tablou&nbsp;cu&nbsp;4&nbsp;numere<br>int[]&nbsp;nums2&nbsp;=&nbsp;new&nbsp;int[5];&nbsp;&nbsp;&nbsp;//&nbsp;tablou&nbsp;cu&nbsp;5&nbsp;numere</code></pre>
     </div>
     <p class="paragraph">La inițializare, toate elementele tabloului primesc valoarea implicită. Pentru tipurile numerice (inclusiv pentru char), valoarea implicită este 0, pentru tipul boolean este false, iar pentru alte obiecte este null. De exemplu, tabloul nums va conține patru zerouri.</p>
     <p class="paragraph">De asemenea, putem specifica valori explicite pentru elementele tabloului:</p>
     <div class="code-inline">
      <pre><code>int[]&nbsp;nums&nbsp;=&nbsp;new&nbsp;int[]&nbsp;{&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;5&nbsp;};<br>int[]&nbsp;nums2&nbsp;=&nbsp;{&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;5&nbsp;};</code></pre>
     </div>
     <p class="paragraph">În acest caz, dimensiunea tabloului nu este specificată în parantezele pătrate, deoarece este calculată automat pe baza numărului de elemente specificate în acolade.</p>
     <p class="paragraph">După crearea tabloului, putem accesa oricare dintre elementele sale prin intermediul indicilor, care se specifică în parantezele pătrate după numele variabilei tabloului:</p>
     <div class="code-inline">
      <pre><code>int[]&nbsp;nums&nbsp;=&nbsp;new&nbsp;int[4];<br>//&nbsp;setăm&nbsp;valorile&nbsp;elementelor&nbsp;tabloului<br>nums[0]&nbsp;=&nbsp;1;<br>nums[1]&nbsp;=&nbsp;2;<br>nums[2]&nbsp;=&nbsp;4;<br>nums[3]&nbsp;=&nbsp;100;<br><br>//&nbsp;obținem&nbsp;valoarea&nbsp;celui&nbsp;de-al&nbsp;treilea&nbsp;element<br>System.out.println(nums[2]);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;4</code></pre>
     </div>
     <p class="paragraph">Indexarea elementelor unui tablou începe de la 0, astfel încât pentru a accesa al patrulea element, folosim nums[3]. Dacă încercăm să accesăm un element dincolo de dimensiunea tabloului, de exemplu nums[5] = 5;, vom primi o eroare.</p>
     <h2 class="subtitle">Lungimea tabloului</h2>
     <p class="paragraph">Proprietatea length returnează lungimea tabloului, adică numărul de elemente pe care le conține:</p>
     <div class="code-inline">
      <pre><code>int[]&nbsp;nums&nbsp;=&nbsp;{1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5};<br>int&nbsp;length&nbsp;=&nbsp;nums.length;&nbsp;&nbsp;&nbsp;//&nbsp;5</code></pre>
     </div>
     <p class="paragraph">Pentru a accesa ultimul element dintr-un tablou, putem folosi această proprietate:</p>
     <div class="code-inline">
      <pre><code>int&nbsp;last&nbsp;=&nbsp;nums[nums.length&nbsp;-&nbsp;1];</code></pre>
     </div>
     <h2 class="subtitle">Tablouri multidimensionale</h2>
     <p class="paragraph">Pe lângă tablourile unidimensionale, care pot fi considerate ca o listă de valori de același tip, există și tablouri multidimensionale, cel mai cunoscut fiind tabloul bidimensional (o matrice):</p>
     <div class="code-inline">
      <pre><code>int[]&nbsp;nums1&nbsp;=&nbsp;new&nbsp;int[]&nbsp;{&nbsp;0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5&nbsp;};<br>int[][]&nbsp;nums2&nbsp;=&nbsp;{&nbsp;{&nbsp;0,&nbsp;1,&nbsp;2&nbsp;},&nbsp;{&nbsp;3,&nbsp;4,&nbsp;5&nbsp;}&nbsp;};</code></pre>
     </div>
     <p class="paragraph">Vizual, ambele tablouri ar arăta astfel:</p>
     <ul class="enumeration">
      <li>Tabloul unidimensional nums1:</li>
     </ul>
     <div class="image-container">
      <img th:src="@{/images/Java/2.Bazele%20programarii%20in%20Java/12.Tablouri%20(Matrice)/images/image1.png}" alt="" class="responsive-image">
     </div>
     <ul class="enumeration">
      <li>Tabloul bidimensional nums2 (matrice):</li>
     </ul>
     <div class="image-container">
      <img th:src="@{/images/Java/2.Bazele%20programarii%20in%20Java/12.Tablouri%20(Matrice)/images/image2.png}" alt="" class="responsive-image">
     </div>
     <p class="paragraph">Deoarece tabloul nums2 este bidimensional, îl putem considera o simplă matrice. De asemenea, putem crea un astfel de tablou cu sintaxa int[][] nums2 = new int[2][3];, unde numărul de paranteze pătrate indică dimensiunea tabloului, iar valorile din paranteze specifică numărul de rânduri și coloane. Putem accesa elementele sale astfel:</p>
     <div class="code-inline">
      <pre><code>nums2[1][0]&nbsp;=&nbsp;44;<br>System.out.println(nums2[1][0]);&nbsp;&nbsp;&nbsp;//&nbsp;44</code></pre>
     </div>
     <p class="paragraph">Declarația unui tablou tridimensional ar arăta astfel:</p>
     <div class="code-inline">
      <pre><code>int[][][]&nbsp;nums3&nbsp;=&nbsp;new&nbsp;int[2][3][4];</code></pre>
     </div>
     <h2 class="subtitle">Tablouri zimțate</h2>
     <p class="paragraph">Tablourile multidimensionale pot fi, de asemenea, reprezentate ca "tablouri zimțate". În exemplul de mai sus, tabloul bidimensional avea 2 rânduri și 3 coloane, formând astfel o matrice regulată. Totuși, putem atribui fiecărui element dintr-un tablou bidimensional un alt tablou cu un număr diferit de elemente:</p>
     <div class="code-inline">
      <pre><code>int[][]&nbsp;nums&nbsp;=&nbsp;new&nbsp;int[3][];<br>nums[0]&nbsp;=&nbsp;new&nbsp;int[2];<br>nums[1]&nbsp;=&nbsp;new&nbsp;int[3];<br>nums[2]&nbsp;=&nbsp;new&nbsp;int[5];</code></pre>
     </div>
     <h2 class="subtitle">Iterarea elementelor tabloului: foreach</h2>
     <p class="paragraph">Java oferă o versiune specială a ciclului for pentru a itera prin elementele unui tablou sau colecție, asemănător ciclului foreach din alte limbaje:</p>
     <div class="code-inline">
      <pre><code>int[]&nbsp;array&nbsp;=&nbsp;new&nbsp;int[]&nbsp;{&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5&nbsp;};<br>for&nbsp;(int&nbsp;i&nbsp;:&nbsp;array)&nbsp;{<br>&nbsp;&nbsp;&nbsp;System.out.println(i);<br>}</code></pre>
     </div>
     <p class="paragraph">Aceasta este o variantă simplă și eficientă de a parcurge toate elementele unui tablou.</p>
     <p class="paragraph">Totuși, același lucru poate fi realizat și cu versiunea clasică a ciclului for:</p>
     <div class="code-inline">
      <pre><code>int[]&nbsp;array&nbsp;=&nbsp;new&nbsp;int[]&nbsp;{&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5&nbsp;};<br>for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;array.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;System.out.println(array[i]);<br>}</code></pre>
     </div>
     <p class="paragraph">Această versiune este mai flexibilă, permițând modificarea elementelor tabloului:</p>
     <div class="code-inline">
      <pre><code>int[]&nbsp;array&nbsp;=&nbsp;new&nbsp;int[]&nbsp;{&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5&nbsp;};<br>for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;array.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;array[i]&nbsp;=&nbsp;array[i]&nbsp;*&nbsp;2;<br>&nbsp;&nbsp;&nbsp;System.out.println(array[i]);<br>}</code></pre>
     </div>
     <h2 class="subtitle">Iterarea tablourilor multidimensionale</h2>
     <p class="paragraph">Pentru a parcurge elementele unui tablou bidimensional, putem folosi un ciclu dublu for:</p>
     <div class="code-inline">
      <pre><code>int[][]&nbsp;nums&nbsp;=&nbsp;{<br>&nbsp;&nbsp;&nbsp;{1,&nbsp;2,&nbsp;3},<br>&nbsp;&nbsp;&nbsp;{4,&nbsp;5,&nbsp;6},<br>&nbsp;&nbsp;&nbsp;{7,&nbsp;8,&nbsp;9}<br>};<br>for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;nums.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;nums[i].length;&nbsp;j++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.printf("%d&nbsp;",&nbsp;nums[i][j]);<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;System.out.println();<br>}</code></pre>
     </div>
     <p class="paragraph">În acest caz, primul ciclu iterează prin rândurile matricei, iar al doilea ciclu parcurge coloanele fiecărui rând. Aceeași metodă poate fi aplicată și pentru tablourile tridimensionale sau de dimensiuni mai mari.</p>
    </div>
   </main>
   <aside class="ad-section">
    <div class="ad-box">
     <p>Google Ad Here</p>
    </div>
    <div class="ad-box">
     <p>Promo: SQL Beginner Guide</p>
    </div>
   </aside>
  </div>
  <div class="lesson-navigation">
   <th:block th:if="${previousLesson != null}">
    <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția anterioară</a>
   </th:block> <th:block th:if="${nextLesson != null}">
    <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția următoare →</a>
   </th:block>
  </div>
  <div th:replace="~{fragments/footer :: footer}"></div>
  <script th:src="@{/js/script.js}" defer></script>
 </body>
</html>
