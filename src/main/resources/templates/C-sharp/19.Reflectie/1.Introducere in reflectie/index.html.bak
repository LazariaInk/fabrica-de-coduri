<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">
 <head>
    <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      window.gtag = function () { dataLayer.push(arguments); };
      gtag('consent', 'default', {
        'wait_for_update': 500,
        'region': ['RO'],
        'ad_storage': 'denied',
        'analytics_storage': 'denied',
        'ad_user_data': 'denied',
        'ad_personalization': 'denied'
      });
      gtag('js', new Date());
      gtag('config', 'G-7Q2536ZKL2');
    </script>


  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title th:text="${lesson.title}">Lesson</title>
  <link rel="stylesheet" th:href="@{/css/styles.css}">
  <style>
        body {
            background: #ffffff;
        }
    </style>
 </head>
 <body th:with="activeTopic='C-sharp', activeChapter='19.Reflectie', activeLesson='1.Introducere in reflectie'">
  <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
  <div th:replace="~{fragments/nav :: nav}"></div>
  <div class="top-nav">
   <th:block th:each="topic : ${topics}">
    <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}" th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a>
   </th:block>
  </div>
  <div class="layout">
   <div class="mobile-sidebar" id="mobileSidebar">
    <button class="close-btn" onclick="toggleSidebar()">✖</button>
    <ul class="chapter-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-title" onclick="toggleChapter(this)">
        <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
       </div>
       <ul class="lesson-list">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lessons/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </div>
   <aside class="sidebar">
    <ul class="sidebar-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-toggle" onclick="toggleLessons(this)">
        <span th:text="${chapter.title}">Chapter</span>
       </div>
       <ul class="lesson-list hidden">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lessons/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </aside>
   <main class="content">
    <div class="document-container">
     <h1 class="main-title">Introducere în reflecție - Clasa System.Type</h1>
     <p class="paragraph">Reflecția reprezintă procesul de identificare a tipurilor în timpul rulării aplicației. Fiecare aplicație conține un set de clase utilizate, interfețe, precum și metodele, proprietățile și alte componente ale acestora. Reflecția permite determinarea tuturor acestor elemente componente ale aplicației. Principala sarcină a reflecției este studierea tipurilor.</p>
     <p class="paragraph">Funcționalitatea principală a reflecției este concentrată în spațiul de nume System.Reflection. Aici, putem evidenția următoarele clase principale:</p>
     <ul class="enumeration">
      <li>Assembly: clasa care reprezintă o asamblare și permite manipularea acesteia</li>
      <li>AssemblyName: clasa care stochează informații despre asamblare</li>
      <li>MemberInfo: clasa abstractă de bază care definește funcționalitatea comună pentru clasele EventInfo, FieldInfo, MethodInfo și PropertyInfo</li>
      <li>EventInfo: clasa care stochează informații despre un eveniment</li>
      <li>FieldInfo: stochează informații despre un anumit câmp al unui tip</li>
      <li>MethodInfo: stochează informații despre o anumită metodă</li>
      <li>PropertyInfo: stochează informații despre o proprietate</li>
      <li>ConstructorInfo: clasa care reprezintă un constructor</li>
      <li>Module: clasa care permite accesul la un anumit modul dintr-o asamblare</li>
      <li>ParameterInfo: clasa care stochează informații despre un parametru al unei metode</li>
     </ul>
     <p class="paragraph">Aceste clase reprezintă blocurile componente ale unui tip și aplicației: metode, proprietăți etc. Pentru a obține informații despre membrii unui tip, trebuie să utilizăm clasa System.Type.</p>
     <p class="paragraph">Clasa Type reprezintă tipul studiat, încapsulând toate informațiile despre acesta. Cu ajutorul proprietăților și metodelor sale, putem obține aceste informații. Unele dintre proprietățile și metodele sale sunt:</p>
     <ul class="enumeration">
      <li>FindMembers() returnează un array de obiecte MemberInfo al tipului dat</li>
      <li>GetConstructors() returnează toți constructorii tipului dat sub formă de set de obiecte ConstructorInfo</li>
      <li>GetEvents() returnează toate evenimentele tipului dat sub formă de array de obiecte EventInfo</li>
      <li>GetFields() returnează toate câmpurile tipului dat sub formă de array de obiecte FieldInfo</li>
      <li>GetInterfaces() obține toate interfețele implementate de tipul dat sub formă de array de obiecte Type</li>
      <li>GetMembers() returnează toți membrii tipului sub formă de array de obiecte MemberInfo</li>
      <li>GetMethods() obține toate metodele tipului sub formă de array de obiecte MethodInfo</li>
      <li>GetProperties() obține toate proprietățile sub formă de array de obiecte PropertyInfo</li>
      <li>Name returnează numele tipului</li>
      <li>Assembly returnează numele asamblării în care este definit tipul</li>
      <li>Namespace returnează numele spațiului de nume în care este definit tipul</li>
      <li>IsArray returnează true dacă tipul este un array</li>
      <li>IsClass returnează true dacă tipul reprezintă o clasă</li>
      <li>IsEnum returnează true dacă tipul este o enumerație</li>
      <li>IsInterface returnează true dacă tipul reprezintă o interfață</li>
     </ul>
     <h2 class="subtitle">Obținerea tipului</h2>
     <p class="paragraph">Pentru a manipula tipul și a obține toate informațiile despre acesta, trebuie mai întâi să obținem tipul respectiv. Acest lucru poate fi realizat în trei moduri: cu ajutorul operatorului typeof, folosind metoda GetType() a clasei Object și aplicând metoda statică Type.GetType().</p>
     <p class="paragraph">Obținerea tipului prin typeof:</p>
     <div class="code-inline">
      <pre><code>Type&nbsp;myType&nbsp;=&nbsp;typeof(Person);<br><br>Console.WriteLine(myType);&nbsp;&nbsp;//&nbsp;Person<br><br>public&nbsp;class&nbsp;Person<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;}<br>&nbsp;&nbsp;&nbsp;public&nbsp;Person(string&nbsp;name)&nbsp;=&gt;&nbsp;Name&nbsp;=&nbsp;name;<br>}</code></pre>
     </div>
     <p class="paragraph">Aici, este definită clasa Person cu o anumită funcționalitate. Pentru a obține tipul acesteia, se folosește expresia Type myType = typeof(Person);.</p>
     <p class="paragraph">Obținerea tipului folosind metoda GetType, moștenită de la clasa Object:</p>
     <div class="code-inline">
      <pre><code>Person&nbsp;tom&nbsp;=&nbsp;new&nbsp;Person("Tom");<br>Type&nbsp;myType&nbsp;=&nbsp;tom.GetType();</code></pre>
     </div>
     <p class="paragraph">Spre deosebire de exemplul anterior, aici, pentru a obține tipul, trebuie să creăm un obiect al clasei.</p>
     <p class="paragraph">Al treilea mod de obținere a tipului - metoda statică Type.GetType():</p>
     <div class="code-inline">
      <pre><code>Type?&nbsp;myType&nbsp;=&nbsp;Type.GetType("Person",&nbsp;false,&nbsp;true);</code></pre>
     </div>
     <p class="paragraph">Primul parametru indică numele complet al clasei cu spațiul de nume. Al doilea parametru indică dacă va fi generată o excepție în cazul în care clasa nu poate fi găsită. În acest caz, valoarea false înseamnă că excepția nu va fi generată.</p>
     <p class="paragraph">Al treilea parametru indică dacă trebuie să se țină cont de sensibilitatea la majuscule și minuscule în primul parametru. Valoarea true înseamnă că sensibilitatea la majuscule și minuscule este ignorată. Deoarece tipul specificat poate lipsi, metoda returnează un obiect de tip nullable.</p>
     <p class="paragraph">În acest caz, clasa principală a programului și clasa Person se află în spațiul de nume global. Totuși, dacă tipul este situat într-un alt spațiu de nume, acesta trebuie de asemenea specificat:</p>
     <div class="code-inline">
      <pre><code>Type?&nbsp;myType&nbsp;=&nbsp;Type.GetType("PeopleTypes.Person",&nbsp;false,&nbsp;true);<br><br>Console.WriteLine(myType);&nbsp;&nbsp;//&nbsp;PeopleTypes.Person<br><br>namespace&nbsp;PeopleTypes<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;Person<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Person(string&nbsp;name)&nbsp;=&gt;&nbsp;Name&nbsp;=&nbsp;name;<br>&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">Ca alternativă, putem folosi operatorul typeof, transmițându-i numele tipului cu specificarea spațiului de nume:</p>
     <div class="code-inline">
      <pre><code>Type&nbsp;myType&nbsp;=&nbsp;typeof(PeopleTypes.Person);</code></pre>
     </div>
     <p class="paragraph">Dacă tipul necesar se află într-o altă asamblare dll, atunci după numele complet al clasei, se specifică numele asamblării, separat prin virgulă:</p>
     <div class="code-inline">
      <pre><code>Type&nbsp;myType&nbsp;=&nbsp;Type.GetType("PeopleTypes.Person,&nbsp;MyLibrary",&nbsp;false,&nbsp;true);</code></pre>
     </div>
     <p class="paragraph">Acum vom explora tipul și vom obține câteva informații despre el.</p>
     <div class="code-inline">
      <pre><code>Type&nbsp;myType&nbsp;=&nbsp;typeof(PeopleTypes.Person);<br><br>Console.WriteLine($"Name:&nbsp;{myType.Name}");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;obținem&nbsp;numele&nbsp;scurt&nbsp;al&nbsp;tipului<br>Console.WriteLine($"Full&nbsp;Name:&nbsp;{myType.FullName}");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;obținem&nbsp;numele&nbsp;complet&nbsp;al&nbsp;tipului<br>Console.WriteLine($"Namespace:&nbsp;{myType.Namespace}");&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;obținem&nbsp;spațiul&nbsp;de&nbsp;nume&nbsp;al&nbsp;tipului<br>Console.WriteLine($"Is&nbsp;struct:&nbsp;{myType.IsValueType}");&nbsp;&nbsp;//&nbsp;verificăm&nbsp;dacă&nbsp;tipul&nbsp;este&nbsp;structură<br>Console.WriteLine($"Is&nbsp;class:&nbsp;{myType.IsClass}");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;verificăm&nbsp;dacă&nbsp;tipul&nbsp;este&nbsp;clasă<br><br>namespace&nbsp;PeopleTypes<br>{<br>&nbsp;&nbsp;&nbsp;class&nbsp;Person<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Person(string&nbsp;name)&nbsp;=&gt;&nbsp;Name&nbsp;=&nbsp;name;<br>&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">Output-ul consolei:</p>
     <div class="code-inline">
      <pre><code>Name:&nbsp;Person<br>Full&nbsp;Name:&nbsp;PeopleTypes.Person<br>Namespace:&nbsp;PeopleTypes<br>Is&nbsp;struct:&nbsp;False<br>Is&nbsp;class:&nbsp;True</code></pre>
     </div>
     <h2 class="subtitle">Căutarea interfețelor implementate</h2>
     <p class="paragraph">Pentru a obține toate interfețele implementate de tip, trebuie să utilizăm metoda GetInterfaces(), care returnează un array de obiecte Type:</p>
     <div class="code-inline">
      <pre><code>Type&nbsp;myType&nbsp;=&nbsp;typeof(Person);<br><br>Console.WriteLine("Interfețele&nbsp;implementate:");<br>foreach&nbsp;(Type&nbsp;i&nbsp;in&nbsp;myType.GetInterfaces())<br>{<br>&nbsp;&nbsp;&nbsp;Console.WriteLine(i.Name);<br>}<br><br>public&nbsp;class&nbsp;Person&nbsp;:&nbsp;IEater,&nbsp;IMovable<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;}<br>&nbsp;&nbsp;&nbsp;public&nbsp;Person(string&nbsp;name)&nbsp;=&gt;&nbsp;Name&nbsp;=&nbsp;name;<br>&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Eat()&nbsp;=&gt;&nbsp;Console.WriteLine($"{Name}&nbsp;mănâncă");<br><br>&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Move()&nbsp;=&gt;&nbsp;Console.WriteLine($"{Name}&nbsp;se&nbsp;mișcă");<br>}<br><br>interface&nbsp;IEater<br>{<br>&nbsp;&nbsp;&nbsp;void&nbsp;Eat();<br>}<br><br>interface&nbsp;IMovable<br>{<br>&nbsp;&nbsp;&nbsp;void&nbsp;Move();<br>}</code></pre>
     </div>
     <p class="paragraph">Deoarece fiecare interfață reprezintă un obiect Type, pentru fiecare interfață obținută putem aplica metodele discutate mai sus pentru a extrage informații despre proprietăți și metode.</p>
     <p class="paragraph">Însă până acum, toate exemplele de mai sus nu au folosit reflecția. În următoarele teme vom examina cum putem folosi reflecția pentru a obține componentele unui tip și pentru a le accesa, de exemplu, pentru a modifica valorile câmpurilor private ale unei clase.</p>
    </div>
   </main>
   <aside class="ad-section">
    <div class="ad-box">
     <p>Google Ad Here</p>
    </div>
    <div class="ad-box">
     <p>Promo: SQL Beginner Guide</p>
    </div>
   </aside>
  </div>
  <div class="lesson-navigation">
   <th:block th:if="${previousLesson != null}">
    <a th:href="@{'/lessons/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția anterioară</a>
   </th:block> <th:block th:if="${nextLesson != null}">
    <a th:href="@{'/lessons/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția următoare →</a>
   </th:block>
  </div>
  <div th:replace="~{fragments/footer :: footer}"></div>
  <script th:src="@{/js/script.js}" defer></script>
 </body>
</html>
