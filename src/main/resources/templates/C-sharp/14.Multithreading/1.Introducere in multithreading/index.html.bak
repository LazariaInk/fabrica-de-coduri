<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">
 <head>
    <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      window.gtag = function () { dataLayer.push(arguments); };
      gtag('consent', 'default', {
        'wait_for_update': 500,
        'region': ['RO'],
        'ad_storage': 'denied',
        'analytics_storage': 'denied',
        'ad_user_data': 'denied',
        'ad_personalization': 'denied'
      });
      gtag('js', new Date());
      gtag('config', 'G-7Q2536ZKL2');
    </script>


  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title th:text="${lesson.title}">Lesson</title>
  <link rel="stylesheet" th:href="@{/css/styles.css}">
  <style>
        body {
            background: #ffffff;
        }
    </style>
 </head>
 <body th:with="activeTopic='C-sharp', activeChapter='14.Multithreading', activeLesson='1.Introducere in multithreading'">
  <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
  <div th:replace="~{fragments/nav :: nav}"></div>
  <div class="top-nav">
   <th:block th:each="topic : ${topics}">
    <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}" th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a>
   </th:block>
  </div>
  <div class="layout">
   <div class="mobile-sidebar" id="mobileSidebar">
    <button class="close-btn" onclick="toggleSidebar()">✖</button>
    <ul class="chapter-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-title" onclick="toggleChapter(this)">
        <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
       </div>
       <ul class="lesson-list">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lessons/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </div>
   <aside class="sidebar">
    <ul class="sidebar-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-toggle" onclick="toggleLessons(this)">
        <span th:text="${chapter.title}">Chapter</span>
       </div>
       <ul class="lesson-list hidden">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lessons/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </aside>
   <main class="content">
    <div class="document-container">
     <h1 class="main-title">Introducere în multithreading - Clasa Thread</h1>
     <p class="paragraph">Unul dintre aspectele cheie în programarea modernă este multithreading-ul. Conceptul principal în lucrul cu multithreading-ul este thread-ul. Un thread reprezintă o parte din codul programului. La rularea programului, fiecărui thread i se alocă un anumit cuantum de timp.</p>
     <p class="paragraph">Prin intermediul multithreading-ului, putem aloca în aplicație mai multe thread-uri care vor executa diverse sarcini simultan. Dacă avem, de exemplu, o aplicație grafică ce trimite o cerere către un server sau citește și procesează un fișier mare, fără multithreading, interfața grafică ar fi blocată pe durata executării sarcinii.</p>
     <p class="paragraph">Datorită thread-urilor, putem aloca trimiterea cererii sau orice altă sarcină care necesită timp îndelungat unui thread separat. Astfel, de exemplu, aplicațiile client-server (și nu doar ele) sunt de neconceput fără multithreading.</p>
     <p class="paragraph">Funcționalitatea principală pentru utilizarea thread-urilor într-o aplicație este concentrată în namespace-ul System.Threading. În acesta este definită clasa ce reprezintă un thread separat - clasa Thread.</p>
     <p class="paragraph">Clasa Thread definește o serie de metode și proprietăți care permit gestionarea thread-ului și obținerea informațiilor despre acesta. Proprietățile principale ale clasei sunt:</p>
     <ul class="enumeration">
      <li>ExecutionContext: permite obținerea contextului în care se execută thread-ul</li>
      <li>IsAlive: indică dacă thread-ul rulează în prezent</li>
      <li>IsBackground: indică dacă thread-ul este de fundal</li>
      <li>Name: conține numele thread-ului</li>
      <li>ManagedThreadId: returnează identificatorul numeric al thread-ului curent</li>
      <li>Priority: stochează prioritatea thread-ului - valoarea unei enumerații ThreadPriority: Lowest BelowNormal Normal AboveNormal Highest</li>
     </ul>
     <p class="paragraph">Implicit, unui thread i se atribuie valoarea Normal. Totuși, putem modifica prioritatea în timpul rulării programului. De exemplu, putem crește importanța thread-ului setând prioritatea Highest. Mediul CLR va citi și analiza valorile priorității și, pe baza acestora, va aloca thread-ului respectiv o anumită cantitate de timp.</p>
     <ul class="enumeration">
      <li>ThreadState returnează starea thread-ului - una dintre valorile enumerației ThreadState:</li>
      <li>Aborted: thread-ul este oprit, dar încă nu a fost finalizat</li>
      <li>AbortRequested: pentru thread a fost apelată metoda Abort, dar oprirea încă nu a avut loc</li>
      <li>Background: thread-ul rulează în mod de fundal</li>
      <li>Running: thread-ul este pornit și rulează (nu este suspendat)</li>
      <li>Stopped: thread-ul este finalizat</li>
      <li>StopRequested: thread-ul a primit o cerere de oprire</li>
      <li>Suspended: thread-ul este suspendat</li>
      <li>SuspendRequested: thread-ul a primit o cerere de suspendare</li>
      <li>Unstarted: thread-ul nu a fost încă pornit</li>
      <li>WaitSleepJoin: thread-ul este blocat în urma apelării metodelor Sleep sau Join</li>
     </ul>
     <p class="paragraph">În timpul rulării thread-ului, starea acestuia poate fi modificată de mai multe ori prin intermediul metodelor. De exemplu, la început, înainte de aplicarea metodei Start, starea este Unstarted. După pornirea thread-ului, starea se schimbă în Running. Apelând metoda Sleep, starea se va schimba în WaitSleepJoin.</p>
     <p class="paragraph">În plus, proprietatea statică CurrentThread a clasei Thread permite obținerea thread-ului curent.</p>
     <p class="paragraph">Într-un program C#, există cel puțin un thread - thread-ul principal, în care se execută metoda Main.</p>
     <p class="paragraph">De exemplu, utilizăm proprietățile descrise mai sus pentru a obține informații despre thread:</p>
     <div class="code-inline">
      <pre><code>using&nbsp;System.Threading;<br><br>//&nbsp;obținem&nbsp;thread-ul&nbsp;curent<br>Thread&nbsp;currentThread&nbsp;=&nbsp;Thread.CurrentThread;<br><br>//&nbsp;obținem&nbsp;numele&nbsp;thread-ului<br>Console.WriteLine($"Numele&nbsp;thread-ului:&nbsp;{currentThread.Name}");<br>currentThread.Name&nbsp;=&nbsp;"Metoda&nbsp;Main";<br>Console.WriteLine($"Numele&nbsp;thread-ului:&nbsp;{currentThread.Name}");<br><br>Console.WriteLine($"Thread-ul&nbsp;este&nbsp;pornit:&nbsp;{currentThread.IsAlive}");<br>Console.WriteLine($"Id-ul&nbsp;thread-ului:&nbsp;{currentThread.ManagedThreadId}");<br>Console.WriteLine($"Prioritatea&nbsp;thread-ului:&nbsp;{currentThread.Priority}");<br>Console.WriteLine($"Starea&nbsp;thread-ului:&nbsp;{currentThread.ThreadState}");</code></pre>
     </div>
     <p class="paragraph">În acest caz, vom obține aproximativ următorul output:</p>
     <div class="code-inline">
      <pre><code>Numele&nbsp;thread-ului:<br>Numele&nbsp;thread-ului:&nbsp;Metoda&nbsp;Main<br>Thread-ul&nbsp;este&nbsp;pornit:&nbsp;True<br>Id-ul&nbsp;thread-ului:&nbsp;1<br>Prioritatea&nbsp;thread-ului:&nbsp;Normal<br>Starea&nbsp;thread-ului:&nbsp;Running</code></pre>
     </div>
     <p class="paragraph">Deoarece implicit, proprietatea Name a obiectelor Thread nu este setată, în primul caz vom obține o valoare de șir gol pentru această proprietate.</p>
     <p class="paragraph">De asemenea, clasa Thread definește o serie de metode pentru gestionarea thread-urilor. Principalele dintre acestea sunt:</p>
     <ul class="enumeration">
      <li>Metoda statică GetDomain returnează o referință la domeniul aplicației</li>
      <li>Metoda statică GetDomainID returnează id-ul domeniului aplicației în care se execută thread-ul curent</li>
      <li>Metoda statică Sleep oprește thread-ul pentru un anumit număr de milisecunde</li>
      <li>Metoda Interrupt întrerupe thread-ul aflat în starea WaitSleepJoin</li>
      <li>Metoda Join blochează execuția thread-ului care a apelat această metodă până când se finalizează thread-ul pentru care a fost apelată metoda</li>
      <li>Metoda Start pornește thread-ul</li>
     </ul>
     <p class="paragraph">De exemplu, utilizăm metoda Sleep pentru a seta o întârziere în execuția aplicației:</p>
     <div class="code-inline">
      <pre><code>using&nbsp;System.Threading;<br><br>for(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i++)<br>{<br>&nbsp;&nbsp;&nbsp;Thread.Sleep(500);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;întârziere&nbsp;în&nbsp;execuție&nbsp;de&nbsp;500&nbsp;de&nbsp;milisecunde<br>&nbsp;&nbsp;&nbsp;Console.WriteLine(i);<br>}</code></pre>
     </div>
    </div>
   </main>
   <aside class="ad-section">
    <div class="ad-box">
     <p>Google Ad Here</p>
    </div>
    <div class="ad-box">
     <p>Promo: SQL Beginner Guide</p>
    </div>
   </aside>
  </div>
  <div class="lesson-navigation">
   <th:block th:if="${previousLesson != null}">
    <a th:href="@{'/lessons/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția anterioară</a>
   </th:block> <th:block th:if="${nextLesson != null}">
    <a th:href="@{'/lessons/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția următoare →</a>
   </th:block>
  </div>
  <div th:replace="~{fragments/footer :: footer}"></div>
  <script th:src="@{/js/script.js}" defer></script>
 </body>
</html>
