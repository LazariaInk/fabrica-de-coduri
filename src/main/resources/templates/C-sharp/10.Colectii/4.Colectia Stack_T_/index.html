<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">
 <head>
    <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      window.gtag = function () { dataLayer.push(arguments); };
      gtag('consent', 'default', {
        'wait_for_update': 500,
        'region': ['RO'],
        'ad_storage': 'denied',
        'analytics_storage': 'denied',
        'ad_user_data': 'denied',
        'ad_personalization': 'denied'
      });
      gtag('js', new Date());
      gtag('config', 'G-7Q2536ZKL2');
    </script>


  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title th:text="${lesson.title}">Lesson</title>
  <link rel="stylesheet" th:href="@{/css/styles.css}">
  <style>
        body {
            background: #ffffff;
        }
    </style>
 </head>
 <body th:with="activeTopic='C-sharp', activeChapter='10.Colectii', activeLesson='4.Colectia Stack_T_'">
  <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
  <div th:replace="~{fragments/nav :: nav}"></div>
  <div class="top-nav">
   <th:block th:each="topic : ${topics}">
    <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}" th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a>
   </th:block>
  </div>
  <div class="layout">
   <div class="mobile-sidebar" id="mobileSidebar">
    <button class="close-btn" onclick="toggleSidebar()">✖</button>
    <ul class="chapter-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-title" onclick="toggleChapter(this)">
        <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
       </div>
       <ul class="lesson-list">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </div>
   <aside class="sidebar">
    <ul class="sidebar-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-toggle" onclick="toggleLessons(this)">
        <span th:text="${chapter.title}">Chapter</span>
       </div>
       <ul class="lesson-list hidden">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </aside>
   <main class="content">
    <div class="document-container">
     <h1 class="main-title">Colecția Stack<t></t></h1>
     <p class="paragraph">Clasa Stack&lt;T&gt; reprezintă o colecție care folosește algoritmul LIFO ("ultimul venit - primul plecat"). În această organizare, fiecare element adăugat este plasat deasupra elementului anterior. Extracția din colecție se face în ordine inversă - este extras elementul care se află deasupra tuturor în stivă.</p>
     <p class="paragraph">Stiva este o structură de date frecvent întâlnită în viața reală. Exemple banale de stive sunt teancurile de cărți sau farfurii, unde fiecare carte sau farfurie nouă este plasată deasupra celei anterioare.</p>
     <p class="paragraph">Iar extragerea din acest teanc se face în ordine inversă - mai întâi elementul de deasupra și așa mai departe. Un alt exemplu este îmbrăcămintea: să presupunem că o persoană iese afară pe vreme de iarnă și își pune mai întâi un tricou, apoi o cămașă, un pulover și, în final, o geacă.</p>
     <p class="paragraph">Când persoana se dezbracă, o face în ordine inversă: mai întâi geaca, apoi puloverul și așa mai departe.</p>
     <h2 class="subtitle">Crearea unei stive</h2>
     <p class="paragraph">Pentru a crea o stivă, se poate folosi unul dintre cei trei constructori ai săi. În primul rând, putem crea o stivă goală:</p>
     <div class="code-inline">
      <pre><code>Stack&lt;string&gt;&nbsp;people&nbsp;=&nbsp;new&nbsp;Stack&lt;string&gt;();</code></pre>
     </div>
     <p class="paragraph">La crearea unei stive goale, se poate specifica capacitatea stivei:</p>
     <div class="code-inline">
      <pre><code>Stack&lt;string&gt;&nbsp;people&nbsp;=&nbsp;new&nbsp;Stack&lt;string&gt;(16);</code></pre>
     </div>
     <p class="paragraph">De asemenea, se poate inițializa stiva cu elemente dintr-o altă colecție sau array:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;employees&nbsp;=&nbsp;new&nbsp;List&lt;string&gt;&nbsp;{&nbsp;"Tom",&nbsp;"Sam",&nbsp;"Bob"&nbsp;};<br>Stack&lt;string&gt;&nbsp;people&nbsp;=&nbsp;new&nbsp;Stack&lt;string&gt;(employees);<br>foreach&nbsp;(var&nbsp;person&nbsp;in&nbsp;people)&nbsp;Console.WriteLine(person);<br><br>Console.WriteLine(people.Count);&nbsp;//&nbsp;3</code></pre>
     </div>
     <p class="paragraph">Pentru parcurgerea stivei se poate folosi ciclul standard foreach. În ciclul foreach, conform algoritmului stivei LIFO, datele sunt extrase în ordine inversă față de adăugare. Rezultatul în consolă în acest caz:</p>
     <div class="code-inline">
      <pre><code>Bob<br>Sam<br>Tom<br>3</code></pre>
     </div>
     <p class="paragraph">Pentru a obține numărul de elemente din stivă se folosește proprietatea Count.</p>
     <h2 class="subtitle">Metodele Stack</h2>
     <p class="paragraph">Clasa Stack&lt;T&gt; are următoarele metode importante:</p>
     <ul class="enumeration">
      <li>void Clear(): șterge toate elementele din stivă</li>
      <li>bool Contains(T item): verifică dacă elementul item este prezent în stivă și returnează true dacă este</li>
      <li>void Push(T item): adaugă un element în stivă, deasupra</li>
      <li>T Pop(): extrage și returnează primul element din stivă</li>
      <li>T Peek(): returnează primul element din stivă fără a-l șterge</li>
     </ul>
     <p class="paragraph">Să vedem un exemplu practic:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;people&nbsp;=&nbsp;new&nbsp;Stack&lt;string&gt;();<br>people.Push("Tom");<br>//&nbsp;people&nbsp;=&nbsp;{&nbsp;Tom&nbsp;}<br>people.Push("Sam");<br>//&nbsp;people&nbsp;=&nbsp;{&nbsp;Sam,&nbsp;Tom&nbsp;}<br>people.Push("Bob");<br>//&nbsp;people&nbsp;=&nbsp;{&nbsp;Bob,&nbsp;Sam,&nbsp;Tom&nbsp;}<br><br>//&nbsp;obținem&nbsp;primul&nbsp;element&nbsp;din&nbsp;stivă&nbsp;fără&nbsp;a-l&nbsp;șterge<br>string&nbsp;headPerson&nbsp;=&nbsp;people.Peek();<br>Console.WriteLine(headPerson);&nbsp;&nbsp;//&nbsp;Bob<br><br>string&nbsp;person1&nbsp;=&nbsp;people.Pop();<br>//&nbsp;people&nbsp;=&nbsp;{&nbsp;Sam,&nbsp;Tom&nbsp;}<br>Console.WriteLine(person1);&nbsp;&nbsp;//&nbsp;Bob<br><br>string&nbsp;person2&nbsp;=&nbsp;people.Pop();<br>//&nbsp;people&nbsp;=&nbsp;{&nbsp;Tom&nbsp;}<br>Console.WriteLine(person2);&nbsp;&nbsp;//&nbsp;Sam<br><br>string&nbsp;person3&nbsp;=&nbsp;people.Pop();<br>//&nbsp;people&nbsp;=&nbsp;{&nbsp;}<br>Console.WriteLine(person3);&nbsp;&nbsp;//&nbsp;Tom</code></pre>
     </div>
     <p class="paragraph">Funcționarea stivei poate fi reprezentată prin următoarea ilustrație:</p>
     <div class="image-container">
      <img th:src="@{/images/10.Colectii/4.Colectia%20Stack_T_/images/image1.png}" alt="" class="responsive-image">
     </div>
     <p class="paragraph">Este de remarcat că, dacă folosim metodele Peek sau Pop pentru a obține primul element dintr-o stivă goală, programul va arunca o excepție. Prin urmare, înainte de a obține un element, putem verifica numărul de elemente din stivă:</p>
     <div class="code-inline">
      <pre><code>if(people.Count&nbsp;&gt;&nbsp;0)<br>{<br>&nbsp;&nbsp;&nbsp;var&nbsp;person&nbsp;=&nbsp;people.Peek();<br>&nbsp;&nbsp;&nbsp;people.Pop();<br>}</code></pre>
     </div>
     <p class="paragraph">Sau putem folosi perechea de metode:</p>
     <ul class="enumeration">
      <li>bool TryPop(out T result): șterge primul element din stivă și îl atribuie variabilei result, returnează true dacă stiva nu este goală și elementul a fost obținut cu succes</li>
      <li>bool TryPeek(out T result): atribuie variabilei result primul element din stivă fără a-l șterge, returnează true dacă elementul a fost obținut cu succes</li>
     </ul>
     <p class="paragraph">Aplicarea metodelor:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;people&nbsp;=&nbsp;new&nbsp;Stack&lt;string&gt;();<br>people.Push("Tom");<br>//&nbsp;people&nbsp;=&nbsp;{&nbsp;Tom&nbsp;}<br><br>//&nbsp;ștergem&nbsp;elemente<br>var&nbsp;success1&nbsp;=&nbsp;people.TryPop(out&nbsp;var&nbsp;person1);&nbsp;&nbsp;//&nbsp;success1&nbsp;=&nbsp;true<br>if&nbsp;(success1)&nbsp;Console.WriteLine(person1);&nbsp;//&nbsp;Tom<br><br>var&nbsp;success2&nbsp;=&nbsp;people.TryPeek(out&nbsp;var&nbsp;person2);&nbsp;&nbsp;//&nbsp;success2&nbsp;=&nbsp;false<br>if&nbsp;(success2)&nbsp;Console.WriteLine(person2);</code></pre>
     </div>
    </div>
   </main>
   <aside class="ad-section">
    <div class="ad-box">
     <p>Google Ad Here</p>
    </div>
    <div class="ad-box">
     <p>Promo: SQL Beginner Guide</p>
    </div>
   </aside>
  </div>
  <div class="lesson-navigation">
   <th:block th:if="${previousLesson != null}">
    <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția anterioară</a>
   </th:block> <th:block th:if="${nextLesson != null}">
    <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția următoare →</a>
   </th:block>
  </div>
  <div th:replace="~{fragments/footer :: footer}"></div>
  <script th:src="@{/js/script.js}" defer></script>
 </body>
</html>
