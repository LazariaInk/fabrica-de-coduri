<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">
 <head>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4253419731329045" crossorigin="anonymous"></script>
  <link rel="canonical" th:href="${canonicalUrl}">
  <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
  <script>
      window.dataLayer = window.dataLayer || [];
      window.gtag = function () { dataLayer.push(arguments); };
      gtag('consent', 'default', {
        'wait_for_update': 500,
        'region': ['RO'],
        'ad_storage': 'denied',
        'analytics_storage': 'denied',
        'ad_user_data': 'denied',
        'ad_personalization': 'denied'
      });
      gtag('js', new Date());
      gtag('config', 'G-7Q2536ZKL2');
    </script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title th:text="${lesson.title}">Lesson</title>
  <link rel="stylesheet" th:href="@{/css/styles.css}">
  <style>
        body {
            background: #ffffff;
        }
    </style>
 </head>
 <body th:with="activeTopic='C-sharp', activeChapter='10.Colectii', activeLesson='10.Tipul Span'">
  <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
  <div th:replace="~{fragments/nav :: nav}"></div>
  <div class="top-nav">
   <th:block th:each="topic : ${topics}"> <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}" th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a> </th:block>
  </div>
  <div class="layout">
   <div class="mobile-sidebar" id="mobileSidebar">
    <button class="close-btn" onclick="toggleSidebar()">✖</button>
    <ul class="chapter-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-title" onclick="toggleChapter(this)">
        <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
       </div>
       <ul class="lesson-list">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul>
      </li>
     </th:block>
    </ul>
   </div>
   <aside class="sidebar">
    <ul class="sidebar-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-toggle" onclick="toggleLessons(this)">
        <span th:text="${chapter.title}">Chapter</span>
       </div>
       <ul class="lesson-list hidden">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul>
      </li>
     </th:block>
    </ul>
   </aside>
   <main class="content">
    <div class="document-container">
     <h1 class="main-title">Tipul Span</h1>
     <p class="paragraph">Tipul Span reprezintă o regiune continuă de memorie. Scopul acestui tip este de a crește performanța și eficiența utilizării memoriei. Span permite evitarea alocărilor suplimentare de memorie la operarea cu seturi de date. Deoarece Span este o structură, obiectul acestui tip este plasat pe stivă, nu în heap.</p>
     <h2 class="subtitle">Crearea unui Span</h2>
     <p class="paragraph">Pentru a crea un obiect Span, putem folosi unul dintre constructorii săi:</p>
     <ul class="enumeration">
      <li>Span(): creează un obiect Span gol</li>
      <li>Span(T item): creează un obiect Span cu un element item</li>
      <li>Span(T[] array): creează un obiect Span dintr-un array array</li>
      <li>Span(void* pointer, int length): creează un obiect Span care primește length bytes de memorie începând de la pointer</li>
      <li>Span(T[] array, int start, int length): creează un obiect Span care primește length elemente din array, începând de la indexul start</li>
     </ul>
     <p class="paragraph">De exemplu, o creare simplă a unui Span:</p>
     <div class="code-inline">
      <pre><code>Span&lt;string&gt;&nbsp;people&nbsp;=&nbsp;new&nbsp;Span&lt;string&gt;(new&nbsp;string[]&nbsp;{&nbsp;"Tom",&nbsp;"Bob",&nbsp;"Sam"&nbsp;});</code></pre>
     </div>
     <p class="paragraph">În acest caz, Span va stoca referințe la trei șiruri de caractere.</p>
     <p class="paragraph">Span este adesea creat pe baza altor seturi de date:</p>
     <div class="code-inline">
      <pre><code>string[]&nbsp;people&nbsp;=&nbsp;{&nbsp;"Tom",&nbsp;"Alice",&nbsp;"Bob"&nbsp;};<br>Span&lt;string&gt;&nbsp;peopleSpan&nbsp;=&nbsp;new&nbsp;Span&lt;string&gt;(people);</code></pre>
     </div>
     <p class="paragraph">Putem, de asemenea, să atribuim direct un array, care va fi implicit convertit în Span:</p>
     <ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-4253419731329045" data-ad-slot="8453761934"></ins>
     <script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
     <div class="code-inline">
      <pre><code>string[]&nbsp;people&nbsp;=&nbsp;{&nbsp;"Tom",&nbsp;"Alice",&nbsp;"Bob"&nbsp;};<br>Span&lt;string&gt;&nbsp;peopleSpan&nbsp;=&nbsp;people;</code></pre>
     </div>
     <p class="paragraph">Putem apoi accesa, seta sau itera prin date, la fel ca în cazul unui array:</p>
     <div class="code-inline">
      <pre><code>string[]&nbsp;people&nbsp;=&nbsp;{&nbsp;"Tom",&nbsp;"Alice",&nbsp;"Bob"&nbsp;};<br>Span&lt;string&gt;&nbsp;peopleSpan&nbsp;=&nbsp;people;<br>peopleSpan[1]&nbsp;=&nbsp;"Ann";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;setarea&nbsp;valorii&nbsp;unui&nbsp;element<br>Console.WriteLine(peopleSpan[2]);&nbsp;&nbsp;&nbsp;//&nbsp;obținerea&nbsp;unui&nbsp;element<br>Console.WriteLine(peopleSpan.Length);&nbsp;&nbsp;&nbsp;//&nbsp;obținerea&nbsp;lungimii&nbsp;Span<br><br>//&nbsp;iterația&nbsp;prin&nbsp;Span<br>foreach&nbsp;(var&nbsp;s&nbsp;in&nbsp;peopleSpan)<br>{<br>&nbsp;&nbsp;&nbsp;Console.WriteLine(s);<br>}</code></pre>
     </div>
     <p class="paragraph">Dacă Span se comportă la exterior ca un array, care este avantajul său sau când ne poate fi util? Să luăm un exemplu simplu: avem un array cu valorile temperaturilor zilnice pe parcursul unei luni și trebuie să obținem două seturi - setul temperaturilor din prima decadă și din ultima decadă. Folosind array-uri, am putea proceda astfel:</p>
     <div class="code-inline">
      <pre><code>int[]&nbsp;temperatures&nbsp;=<br>{<br>&nbsp;&nbsp;&nbsp;10,&nbsp;12,&nbsp;13,&nbsp;14,&nbsp;15,&nbsp;11,&nbsp;13,&nbsp;15,&nbsp;16,&nbsp;17,<br>&nbsp;&nbsp;&nbsp;18,&nbsp;16,&nbsp;15,&nbsp;16,&nbsp;17,&nbsp;14,&nbsp;&nbsp;9,&nbsp;&nbsp;8,&nbsp;10,&nbsp;11,<br>&nbsp;&nbsp;&nbsp;12,&nbsp;14,&nbsp;15,&nbsp;15,&nbsp;16,&nbsp;15,&nbsp;13,&nbsp;12,&nbsp;12,&nbsp;11<br>};<br>int[]&nbsp;firstDecade&nbsp;=&nbsp;new&nbsp;int[10];&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;alocăm&nbsp;memorie&nbsp;pentru&nbsp;prima&nbsp;decadă<br>int[]&nbsp;lastDecade&nbsp;=&nbsp;new&nbsp;int[10];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;alocăm&nbsp;memorie&nbsp;pentru&nbsp;a&nbsp;doua&nbsp;decadă<br>Array.Copy(temperatures,&nbsp;0,&nbsp;firstDecade,&nbsp;0,&nbsp;10);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;copiem&nbsp;datele&nbsp;în&nbsp;primul&nbsp;array<br>Array.Copy(temperatures,&nbsp;20,&nbsp;lastDecade,&nbsp;0,&nbsp;10);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;copiem&nbsp;datele&nbsp;în&nbsp;al&nbsp;doilea&nbsp;array</code></pre>
     </div>
     <p class="paragraph">Pentru a stoca datele, creăm două array-uri suplimentare pentru temperaturile zilnice din fiecare decadă. Cu metoda Array.Copy, datele din array-ul inițial temperatures sunt copiate în cele două array-uri.</p>
     <p class="paragraph">Dar în acest caz, suntem forțați să alocăm memorie suplimentară pentru cele două array-uri, care de fapt conțin aceleași date ca temperatures, dar în părți separate ale memoriei.</p>
     <p class="paragraph">Span permite lucrul cu memoria mai eficient și evită alocările inutile de memorie. Folosind Span în loc de array-uri:</p>
     <div class="code-inline">
      <pre><code>int[]&nbsp;temperatures&nbsp;=<br>{<br>&nbsp;&nbsp;&nbsp;10,&nbsp;12,&nbsp;13,&nbsp;14,&nbsp;15,&nbsp;11,&nbsp;13,&nbsp;15,&nbsp;16,&nbsp;17,<br>&nbsp;&nbsp;&nbsp;18,&nbsp;16,&nbsp;15,&nbsp;16,&nbsp;17,&nbsp;14,&nbsp;&nbsp;9,&nbsp;&nbsp;8,&nbsp;10,&nbsp;11,<br>&nbsp;&nbsp;&nbsp;12,&nbsp;14,&nbsp;15,&nbsp;15,&nbsp;16,&nbsp;15,&nbsp;13,&nbsp;12,&nbsp;12,&nbsp;11<br>};<br>Span&lt;int&gt;&nbsp;temperaturesSpan&nbsp;=&nbsp;temperatures;<br><br>Span&lt;int&gt;&nbsp;firstDecade&nbsp;=&nbsp;temperaturesSpan.Slice(0,&nbsp;10);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;fără&nbsp;alocare&nbsp;de&nbsp;memorie&nbsp;pentru&nbsp;date<br>Span&lt;int&gt;&nbsp;lastDecade&nbsp;=&nbsp;temperaturesSpan.Slice(20,&nbsp;10);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;fără&nbsp;alocare&nbsp;de&nbsp;memorie&nbsp;pentru&nbsp;date</code></pre>
     </div>
     <p class="paragraph">Pentru a crea obiecte Span derivate, folosim metoda Slice, care extrage o parte din Span și o returnează sub forma unui alt obiect Span. Acum, obiectele Span firstDecade și lastDecade lucrează cu aceleași date ca temperaturesSpan, dar nu se alocă memorie suplimentară.</p>
     <p class="paragraph">În toate cele trei cazuri, lucrăm cu același array temperatures. Putem chiar să modificăm datele într-un Span și acestea se vor schimba și în celălalt:</p>
     <div class="code-inline">
      <pre><code>int[]&nbsp;temperatures&nbsp;=<br>{<br>&nbsp;&nbsp;&nbsp;10,&nbsp;12,&nbsp;13,&nbsp;14,&nbsp;15,&nbsp;11,&nbsp;13,&nbsp;15,&nbsp;16,&nbsp;17,<br>&nbsp;&nbsp;&nbsp;18,&nbsp;16,&nbsp;15,&nbsp;16,&nbsp;17,&nbsp;14,&nbsp;&nbsp;9,&nbsp;&nbsp;8,&nbsp;10,&nbsp;11,<br>&nbsp;&nbsp;&nbsp;12,&nbsp;14,&nbsp;15,&nbsp;15,&nbsp;16,&nbsp;15,&nbsp;13,&nbsp;12,&nbsp;12,&nbsp;11<br>};<br>Span&lt;int&gt;&nbsp;temperaturesSpan&nbsp;=&nbsp;temperatures;<br><br>Span&lt;int&gt;&nbsp;firstDecade&nbsp;=&nbsp;temperaturesSpan.Slice(0,&nbsp;10);<br><br>temperaturesSpan[0]&nbsp;=&nbsp;25;&nbsp;//&nbsp;schimbăm&nbsp;în&nbsp;temperatureSpan<br>Console.WriteLine(firstDecade[0]);&nbsp;//&nbsp;25</code></pre>
     </div>
     <p class="paragraph">Cum este posibil acest lucru? Pentru a înțelege cum funcționează Span, putem consulta codul sursă al tipului. În special, putem vedea următoarea proprietate:</p>
     <div class="code-inline">
      <pre><code>public&nbsp;readonly&nbsp;ref&nbsp;struct&nbsp;Span&lt;T&gt;<br>{<br>&nbsp;&nbsp;&nbsp;//....<br>&nbsp;&nbsp;&nbsp;public&nbsp;ref&nbsp;T&nbsp;this[int&nbsp;index]&nbsp;{&nbsp;get&nbsp;{&nbsp;...&nbsp;}&nbsp;}<br>&nbsp;&nbsp;&nbsp;//....<br>}</code></pre>
     </div>
     <p class="paragraph">Aici vedem că indexatorul returnează o referință ref, ceea ce ne permite accesul direct la obiect și modificarea acestuia.</p>
     <script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
     <p class="paragraph">În acest caz, avantajele lipsei alocării suplimentare de memorie pentru stocarea obiectelor sunt minime. Dar în lucrul mai intensiv cu datele, câștigul în performanță va crește inevitabil.</p>
     <h2 class="subtitle">Metode Span</h2>
     <p class="paragraph">Metodele principale ale Span:</p>
     <ul class="enumeration">
      <li>void Fill(T value): umple toate elementele Span cu valoarea value</li>
      <li>T[] ToArray(): convertește Span într-un array</li>
      <li>Span&lt;T&gt; Slice(int start, int length): extrage length elemente din Span începând de la indexul start sub forma unui alt Span</li>
      <li>void Clear(): golește Span</li>
      <li>void CopyTo(Span&lt;T&gt; destination): copiază elementele din Span-ul curent în alt Span</li>
      <li>bool TryCopyTo(Span&lt;T&gt; destination): copiază elementele din Span-ul curent în alt Span și returnează un boolean care indică dacă operațiunea de copiere a reușit</li>
     </ul>
     <h2 class="subtitle">ReadOnlySpan</h2>
     <p class="paragraph">Structura ReadOnlySpan este similară cu Span, dar este destinată datelor neschimbabile. De exemplu:</p>
     <div class="code-inline">
      <pre><code>string&nbsp;text&nbsp;=&nbsp;"hello,&nbsp;world";<br>string&nbsp;worldString&nbsp;=&nbsp;text.Substring(startIndex:&nbsp;7,&nbsp;length:&nbsp;5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;alocare&nbsp;de&nbsp;memorie&nbsp;pentru&nbsp;caractere<br>ReadOnlySpan&lt;char&gt;&nbsp;worldSpan&nbsp;=&nbsp;text.AsSpan().Slice(start:&nbsp;7,&nbsp;length:&nbsp;5);&nbsp;//&nbsp;fără&nbsp;alocare&nbsp;de&nbsp;memorie&nbsp;pentru&nbsp;caractere<br>//&nbsp;worldSpan[0]&nbsp;=&nbsp;'a';&nbsp;//&nbsp;Nu&nbsp;se&nbsp;poate&nbsp;modifica<br>Console.WriteLine(worldSpan[0]);&nbsp;//&nbsp;afișează&nbsp;primul&nbsp;caracter<br><br>//&nbsp;iterația&nbsp;prin&nbsp;caractere<br>foreach&nbsp;(var&nbsp;c&nbsp;in&nbsp;worldSpan)<br>{<br>&nbsp;&nbsp;&nbsp;Console.Write(c);<br>}</code></pre>
     </div>
     <p class="paragraph">În acest caz, folosim metoda AsSpan() pentru a converti șirul text într-un obiect ReadOnlySpan&lt;char&gt; și apoi extragem din acesta intervalul de caractere "world". Deoarece ReadOnlySpan este destinat doar pentru citire, nu putem modifica datele prin intermediul său, dar le putem accesa. În rest, lucrul cu ReadOnlySpan se face la fel ca și cu Span.</p>
     <h2 class="subtitle">Limitările Span</h2>
     <p class="paragraph">Ca o structură definită cu modificatorul ref, Span are câteva limitări: nu poate fi atribuit unei variabile de tip Object, dynamic sau unei variabile de tip interfață. Nu poate fi un câmp într-un obiect de tip referință (doar în cadrul structurilor ref). Nu poate fi utilizat în operațiuni await sau yield.</p>
    </div>
    <div class="lesson-navigation">
     <th:block th:if="${previousLesson != null}"> <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția anterioară</a> </th:block> <th:block th:if="${nextLesson != null}"> <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția următoare →</a> </th:block>
    </div>
    <div class="discord-banner-section">
     <div class="discord-banner-container">
      <a href="https://discord.com/channels/1168639076098920578/1168646490726604923" target="_blank"> <img th:src="@{/images/c-sharp-discord.png}" alt="Discord Banner" class="discord-banner-image"> </a>
     </div>
    </div>
   </main>
   <aside class="ad-section">
    <div class="ad-box ad-desktop">
     <ins class="adsbygoogle" style="display:inline-block;width:120px;height:728px" data-ad-client="ca-pub-4253419731329045" data-ad-slot="7123454389"></ins>
    </div>
    <div class="ad-box ad-mobile">
     <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-4253419731329045" data-ad-slot="7123454389"></ins>
    </div>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
   </aside>
  </div>
  <div th:replace="~{fragments/footer :: footer}"></div>
  <script th:src="@{/js/script.js}" defer></script>
 </body>
</html>