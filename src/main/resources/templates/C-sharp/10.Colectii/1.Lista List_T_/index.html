<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">
 <head>
    <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      window.gtag = function () { dataLayer.push(arguments); };
      gtag('consent', 'default', {
        'wait_for_update': 500,
        'region': ['RO'],
        'ad_storage': 'denied',
        'analytics_storage': 'denied',
        'ad_user_data': 'denied',
        'ad_personalization': 'denied'
      });
      gtag('js', new Date());
      gtag('config', 'G-7Q2536ZKL2');
    </script>


  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title th:text="${lesson.title}">Lesson</title>
  <link rel="stylesheet" th:href="@{/css/styles.css}">
  <style>
        body {
            background: #ffffff;
        }
    </style>
 </head>
 <body th:with="activeTopic='C-sharp', activeChapter='10.Colectii', activeLesson='1.Lista List_T_'">
  <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
  <div th:replace="~{fragments/nav :: nav}"></div>
  <div class="top-nav">
   <th:block th:each="topic : ${topics}">
    <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}" th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a>
   </th:block>
  </div>
  <div class="layout">
   <div class="mobile-sidebar" id="mobileSidebar">
    <button class="close-btn" onclick="toggleSidebar()">✖</button>
    <ul class="chapter-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-title" onclick="toggleChapter(this)">
        <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
       </div>
       <ul class="lesson-list">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </div>
   <aside class="sidebar">
    <ul class="sidebar-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-toggle" onclick="toggleLessons(this)">
        <span th:text="${chapter.title}">Chapter</span>
       </div>
       <ul class="lesson-list hidden">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </aside>
   <main class="content">
    <div class="document-container">
     <h1 class="main-title">Lista List_T_</h1>
     <p class="paragraph">Deși în limbajul C# există array-uri care stochează seturi de obiecte de același tip, nu întotdeauna este convenabil să lucrăm cu ele. De exemplu, un array stochează un număr fix de obiecte, dar ce facem dacă nu știm dinainte câte obiecte vom avea nevoie. În acest caz, este mult mai convenabil să folosim colecții.</p>
     <p class="paragraph">Un alt avantaj al colecțiilor este că unele dintre ele implementează structuri de date standard, precum stiva, coada, dicționarul, care pot fi utile pentru rezolvarea diferitelor sarcini speciale. Majoritatea claselor de colecții sunt conținute în spațiul de nume System.Collections.Generic.</p>
     <p class="paragraph">Clasa List&lt;T&gt; din spațiul de nume System.Collections.Generic reprezintă o listă simplă de obiecte de același tip. Clasa List este tipizată cu tipul ale cărui obiecte vor fi stocate în listă.</p>
     <p class="paragraph">Putem crea o listă goală:</p>
     <div class="code-inline">
      <pre><code>List&lt;string&gt;&nbsp;people&nbsp;=&nbsp;new&nbsp;List&lt;string&gt;();</code></pre>
     </div>
     <p class="paragraph">În acest caz, obiectul List este tipizat cu tipul string. Asta înseamnă că putem stoca în această listă doar șiruri de caractere.</p>
     <p class="paragraph">Putem inițializa lista cu valori inițiale chiar la momentul creării:</p>
     <div class="code-inline">
      <pre><code>List&lt;string&gt;&nbsp;people&nbsp;=&nbsp;new&nbsp;List&lt;string&gt;()&nbsp;{&nbsp;"Tom",&nbsp;"Bob",&nbsp;"Sam"&nbsp;};</code></pre>
     </div>
     <p class="paragraph">În acest caz, în listă sunt adăugate trei șiruri de caractere.</p>
     <p class="paragraph">De asemenea, putem inițializa lista cu elemente dintr-o altă colecție, de exemplu, dintr-o altă listă:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;people&nbsp;=&nbsp;new&nbsp;List&lt;string&gt;()&nbsp;{&nbsp;"Tom",&nbsp;"Bob",&nbsp;"Sam"&nbsp;};<br>var&nbsp;employees&nbsp;=&nbsp;new&nbsp;List&lt;string&gt;(people);</code></pre>
     </div>
     <p class="paragraph">Putem combina ambele metode:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;people&nbsp;=&nbsp;new&nbsp;List&lt;string&gt;()&nbsp;{&nbsp;"Tom",&nbsp;"Bob",&nbsp;"Sam"&nbsp;};<br>var&nbsp;employees&nbsp;=&nbsp;new&nbsp;List&lt;string&gt;(people)&nbsp;{&nbsp;"Mike"&nbsp;};</code></pre>
     </div>
     <p class="paragraph">În acest caz, lista employees va avea patru elemente ({ "Tom", "Bob", "Sam", "Mike" }) - trei sunt adăugate din lista people și un element este specificat la inițializare.</p>
     <p class="paragraph">Începând cu versiunea C# 12, pentru definirea listelor se pot folosi expresii de colecții, care presupun închiderea elementelor colecției între paranteze drepte:</p>
     <div class="code-inline">
      <pre><code>List&lt;string&gt;&nbsp;people&nbsp;=&nbsp;["Tom",&nbsp;"Bob",&nbsp;"Sam"];<br>List&lt;string&gt;&nbsp;employees&nbsp;=&nbsp;[];//&nbsp;listă&nbsp;goală</code></pre>
     </div>
     <p class="paragraph">În mod similar, putem lucra cu liste de alte tipuri, de exemplu:</p>
     <div class="code-inline">
      <pre><code>List&lt;Person&gt;&nbsp;people&nbsp;=&nbsp;new&nbsp;List&lt;Person&gt;()<br>{<br>&nbsp;&nbsp;&nbsp;new&nbsp;Person("Tom"),<br>&nbsp;&nbsp;&nbsp;new&nbsp;Person("Bob"),<br>&nbsp;&nbsp;&nbsp;new&nbsp;Person("Sam")<br>};<br><br>class&nbsp;Person<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;}<br>&nbsp;&nbsp;&nbsp;public&nbsp;Person(string&nbsp;name)&nbsp;=&gt;&nbsp;Name&nbsp;=&nbsp;name;<br>}</code></pre>
     </div>
     <h2 class="subtitle">Stabilirea capacității inițiale a listei</h2>
     <p class="paragraph">Un alt constructor al clasei List primește ca parametru capacitatea inițială a listei:</p>
     <div class="code-inline">
      <pre><code>List&lt;string&gt;&nbsp;people&nbsp;=&nbsp;new&nbsp;List&lt;string&gt;(16);</code></pre>
     </div>
     <p class="paragraph">Stabilirea capacității inițiale a listei permite creșterea performanței și reducerea costurilor de alocare a memoriei la adăugarea de elemente. Deoarece adăugarea dinamică în listă poate duce la alocări suplimentare de memorie, ceea ce reduce performanța.</p>
     <p class="paragraph">Dacă știm că lista nu va depăși o anumită dimensiune, putem transmite această dimensiune ca și capacitate a listei pentru a evita alocările suplimentare de memorie.</p>
     <p class="paragraph">De asemenea, capacitatea inițială poate fi stabilită utilizând proprietatea Capacity, care este disponibilă în clasa List.</p>
     <h2 class="subtitle">Accesarea elementelor listei</h2>
     <p class="paragraph">La fel ca array-urile, listele suportă indecși, prin care se poate accesa anumite elemente:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;people&nbsp;=&nbsp;new&nbsp;List&lt;string&gt;()&nbsp;{&nbsp;"Tom",&nbsp;"Bob",&nbsp;"Sam"&nbsp;};<br><br>string&nbsp;firstPerson&nbsp;=&nbsp;people[0];&nbsp;//&nbsp;obținem&nbsp;primul&nbsp;element<br>Console.WriteLine(firstPerson);&nbsp;//&nbsp;Tom<br>people[0]&nbsp;=&nbsp;"Mike";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;modificăm&nbsp;primul&nbsp;element<br>Console.WriteLine(people[0]);&nbsp;//&nbsp;Mike</code></pre>
     </div>
     <h2 class="subtitle">Lungimea listei</h2>
     <p class="paragraph">Cu ajutorul proprietății Count putem obține lungimea listei:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;people&nbsp;=&nbsp;new&nbsp;List&lt;string&gt;()&nbsp;{&nbsp;"Tom",&nbsp;"Bob",&nbsp;"Sam"&nbsp;};<br>Console.WriteLine(people.Count);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;3</code></pre>
     </div>
     <h2 class="subtitle">Parcurgerea listei</h2>
     <p class="paragraph">C# permite parcurgerea listei folosind ciclul standard foreach:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;people&nbsp;=&nbsp;new&nbsp;List&lt;string&gt;()&nbsp;{&nbsp;"Tom",&nbsp;"Bob",&nbsp;"Sam"&nbsp;};<br><br>foreach&nbsp;(var&nbsp;person&nbsp;in&nbsp;people)<br>{<br>&nbsp;&nbsp;&nbsp;Console.WriteLine(person);<br>}<br>//&nbsp;Rezultatul&nbsp;programului:<br>//&nbsp;Tom<br>//&nbsp;Bob<br>//&nbsp;Sam</code></pre>
     </div>
     <p class="paragraph">De asemenea, se pot folosi alte tipuri de cicluri și în combinație cu indecșii se pot parcurge listele:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;people&nbsp;=&nbsp;new&nbsp;List&lt;string&gt;()&nbsp;{&nbsp;"Tom",&nbsp;"Bob",&nbsp;"Sam"&nbsp;};<br><br>for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;people.Count;&nbsp;i++)<br>{<br>&nbsp;&nbsp;&nbsp;Console.WriteLine(people[i]);<br>}</code></pre>
     </div>
     <h2 class="subtitle">Metodele listei</h2>
     <p class="paragraph">Dintre metodele sale, putem menționa următoarele:</p>
     <ul class="enumeration">
      <li>void Add(T item): adăugarea unui nou element în listă</li>
      <li>void AddRange(IEnumerable&lt;T&gt; collection): adăugarea unei colecții sau array în listă</li>
      <li>int BinarySearch(T item): căutare binară a unui element în listă. Dacă elementul este găsit, metoda returnează indexul acestuia în colecție. Lista trebuie să fie sortată</li>
      <li>void CopyTo(T[] array): copiază lista în array</li>
      <li>void CopyTo(int index, T[] array, int arrayIndex, int count): copiază din listăîncepând de la index-ul index elementele al căror număr este egal cu count și le inserează în array începând de la arrayIndex</li>
      <li>bool Contains(T item): returnează true dacă elementul item există în listă</li>
      <li>void Clear(): șterge toate elementele din listă</li>
      <li>bool Exists(Predicate&lt;T&gt; match): returnează true dacă în listă există un element care corespunde delegatului match</li>
      <li>T? Find(Predicate&lt;T&gt; match): returnează primul element care corespunde delegatului match. Dacă elementul nu este găsit, returnează null</li>
      <li>T? FindLast(Predicate&lt;T&gt; match): returnează ultimul element care corespunde delegatului match. Dacă elementul nu este găsit, returnează null</li>
      <li>List&lt;T&gt; FindAll(Predicate&lt;T&gt; match): returnează o listă de elemente care corespund delegatului match</li>
      <li>int IndexOf(T item): returnează indexul primei apariții a elementului în listă</li>
      <li>int LastIndexOf(T item): returnează indexul ultimei apariții a elementului în listă</li>
      <li>List&lt;T&gt; GetRange(int index, int count): returnează o listă de elemente al căror număr este egal cu count, începând de la indexul index</li>
      <li>void Insert(int index, T item): inserează elementul item în listă la indexul index. Dacă nu există un astfel de index în listă, se generează o excepție</li>
      <li>void InsertRange(int index, collection): inserează colecția de elemente collection în lista curentă începând de la indexul index. Dacă nu există un astfel de index în listă, se generează o excepție</li>
      <li>bool Remove(T item): șterge elementul item din listă și returnează true dacă ștergerea a fost efectuată cu succes. Dacă în listă există mai multe elemente identice, se șterge doar primul dintre ele</li>
      <li>void RemoveAt(int index): șterge elementul de la indexul specificat index. Dacă nu există un astfel de index în listă, se generează o excepție</li>
      <li>void RemoveRange(int index, int count): parametrul index specifică indexul de la care trebuie șterse elementele, iar parametrul count specifică numărul de elemente care trebuie șterse</li>
      <li>int RemoveAll((Predicate&lt;T&gt; match)): șterge toate elementele care corespund delegatului match. Returnează numărul de elemente șterse</li>
      <li>void Reverse(): inversează ordinea elementelor</li>
      <li>void Reverse(int index, int count): inversează ordinea pentru un număr de elemente egal cu count, începând de la indexul index</li>
      <li>void Sort(): sortează lista</li>
      <li>void Sort(IComparer&lt;T&gt;? comparer): sortează lista folosind obiectul comparer, care este transmis ca parametru</li>
     </ul>
     <h2 class="subtitle">Adăugarea în listă</h2>
     <div class="code-inline">
      <pre><code>List&lt;string&gt;&nbsp;people&nbsp;=&nbsp;new&nbsp;List&lt;string&gt;()&nbsp;{&nbsp;"Tom"&nbsp;};<br><br>people.Add("Bob");&nbsp;//&nbsp;adăugarea&nbsp;unui&nbsp;element<br>//&nbsp;people&nbsp;=&nbsp;{&nbsp;"Tom",&nbsp;"Bob"&nbsp;};<br><br>people.AddRange(new[]&nbsp;{&nbsp;"Sam",&nbsp;"Alice"&nbsp;});&nbsp;&nbsp;&nbsp;//&nbsp;adăugăm&nbsp;un&nbsp;array<br>//&nbsp;people&nbsp;=&nbsp;{&nbsp;"Tom",&nbsp;"Bob",&nbsp;"Sam",&nbsp;"Alice"&nbsp;};<br>//&nbsp;am&nbsp;putea&nbsp;adăuga&nbsp;și&nbsp;o&nbsp;altă&nbsp;listă<br>//&nbsp;people.AddRange(new&nbsp;List&lt;string&gt;(){&nbsp;"Sam",&nbsp;"Alice"&nbsp;});<br><br>people.Insert(0,&nbsp;"Eugene");&nbsp;//&nbsp;inserăm&nbsp;pe&nbsp;prima&nbsp;poziție<br>//&nbsp;people&nbsp;=&nbsp;{&nbsp;"Eugene",&nbsp;"Tom",&nbsp;"Bob",&nbsp;"Sam",&nbsp;"Alice"&nbsp;};<br><br>people.InsertRange(1,&nbsp;new&nbsp;string[]&nbsp;{"Mike",&nbsp;"Kate"});&nbsp;//&nbsp;inserăm&nbsp;un&nbsp;array&nbsp;de&nbsp;la&nbsp;indexul&nbsp;1<br>//&nbsp;people&nbsp;=&nbsp;{&nbsp;"Eugene",&nbsp;"Mike",&nbsp;"Kate",&nbsp;"Tom",&nbsp;"Bob",&nbsp;"Sam",&nbsp;"Alice"&nbsp;};<br><br>//&nbsp;am&nbsp;putea&nbsp;adăuga&nbsp;și&nbsp;o&nbsp;altă&nbsp;listă<br>//&nbsp;people.InsertRange(1,&nbsp;new&nbsp;List&lt;string&gt;(){&nbsp;"Mike",&nbsp;"Kate"&nbsp;});</code></pre>
     </div>
     <h2 class="subtitle">Ștergerea din listă</h2>
     <div class="code-inline">
      <pre><code>var&nbsp;people&nbsp;=&nbsp;new&nbsp;List&lt;string&gt;()&nbsp;{&nbsp;"Eugene",&nbsp;"Mike",&nbsp;"Kate",&nbsp;"Tom",&nbsp;"Bob",&nbsp;"Sam",&nbsp;"Tom",&nbsp;"Alice"&nbsp;};<br><br>people.RemoveAt(1);&nbsp;//&nbsp;ștergem&nbsp;al&nbsp;doilea&nbsp;element<br>//&nbsp;people&nbsp;=&nbsp;{&nbsp;"Eugene",&nbsp;"Kate",&nbsp;"Tom",&nbsp;"Bob",&nbsp;"Sam",&nbsp;"Tom",&nbsp;"Alice"&nbsp;};<br><br>people.Remove("Tom");&nbsp;//&nbsp;ștergem&nbsp;elementul&nbsp;"Tom"<br>//&nbsp;people&nbsp;=&nbsp;{&nbsp;"Eugene",&nbsp;"Kate",&nbsp;"Bob",&nbsp;"Sam",&nbsp;"Tom",&nbsp;"Alice"&nbsp;};<br><br>//&nbsp;ștergem&nbsp;din&nbsp;listă&nbsp;toate&nbsp;elementele&nbsp;a&nbsp;căror&nbsp;lungime&nbsp;este&nbsp;de&nbsp;3&nbsp;caractere<br>people.RemoveAll(person&nbsp;=&gt;&nbsp;person.Length&nbsp;==&nbsp;3);<br>//&nbsp;people&nbsp;=&nbsp;{&nbsp;"Eugene",&nbsp;"Kate",&nbsp;"Alice"&nbsp;};<br><br>//&nbsp;ștergem&nbsp;din&nbsp;listă&nbsp;2&nbsp;elemente&nbsp;începând&nbsp;de&nbsp;la&nbsp;indexul&nbsp;1<br>people.RemoveRange(1,&nbsp;2);<br>//&nbsp;people&nbsp;=&nbsp;{&nbsp;"Eugene"&nbsp;};<br><br>//&nbsp;ștergem&nbsp;complet&nbsp;lista<br>people.Clear();<br>//&nbsp;people&nbsp;=&nbsp;{&nbsp;&nbsp;};</code></pre>
     </div>
     <h2 class="subtitle">Căutarea și verificarea elementelor</h2>
     <div class="code-inline">
      <pre><code>var&nbsp;people&nbsp;=&nbsp;new&nbsp;List&lt;string&gt;()&nbsp;{&nbsp;"Eugene",&nbsp;"Mike",&nbsp;"Kate",&nbsp;"Tom",&nbsp;"Bob",&nbsp;"Sam"&nbsp;};<br><br>var&nbsp;containsBob&nbsp;=&nbsp;people.Contains("Bob");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;true<br>var&nbsp;containsBill&nbsp;=&nbsp;people.Contains("Bill");&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;false<br><br>//&nbsp;verificăm&nbsp;dacă&nbsp;în&nbsp;listă&nbsp;există&nbsp;șiruri&nbsp;de&nbsp;caractere&nbsp;cu&nbsp;lungimea&nbsp;de&nbsp;3&nbsp;caractere<br>var&nbsp;existsLength3&nbsp;=&nbsp;people.Exists(p&nbsp;=&gt;&nbsp;p.Length&nbsp;==&nbsp;3);&nbsp;&nbsp;//&nbsp;true<br><br>//&nbsp;verificăm&nbsp;dacă&nbsp;în&nbsp;listă&nbsp;există&nbsp;șiruri&nbsp;de&nbsp;caractere&nbsp;cu&nbsp;lungimea&nbsp;de&nbsp;7&nbsp;caractere<br>var&nbsp;existsLength7&nbsp;=&nbsp;people.Exists(p&nbsp;=&gt;&nbsp;p.Length&nbsp;==&nbsp;7);&nbsp;&nbsp;//&nbsp;false<br><br>//&nbsp;obținem&nbsp;primul&nbsp;element&nbsp;cu&nbsp;lungimea&nbsp;de&nbsp;3&nbsp;caractere<br>var&nbsp;firstWithLength3&nbsp;=&nbsp;people.Find(p&nbsp;=&gt;&nbsp;p.Length&nbsp;==&nbsp;3);&nbsp;//&nbsp;Tom<br><br>//&nbsp;obținem&nbsp;ultimul&nbsp;element&nbsp;cu&nbsp;lungimea&nbsp;de&nbsp;3&nbsp;caractere<br>var&nbsp;lastWithLength3&nbsp;=&nbsp;people.FindLast(p&nbsp;=&gt;&nbsp;p.Length&nbsp;==&nbsp;3);&nbsp;&nbsp;//&nbsp;Sam<br><br>//&nbsp;obținem&nbsp;toate&nbsp;elementele&nbsp;cu&nbsp;lungimea&nbsp;de&nbsp;3&nbsp;caractere&nbsp;sub&nbsp;formă&nbsp;de&nbsp;listă<br>List&lt;string&gt;&nbsp;peopleWithLength3&nbsp;=&nbsp;people.FindAll(p&nbsp;=&gt;&nbsp;p.Length&nbsp;==&nbsp;3);<br>//&nbsp;peopleWithLength3&nbsp;{&nbsp;"Tom",&nbsp;"Bob",&nbsp;"Sam"}</code></pre>
     </div>
     <h2 class="subtitle">Obținerea unui interval și copierea într-un array</h2>
     <div class="code-inline">
      <pre><code>List&lt;string&gt;&nbsp;people&nbsp;=&nbsp;new&nbsp;List&lt;string&gt;()&nbsp;{"Eugene",&nbsp;"Tom",&nbsp;"Mike",&nbsp;"Sam",&nbsp;"Bob"&nbsp;};<br><br>//&nbsp;obținem&nbsp;intervalul&nbsp;de&nbsp;la&nbsp;al&nbsp;doilea&nbsp;la&nbsp;al&nbsp;patrulea&nbsp;element<br>var&nbsp;range&nbsp;=&nbsp;people.GetRange(1,&nbsp;3);<br>//&nbsp;range&nbsp;=&nbsp;{&nbsp;"Tom",&nbsp;"Mike",&nbsp;"Sam"&nbsp;};<br><br>//&nbsp;copiem&nbsp;în&nbsp;array&nbsp;primele&nbsp;trei&nbsp;elemente<br>string[]&nbsp;partOfPeople&nbsp;=&nbsp;new&nbsp;string[3];<br>people.CopyTo(0,&nbsp;partOfPeople,&nbsp;0,&nbsp;3);<br>//&nbsp;partOfPeople&nbsp;=&nbsp;{&nbsp;"Eugene",&nbsp;"Tom",&nbsp;"Mike"&nbsp;};</code></pre>
     </div>
     <h2 class="subtitle">Inversarea ordinii elementelor</h2>
     <div class="code-inline">
      <pre><code>var&nbsp;people&nbsp;=&nbsp;new&nbsp;List&lt;string&gt;()&nbsp;{&nbsp;"Eugene",&nbsp;"Tom",&nbsp;"Mike",&nbsp;"Sam",&nbsp;"Bob"&nbsp;};<br><br>//&nbsp;inversăm&nbsp;întreaga&nbsp;listă<br>people.Reverse();<br>//&nbsp;people&nbsp;=&nbsp;{&nbsp;"Bob",&nbsp;"Sam",&nbsp;"Mike",&nbsp;"Tom",&nbsp;"Eugene"&nbsp;};<br><br>var&nbsp;people2&nbsp;=&nbsp;new&nbsp;List&lt;string&gt;()&nbsp;{&nbsp;"Eugene",&nbsp;"Tom",&nbsp;"Mike",&nbsp;"Sam",&nbsp;"Bob"&nbsp;};<br>//&nbsp;inversăm&nbsp;doar&nbsp;3&nbsp;elemente&nbsp;începând&nbsp;de&nbsp;la&nbsp;indexul&nbsp;1<br>people2.Reverse(1,&nbsp;3);<br>//&nbsp;people2&nbsp;=&nbsp;{&nbsp;"Eugene",&nbsp;"Sam",&nbsp;"Mike",&nbsp;"Tom",&nbsp;"Bob"&nbsp;};</code></pre>
     </div>
    </div>
   </main>
   <aside class="ad-section">
    <div class="ad-box">
     <p>Google Ad Here</p>
    </div>
    <div class="ad-box">
     <p>Promo: SQL Beginner Guide</p>
    </div>
   </aside>
  </div>
  <div class="lesson-navigation">
   <th:block th:if="${previousLesson != null}">
    <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția anterioară</a>
   </th:block> <th:block th:if="${nextLesson != null}">
    <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția următoare →</a>
   </th:block>
  </div>
  <div th:replace="~{fragments/footer :: footer}"></div>
  <script th:src="@{/js/script.js}" defer></script>
 </body>
</html>
