<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">
 <head>
    <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      window.gtag = function () { dataLayer.push(arguments); };
      gtag('consent', 'default', {
        'wait_for_update': 500,
        'region': ['RO'],
        'ad_storage': 'denied',
        'analytics_storage': 'denied',
        'ad_user_data': 'denied',
        'ad_personalization': 'denied'
      });
      gtag('js', new Date());
      gtag('config', 'G-7Q2536ZKL2');
    </script>


  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title th:text="${lesson.title}">Lesson</title>
  <link rel="stylesheet" th:href="@{/css/styles.css}">
  <style>
        body {
            background: #ffffff;
        }
    </style>
 </head>
 <body th:with="activeTopic='C-sharp', activeChapter='4.Programare orientata pe obiecte', activeLesson='6.Clase abstracte si membrii claselor'">
  <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
  <div th:replace="~{fragments/nav :: nav}"></div>
  <div class="top-nav">
   <th:block th:each="topic : ${topics}">
    <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}" th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a>
   </th:block>
  </div>
  <div class="layout">
   <div class="mobile-sidebar" id="mobileSidebar">
    <button class="close-btn" onclick="toggleSidebar()">✖</button>
    <ul class="chapter-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-title" onclick="toggleChapter(this)">
        <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
       </div>
       <ul class="lesson-list">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lessons/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </div>
   <aside class="sidebar">
    <ul class="sidebar-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-toggle" onclick="toggleLessons(this)">
        <span th:text="${chapter.title}">Chapter</span>
       </div>
       <ul class="lesson-list hidden">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lessons/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </aside>
   <main class="content">
    <div class="document-container">
     <h1 class="main-title">Clase abstracte și membrii claselor</h1>
     <h2 class="subtitle">Clase abstracte</h2>
     <p class="paragraph">În C#, pe lângă clasele obișnuite, există și clase abstracte. Ce rol au acestea? Clasele obișnuite reprezintă de obicei un plan pentru anumite tipuri de obiecte sau entități. De exemplu, putem defini clasa Car pentru a reprezenta mașinile sau clasa Person pentru a reprezenta persoanele, incluzând în aceste clase proprietăți, câmpuri și metode corespunzătoare care descriu aceste obiecte.</p>
     <p class="paragraph">Cu toate acestea, unele entități pe care dorim să le exprimăm prin intermediul limbajului de programare nu au o manifestare concretă. De exemplu, în realitate nu există o formă geometrică ca atare.</p>
     <p class="paragraph">Există cercuri, dreptunghiuri, pătrate, dar nu există pur și simplu o "formă". Totuși, atât cercul cât și dreptunghiul au ceva în comun și sunt forme. Pentru a descrie astfel de entități care nu au o manifestare concretă sunt destinate clasele abstracte.</p>
     <p class="paragraph">O clasă abstractă este similară cu o clasă obișnuită. Aceasta poate avea variabile, metode, constructori, proprietăți. Singura diferență este că la definirea claselor abstracte se folosește cuvântul cheie abstract. De exemplu, să definim o clasă abstractă care reprezintă un vehicul:</p>
     <div class="code-inline">
      <pre><code>abstract&nbsp;class&nbsp;Transport<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Move()<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("Vehiculul&nbsp;se&nbsp;deplasează");<br>&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">Un vehicul reprezintă o abstracție care nu are o manifestare concretă. Adică, există mașini și camioane, avioane, nave maritime, unii se plimbă chiar și pe nave spațiale, dar ca un vehicul concret nu există.</p>
     <p class="paragraph">Cu toate acestea, toate vehiculele au ceva comun - ele se pot deplasa. Pentru aceasta, în clasă este definită metoda Move, care simulează deplasarea.</p>
     <p class="paragraph">Dar principalul aspect care diferențiază clasele abstracte de cele obișnuite este că nu putem folosi constructorul unei clase abstracte pentru a crea o instanță a clasei. De exemplu, nu putem face asta în felul următor:</p>
     <div class="code-inline">
      <pre><code>Transport&nbsp;tesla&nbsp;=&nbsp;new&nbsp;Transport();&nbsp;//&nbsp;Eroare!&nbsp;Nu&nbsp;se&nbsp;poate&nbsp;instantia&nbsp;o&nbsp;clasa&nbsp;abstracta</code></pre>
     </div>
     <p class="paragraph">Clasele abstracte sunt folositoare pentru a descrie funcționalități comune care pot fi moștenite și utilizate de clasele derivate:</p>
     <div class="code-inline">
      <pre><code>Transport&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br>Transport&nbsp;ship&nbsp;=&nbsp;new&nbsp;Ship();<br>Transport&nbsp;aircraft&nbsp;=&nbsp;new&nbsp;Aircraft();<br><br>car.Move();<br>ship.Move();<br>aircraft.Move();<br><br>abstract&nbsp;class&nbsp;Transport<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Move()<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("Vehiculul&nbsp;se&nbsp;deplasează");<br>&nbsp;&nbsp;&nbsp;}<br>}<br><br>//&nbsp;clasă&nbsp;de&nbsp;tip&nbsp;navă<br>class&nbsp;Ship&nbsp;:&nbsp;Transport&nbsp;{&nbsp;}<br><br>//&nbsp;clasă&nbsp;de&nbsp;tip&nbsp;avion<br>class&nbsp;Aircraft&nbsp;:&nbsp;Transport&nbsp;{&nbsp;}<br><br>//&nbsp;clasă&nbsp;de&nbsp;tip&nbsp;automobil<br>class&nbsp;Car&nbsp;:&nbsp;Transport&nbsp;{&nbsp;}</code></pre>
     </div>
     <p class="paragraph">În acest caz, de la clasa Transport sunt moștenite trei clase care reprezintă diferite tipuri de vehicule. Cu toate acestea, ele au o trăsătură comună - ele se pot deplasa folosind metoda Move().</p>
     <p class="paragraph">Deși nu putem folosi constructorul unei clase abstracte pentru a crea instanțe ale acesteia, clasa abstractă poate defini constructori:</p>
     <div class="code-inline">
      <pre><code>Transport&nbsp;car&nbsp;=&nbsp;new&nbsp;Car("automobil");<br>Transport&nbsp;ship&nbsp;=&nbsp;new&nbsp;Ship("navă");<br>Transport&nbsp;aircraft&nbsp;=&nbsp;new&nbsp;Aircraft("avion");<br><br>car.Move();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;automobilul&nbsp;se&nbsp;deplasează<br>ship.Move();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;nava&nbsp;se&nbsp;deplasează<br>aircraft.Move();&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;avionul&nbsp;se&nbsp;deplasează<br><br>abstract&nbsp;class&nbsp;Transport<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;private&nbsp;set;&nbsp;}<br>&nbsp;&nbsp;&nbsp;//&nbsp;constructorul&nbsp;clasei&nbsp;abstracte&nbsp;Transport<br>&nbsp;&nbsp;&nbsp;public&nbsp;Transport(string&nbsp;name)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;=&nbsp;name;<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Move()&nbsp;=&gt;&nbsp;Console.WriteLine($"{Name}&nbsp;se&nbsp;deplasează");<br>}<br><br>//&nbsp;clasă&nbsp;de&nbsp;tip&nbsp;navă<br>class&nbsp;Ship&nbsp;:&nbsp;Transport&nbsp;<br>{<br>&nbsp;&nbsp;&nbsp;//&nbsp;apelăm&nbsp;constructorul&nbsp;clasei&nbsp;de&nbsp;bază<br>&nbsp;&nbsp;&nbsp;public&nbsp;Ship(string&nbsp;name)&nbsp;:&nbsp;base(name)&nbsp;{&nbsp;}<br>}<br><br>//&nbsp;clasă&nbsp;de&nbsp;tip&nbsp;avion<br>class&nbsp;Aircraft&nbsp;:&nbsp;Transport<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;Aircraft(string&nbsp;name)&nbsp;:&nbsp;base(name)&nbsp;{&nbsp;}<br>}<br><br>//&nbsp;clasă&nbsp;de&nbsp;tip&nbsp;automobil<br>class&nbsp;Car&nbsp;:&nbsp;Transport<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;Car(string&nbsp;name)&nbsp;:&nbsp;base(name)&nbsp;{&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">În acest caz, în clasa abstractă Transport este definit un constructor care, printr-un parametru, stabilește valoarea proprietății Name, care păstrează numele vehiculului. Astfel, clasele derivate trebuie să apeleze acest constructor în constructorii proprii.</p>
     <h2 class="subtitle">Membri abstracti ai claselor</h2>
     <p class="paragraph">O clasă abstractă poate avea membri abstracti, care sunt definiți cu cuvântul cheie abstract și nu au implementare. Acești membri pot fi:</p>
     <ul class="enumeration">
      <li>Metode</li>
      <li>Proprietăți</li>
      <li>Indexatori</li>
      <li>Evenimente</li>
     </ul>
     <p class="paragraph">Membrii abstracti ai claselor nu pot avea modificatorul private. O clasă derivată trebuie să implementeze toți membrii abstracti ai clasei de bază. Când un membru abstract este suprascris într-o clasă derivată, acesta trebuie declarat cu modificatorul override.</p>
     <p class="paragraph">Dacă o clasă conține cel puțin un membru abstract, atunci acea clasă trebuie să fie declarată ca fiind abstractă.</p>
     <h2 class="subtitle">Metode abstracte</h2>
     <p class="paragraph">De exemplu, în cazul vehiculelor, metoda Move ar putea descrie modul în care un vehicul se deplasează. Totuși, diferite tipuri de vehicule se deplasează în moduri diferite - unele pe pământ, altele prin aer, altele pe apă. În acest caz, am putea face metoda Move abstractă, iar implementarea ei să fie responsabilitatea claselor derivate:</p>
     <div class="code-inline">
      <pre><code>abstract&nbsp;class&nbsp;Transport<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;void&nbsp;Move();<br>}<br><br>class&nbsp;Car&nbsp;:&nbsp;Transport<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;override&nbsp;void&nbsp;Move()<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("Mașina&nbsp;merge");<br>&nbsp;&nbsp;&nbsp;}<br>}<br><br>class&nbsp;Ship&nbsp;:&nbsp;Transport<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;override&nbsp;void&nbsp;Move()<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("Nava&nbsp;navighează");<br>&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">Aplicarea claselor:</p>
     <div class="code-inline">
      <pre><code>Transport&nbsp;car&nbsp;=&nbsp;new&nbsp;Car();<br>Transport&nbsp;ship&nbsp;=&nbsp;new&nbsp;Ship();<br>Transport&nbsp;aircraft&nbsp;=&nbsp;new&nbsp;Aircraft();<br><br>car.Move();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;mașina&nbsp;merge<br>ship.Move();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;corabia&nbsp;navighează<br>aircraft.Move();&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;avionul&nbsp;zboară</code></pre>
     </div>
     <h2 class="subtitle">Proprietăți abstracte</h2>
     <p class="paragraph">Este important să subliniem utilizarea proprietăților abstracte. Definirea acestora este similară cu definirea proprietăților automate. De exemplu:</p>
     <div class="code-inline">
      <pre><code>abstract&nbsp;class&nbsp;Transport<br>{<br>&nbsp;&nbsp;&nbsp;//&nbsp;proprietate&nbsp;abstractă&nbsp;pentru&nbsp;stocarea&nbsp;vitezei<br>&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;int&nbsp;Speed&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}<br>}<br>//&nbsp;clasă&nbsp;de&nbsp;tip&nbsp;navă<br>class&nbsp;Ship:&nbsp;Transport<br>{<br>&nbsp;&nbsp;&nbsp;int&nbsp;speed;<br>&nbsp;&nbsp;&nbsp;public&nbsp;override&nbsp;int&nbsp;Speed<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get&nbsp;=&gt;&nbsp;speed;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;=&gt;&nbsp;speed&nbsp;=&nbsp;value;<br>&nbsp;&nbsp;&nbsp;}<br>}<br><br>class&nbsp;Aircraft&nbsp;:&nbsp;Transport<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;override&nbsp;int&nbsp;Speed&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">În clasa Transport este definită o proprietate abstractă Speed, care trebuie să stocheze viteza vehiculului. Aceasta seamănă cu o proprietate auto, dar nu este o proprietate auto. Deoarece această proprietate nu trebuie să aibă o implementare, conține doar blocuri goale pentru get și set.</p>
     <p class="paragraph">În clasele derivate, putem suprascrie această proprietate, transformând-o într-o proprietate completă (cum este în clasa Ship), sau o putem menține ca o proprietate auto (cum este în clasa Aircraft).</p>
     <h2 class="subtitle">Renunțarea la implementarea membrilor abstracti</h2>
     <p class="paragraph">Clasa derivată este obligată să implementeze toți membrii abstracti ai clasei de bază. Totuși, putem renunța la implementare, dar în acest caz clasa derivată trebuie să fie, de asemenea, definită ca fiind abstractă:</p>
     <div class="code-inline">
      <pre><code>ransport&nbsp;tesla&nbsp;=&nbsp;new&nbsp;Auto();<br>tesla.Move();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;mașina&nbsp;se&nbsp;deplasează<br>abstract&nbsp;class&nbsp;Transport<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;void&nbsp;Move();<br>}<br>//&nbsp;clasă&nbsp;de&nbsp;tip&nbsp;automobil<br>abstract&nbsp;class&nbsp;Car&nbsp;:&nbsp;Transport{}<br><br>class&nbsp;Auto:&nbsp;Car<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;override&nbsp;void&nbsp;Move()<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("mașina&nbsp;se&nbsp;deplasează");<br>&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">În acest caz, clasa Car nu implementează metoda abstractă Move a clasei de bază Transport și, prin urmare, este definită ca fiind abstractă. Totuși, orice clasă non-abstractă derivată din Car trebuie să implementeze toți membrii abstracti moșteniți.</p>
     <h2 class="subtitle">Exemplu de clasă abstractă</h2>
     <p class="paragraph">Un exemplu clasic este sistemul de forme geometrice. În realitate, nu există o formă geometrică ca atare. Există cercuri, dreptunghiuri, pătrate, dar nu există pur și simplu o "formă". Totuși, atât cercul cât și dreptunghiul au ceva în comun și sunt forme:</p>
     <div class="code-inline">
      <pre><code>//&nbsp;clasă&nbsp;abstractă&nbsp;pentru&nbsp;forme<br>abstract&nbsp;class&nbsp;Shape<br>{<br>&nbsp;&nbsp;&nbsp;//&nbsp;metodă&nbsp;abstractă&nbsp;pentru&nbsp;obținerea&nbsp;perimetrului<br>&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;double&nbsp;GetPerimeter();<br>&nbsp;&nbsp;&nbsp;//&nbsp;metodă&nbsp;abstractă&nbsp;pentru&nbsp;obținerea&nbsp;ariei<br>&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;double&nbsp;GetArea();<br>}<br>//&nbsp;clasă&nbsp;derivată&nbsp;pentru&nbsp;dreptunghiuri<br>class&nbsp;Rectangle&nbsp;:&nbsp;Shape<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;float&nbsp;Width&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}<br>&nbsp;&nbsp;&nbsp;public&nbsp;float&nbsp;Height&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;//&nbsp;suprascrierea&nbsp;obținerii&nbsp;perimetrului<br>&nbsp;&nbsp;&nbsp;public&nbsp;override&nbsp;double&nbsp;GetPerimeter()&nbsp;=&gt;&nbsp;Width&nbsp;*&nbsp;2&nbsp;+&nbsp;Height&nbsp;*&nbsp;2;<br>&nbsp;&nbsp;&nbsp;//&nbsp;suprascrierea&nbsp;obținerii&nbsp;ariei<br>&nbsp;&nbsp;&nbsp;public&nbsp;override&nbsp;double&nbsp;GetArea()&nbsp;=&gt;&nbsp;Width&nbsp;*&nbsp;Height;<br>}<br>//&nbsp;clasă&nbsp;derivată&nbsp;pentru&nbsp;cercuri<br>class&nbsp;Circle&nbsp;:&nbsp;Shape<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;double&nbsp;Radius&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;//&nbsp;suprascrierea&nbsp;obținerii&nbsp;perimetrului<br>&nbsp;&nbsp;&nbsp;public&nbsp;override&nbsp;double&nbsp;GetPerimeter()&nbsp;=&gt;&nbsp;Radius&nbsp;*&nbsp;2&nbsp;*&nbsp;3.14;<br>&nbsp;&nbsp;&nbsp;//&nbsp;suprascrierea&nbsp;obținerii&nbsp;ariei<br>&nbsp;&nbsp;&nbsp;public&nbsp;override&nbsp;double&nbsp;GetArea()&nbsp;=&gt;&nbsp;Radius&nbsp;*&nbsp;Radius&nbsp;*&nbsp;3.14;<br>}</code></pre>
     </div>
     <p class="paragraph">Utilizarea claselor:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;rectangle&nbsp;=&nbsp;new&nbsp;Rectangle&nbsp;{&nbsp;Width&nbsp;=&nbsp;20,&nbsp;Height&nbsp;=&nbsp;20&nbsp;};<br>var&nbsp;circle&nbsp;=&nbsp;new&nbsp;Circle&nbsp;{&nbsp;Radius&nbsp;=&nbsp;200&nbsp;};<br>PrintShape(rectangle);&nbsp;//&nbsp;Perimeter:&nbsp;80&nbsp;&nbsp;&nbsp;Area:&nbsp;400<br>PrintShape(circle);&nbsp;//&nbsp;Perimeter:&nbsp;1256&nbsp;&nbsp;Area:&nbsp;125600<br><br>void&nbsp;PrintShape(Shape&nbsp;shape)<br>{<br>&nbsp;&nbsp;&nbsp;Console.WriteLine($"Perimeter:&nbsp;{shape.GetPerimeter()}&nbsp;&nbsp;Area:&nbsp;{shape.GetArea()}");<br>}</code></pre>
     </div>
    </div>
   </main>
   <aside class="ad-section">
    <div class="ad-box">
     <p>Google Ad Here</p>
    </div>
    <div class="ad-box">
     <p>Promo: SQL Beginner Guide</p>
    </div>
   </aside>
  </div>
  <div class="lesson-navigation">
   <th:block th:if="${previousLesson != null}">
    <a th:href="@{'/lessons/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția anterioară</a>
   </th:block> <th:block th:if="${nextLesson != null}">
    <a th:href="@{'/lessons/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția următoare →</a>
   </th:block>
  </div>
  <div th:replace="~{fragments/footer :: footer}"></div>
  <script th:src="@{/js/script.js}" defer></script>
 </body>
</html>
