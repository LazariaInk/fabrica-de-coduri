<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">
 <head>
    <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      window.gtag = function () { dataLayer.push(arguments); };
      gtag('consent', 'default', {
        'wait_for_update': 500,
        'region': ['RO'],
        'ad_storage': 'denied',
        'analytics_storage': 'denied',
        'ad_user_data': 'denied',
        'ad_personalization': 'denied'
      });
      gtag('js', new Date());
      gtag('config', 'G-7Q2536ZKL2');
    </script>


  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title th:text="${lesson.title}">Lesson</title>
  <link rel="stylesheet" th:href="@{/css/styles.css}">
  <style>
        body {
            background: #ffffff;
        }
    </style>
 </head>
 <body th:with="activeTopic='C-sharp', activeChapter='4.Programare orientata pe obiecte', activeLesson='7.Clasa System'">
  <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
  <div th:replace="~{fragments/nav :: nav}"></div>
  <div class="top-nav">
   <th:block th:each="topic : ${topics}">
    <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}" th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a>
   </th:block>
  </div>
  <div class="layout">
   <div class="mobile-sidebar" id="mobileSidebar">
    <button class="close-btn" onclick="toggleSidebar()">✖</button>
    <ul class="chapter-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-title" onclick="toggleChapter(this)">
        <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
       </div>
       <ul class="lesson-list">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </div>
   <aside class="sidebar">
    <ul class="sidebar-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-toggle" onclick="toggleLessons(this)">
        <span th:text="${chapter.title}">Chapter</span>
       </div>
       <ul class="lesson-list hidden">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </aside>
   <main class="content">
    <div class="document-container">
     <h1 class="main-title">Clasa System - Object și metodele sale</h1>
     <p class="paragraph">Toate clasele din .NET, inclusiv cele pe care le creăm noi înșine, precum și tipurile de bază, cum ar fi System.Int32, derivă implicit din clasa Object. Chiar dacă nu specificăm clasa Object ca bază, implicit clasa Object este în vârful ierarhiei moștenirii. Prin urmare, toate tipurile și clasele pot implementa metodele definite în clasa System.Object. Să analizăm aceste metode.</p>
     <h2 class="subtitle">Metoda ToString</h2>
     <p class="paragraph">Metoda ToString servește pentru obținerea unei reprezentări textuale a obiectului respectiv. Pentru tipurile de bază, va afișa valoarea lor textuală:</p>
     <div class="code-inline">
      <pre><code>int&nbsp;i&nbsp;=&nbsp;5;<br>Console.WriteLine(i.ToString());&nbsp;//&nbsp;va&nbsp;afișa&nbsp;numărul&nbsp;5<br><br>double&nbsp;d&nbsp;=&nbsp;3.5;<br>Console.WriteLine(d.ToString());&nbsp;//&nbsp;va&nbsp;afișa&nbsp;numărul&nbsp;3,5</code></pre>
     </div>
     <p class="paragraph">Pentru clase, această metodă afișează numele complet al clasei cu specificarea spațiului de nume în care este definită. Putem suprascrie această metodă. Să vedem un exemplu:</p>
     <div class="code-inline">
      <pre><code>Person&nbsp;person&nbsp;=&nbsp;new&nbsp;Person&nbsp;{&nbsp;Name&nbsp;=&nbsp;"Tom"&nbsp;};<br>Console.WriteLine(person.ToString());&nbsp;//&nbsp;va&nbsp;afișa&nbsp;numele&nbsp;clasei&nbsp;Person<br><br>Clock&nbsp;clock&nbsp;=&nbsp;new&nbsp;Clock&nbsp;{&nbsp;Hours&nbsp;=&nbsp;15,&nbsp;Minutes&nbsp;=&nbsp;34,&nbsp;Seconds&nbsp;=&nbsp;53&nbsp;};<br>Console.WriteLine(clock.ToString());&nbsp;//&nbsp;va&nbsp;afișa&nbsp;15:34:53<br><br>class&nbsp;Clock<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;Hours&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}<br>&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;Minutes&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}<br>&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;Seconds&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}<br>&nbsp;&nbsp;&nbsp;public&nbsp;override&nbsp;string&nbsp;ToString()<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$"{Hours}:{Minutes}:{Seconds}";<br>&nbsp;&nbsp;&nbsp;}<br>}<br><br>class&nbsp;Person<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}&nbsp;=&nbsp;"";<br>}</code></pre>
     </div>
     <p class="paragraph">Pentru suprascrierea metodei ToString în clasa Clock, care reprezintă ceasuri, se folosește cuvântul cheie override (la fel ca în cazul suprascrierii metodelor virtuale sau abstracte). În acest caz, metoda ToString afișează în șir de caractere valorile proprietăților Hours, Minutes, Seconds.</p>
     <p class="paragraph">Clasa Person nu suprascrie metoda ToString, astfel încât pentru această clasă se aplică implementarea standard a acestei metode, care afișează pur și simplu numele clasei.</p>
     <p class="paragraph">De asemenea, putem utiliza ambele implementări:</p>
     <div class="code-inline">
      <pre><code>Person&nbsp;tom&nbsp;=&nbsp;new&nbsp;Person&nbsp;{&nbsp;Name&nbsp;=&nbsp;"Tom"&nbsp;};<br>Console.WriteLine(tom.ToString());&nbsp;//&nbsp;Tom<br><br>Person&nbsp;undefined&nbsp;=&nbsp;new&nbsp;Person();<br>Console.WriteLine(undefined.ToString());&nbsp;//&nbsp;Person<br><br>class&nbsp;Person<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}&nbsp;=&nbsp;"";<br><br>&nbsp;&nbsp;&nbsp;public&nbsp;override&nbsp;string?&nbsp;ToString()<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(string.IsNullOrEmpty(Name))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;base.ToString();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Name;<br>&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">Deci, dacă proprietatea Name nu are o valoare, ea reprezintă un șir gol, atunci se întoarce implementarea de bază - numele clasei. Este de remarcat că implementarea de bază returnează nu doar un șir de caractere, ci un obiect string?</p>
     <p class="paragraph">- adică poate fi un șir de caractere string sau valoarea null, care indică lipsa unei valori. În realitate, ca tip returnat pentru metodă putem folosi atât string, cât și string.</p>
     <p class="paragraph">Dacă numele obiectului Person este setat, atunci se întoarce valoarea proprietății Name. Pentru verificarea existenței unei valori în șir se utilizează metoda String.IsNullOrEmpty().</p>
     <p class="paragraph">Este de remarcat că diverse tehnologii din platforma .NET utilizează metoda ToString pentru diferite scopuri. În special, metoda Console.WriteLine() afișează implicit reprezentarea textuală a obiectului.</p>
     <p class="paragraph">Prin urmare, dacă trebuie să afișăm reprezentarea textuală a obiectului în consolă, atunci la transmiterea obiectului în metoda Console.WriteLine nu este necesar să utilizăm metoda ToString - aceasta este apelată implicit:</p>
     <div class="code-inline">
      <pre><code>Person&nbsp;person&nbsp;=&nbsp;new&nbsp;Person&nbsp;{&nbsp;Name&nbsp;=&nbsp;"Tom"&nbsp;};<br>Console.WriteLine(person);&nbsp;&nbsp;//&nbsp;Tom<br><br>Clock&nbsp;clock&nbsp;=&nbsp;new&nbsp;Clock&nbsp;{&nbsp;Hours&nbsp;=&nbsp;15,&nbsp;Minutes&nbsp;=&nbsp;34,&nbsp;Seconds&nbsp;=&nbsp;53&nbsp;};<br>Console.WriteLine(clock);&nbsp;//&nbsp;va&nbsp;afișa&nbsp;15:34:53</code></pre>
     </div>
     <h2 class="subtitle">Metoda GetHashCode</h2>
     <p class="paragraph">Metoda GetHashCode permite returnarea unei valori numerice corespunzătoare obiectului respectiv sau codului său hash. Prin intermediul acestei valori, de exemplu, putem compara obiecte. Putem defini diverse algoritme pentru generarea unei astfel de valori sau putem folosi implementarea tipului de bază:</p>
     <div class="code-inline">
      <pre><code>class&nbsp;Person<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}&nbsp;=&nbsp;"";<br><br>&nbsp;&nbsp;&nbsp;public&nbsp;override&nbsp;int&nbsp;GetHashCode()<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Name.GetHashCode();<br>&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">În acest caz, metoda GetHashCode returnează codul hash pentru valoarea proprietății Name. Adică două obiecte Person care au același nume vor returna același cod hash. Totuși, în realitate, algoritmul poate fi foarte variat.</p>
     <h2 class="subtitle">Obținerea tipului obiectului și metoda GetType</h2>
     <p class="paragraph">Metoda GetType permite obținerea tipului obiectului respectiv:</p>
     <div class="code-inline">
      <pre><code>Person&nbsp;person&nbsp;=&nbsp;new&nbsp;Person&nbsp;{&nbsp;Name&nbsp;=&nbsp;"Tom"&nbsp;};<br>Console.WriteLine(person.GetType());&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Person</code></pre>
     </div>
     <p class="paragraph">Această metodă returnează un obiect Type, adică tipul obiectului.</p>
     <p class="paragraph">Prin intermediul cuvântului cheie typeof obținem tipul clasei și îl comparăm cu tipul obiectului. Și dacă acest obiect reprezintă tipul Person, atunci executăm anumite acțiuni.</p>
     <div class="code-inline">
      <pre><code>object&nbsp;person&nbsp;=&nbsp;new&nbsp;Person&nbsp;{&nbsp;Name&nbsp;=&nbsp;"Tom"&nbsp;};<br>if&nbsp;(person.GetType()&nbsp;==&nbsp;typeof(Person))<br>&nbsp;&nbsp;&nbsp;Console.WriteLine("Acesta&nbsp;este&nbsp;cu&nbsp;adevărat&nbsp;clasa&nbsp;Person");</code></pre>
     </div>
     <p class="paragraph">Deoarece clasa Object este tipul de bază pentru toate clasele, putem atribui unei variabile de tip object un obiect de orice tip. Totuși, pentru această variabilă, metoda GetType va returna în continuare tipul obiectului la care face referire variabila. Adică, în acest caz, obiectul de tip Person.</p>
     <p class="paragraph">Este de remarcat că verificarea tipului din exemplul de mai sus poate fi simplificată folosind operatorul is:</p>
     <div class="code-inline">
      <pre><code>object&nbsp;person&nbsp;=&nbsp;new&nbsp;Person&nbsp;{&nbsp;Name&nbsp;=&nbsp;"Tom"&nbsp;};<br>if&nbsp;(person&nbsp;is&nbsp;Person)<br>&nbsp;&nbsp;&nbsp;Console.WriteLine("Acesta&nbsp;este&nbsp;cu&nbsp;adevărat&nbsp;clasa&nbsp;Person");</code></pre>
     </div>
     <p class="paragraph">Spre deosebire de metodele ToString, Equals, GetHashCode, metoda GetType nu se suprascrie.</p>
     <h2 class="subtitle">Metoda Equals</h2>
     <p class="paragraph">Metoda Equals permite compararea a două obiecte pentru egalitate. Ca parametru, primește un obiect pentru comparare sub formă de tip object și returnează true dacă ambele obiecte sunt egale:</p>
     <div class="code-inline">
      <pre><code>public&nbsp;override&nbsp;bool&nbsp;Equals(object?&nbsp;obj)&nbsp;{......}</code></pre>
     </div>
     <p class="paragraph">De exemplu, implementăm această metodă în clasa Person:</p>
     <div class="code-inline">
      <pre><code>class&nbsp;Person<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}&nbsp;=&nbsp;"";<br>&nbsp;&nbsp;&nbsp;public&nbsp;override&nbsp;bool&nbsp;Equals(object?&nbsp;obj)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;dacă&nbsp;parametrul&nbsp;metodei&nbsp;reprezintă&nbsp;tipul&nbsp;Person<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;atunci&nbsp;returnăm&nbsp;true&nbsp;dacă&nbsp;numele&nbsp;coincid<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(obj&nbsp;is&nbsp;Person&nbsp;person)&nbsp;return&nbsp;Name&nbsp;==&nbsp;person.Name;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;//&nbsp;împreună&nbsp;cu&nbsp;metoda&nbsp;Equals&nbsp;ar&nbsp;trebui&nbsp;să&nbsp;implementăm&nbsp;metoda&nbsp;GetHashCode<br>&nbsp;&nbsp;&nbsp;public&nbsp;override&nbsp;int&nbsp;GetHashCode()&nbsp;=&gt;&nbsp;Name.GetHashCode();<br>}</code></pre>
     </div>
     <p class="paragraph">Metoda Equals primește ca parametru un obiect de orice tip, pe care îl convertim ulterior la clasa curentă - clasa Person.</p>
     <p class="paragraph">Dacă obiectul transmis reprezintă tipul Person, atunci returnăm rezultatul comparării numelor a două obiecte Person. Dacă obiectul reprezintă un alt tip, atunci returnăm false.</p>
     <p class="paragraph">În acest caz, pentru exemplu se aplică un algoritm simplu de comparare, dar, dacă este necesar, implementarea metodei poate fi mai complexă, de exemplu, comparând mai multe proprietăți, dacă acestea există.</p>
     <p class="paragraph">Este de remarcat că împreună cu metoda Equals ar trebui să implementăm metoda GetHashCode.</p>
     <p class="paragraph">Aplicarea metodei:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;person1&nbsp;=&nbsp;new&nbsp;Person&nbsp;{&nbsp;Name&nbsp;=&nbsp;"Tom"&nbsp;};<br>var&nbsp;person2&nbsp;=&nbsp;new&nbsp;Person&nbsp;{&nbsp;Name&nbsp;=&nbsp;"Bob"&nbsp;};<br>var&nbsp;person3&nbsp;=&nbsp;new&nbsp;Person&nbsp;{&nbsp;Name&nbsp;=&nbsp;"Tom"&nbsp;};<br><br>bool&nbsp;person1EqualsPerson2&nbsp;=&nbsp;person1.Equals(person2);&nbsp;&nbsp;&nbsp;//&nbsp;false<br>bool&nbsp;person1EqualsPerson3&nbsp;=&nbsp;person1.Equals(person3);&nbsp;&nbsp;&nbsp;//&nbsp;true<br><br>Console.WriteLine(person1EqualsPerson2);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;false<br>Console.WriteLine(person1EqualsPerson3);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;true</code></pre>
     </div>
     <p class="paragraph">Și dacă trebuie să comparăm două obiecte complexe, ca în acest caz, este mai bine să folosim metoda Equals, decât operația standard ==.</p>
    </div>
   </main>
   <aside class="ad-section">
    <div class="ad-box">
     <p>Google Ad Here</p>
    </div>
    <div class="ad-box">
     <p>Promo: SQL Beginner Guide</p>
    </div>
   </aside>
  </div>
  <div class="lesson-navigation">
   <th:block th:if="${previousLesson != null}">
    <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția anterioară</a>
   </th:block> <th:block th:if="${nextLesson != null}">
    <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția următoare →</a>
   </th:block>
  </div>
  <div th:replace="~{fragments/footer :: footer}"></div>
  <script th:src="@{/js/script.js}" defer></script>
 </body>
</html>
