<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">
 <head>
    <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      window.gtag = function () { dataLayer.push(arguments); };
      gtag('consent', 'default', {
        'wait_for_update': 500,
        'region': ['RO'],
        'ad_storage': 'denied',
        'analytics_storage': 'denied',
        'ad_user_data': 'denied',
        'ad_personalization': 'denied'
      });
      gtag('js', new Date());
      gtag('config', 'G-7Q2536ZKL2');
    </script>


  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title th:text="${lesson.title}">Lesson</title>
  <link rel="stylesheet" th:href="@{/css/styles.css}">
  <style>
        body {
            background: #ffffff;
        }
    </style>
 </head>
 <body th:with="activeTopic='C-sharp', activeChapter='8.Functionalitati suplimentare ale OOP in C-sharp', activeLesson='9.Recorduri'">
  <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
  <div th:replace="~{fragments/nav :: nav}"></div>
  <div class="top-nav">
   <th:block th:each="topic : ${topics}">
    <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}" th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a>
   </th:block>
  </div>
  <div class="layout">
   <div class="mobile-sidebar" id="mobileSidebar">
    <button class="close-btn" onclick="toggleSidebar()">✖</button>
    <ul class="chapter-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-title" onclick="toggleChapter(this)">
        <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
       </div>
       <ul class="lesson-list">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </div>
   <aside class="sidebar">
    <ul class="sidebar-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-toggle" onclick="toggleLessons(this)">
        <span th:text="${chapter.title}">Chapter</span>
       </div>
       <ul class="lesson-list hidden">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
    ${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
    ${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul></li>
     </th:block>
    </ul>
   </aside>
   <main class="content">
    <div class="document-container">
     <h1 class="main-title">Recorduri</h1>
     <p class="paragraph">Recordurile reprezintă un nou tip referențial, care a apărut în C# 9. Caracteristica principală a recordurilor este că pot reprezenta un tip imuabil (immutable) care, în mod implicit, are o serie de avantaje față de clase și structuri. De ce avem nevoie de tipuri imuabile?</p>
     <p class="paragraph">Aceste tipuri sunt mai sigure în situațiile în care trebuie să garantăm că datele unui obiect nu vor fi modificate. În .NET există deja tipuri imuabile, de exemplu, String.</p>
     <p class="paragraph">Este important de menționat că, începând cu versiunea C# 10, a fost adăugată suportul pentru structuri record, astfel putem crea clase record și structuri record.</p>
     <p class="paragraph">Pentru a defini recorduri se folosește cuvântul cheie record. Dacă se definește o clasă record, cuvântul cheie class poate fi omis la definirea tipului:</p>
     <div class="code-inline">
      <pre><code>public&nbsp;record&nbsp;Person<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}<br>&nbsp;&nbsp;&nbsp;public&nbsp;Person(string&nbsp;name)&nbsp;=&gt;&nbsp;Name&nbsp;=&nbsp;name;<br>}</code></pre>
     </div>
     <p class="paragraph">Sau astfel:</p>
     <div class="code-inline">
      <pre><code>public&nbsp;record&nbsp;class&nbsp;Person<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}<br>&nbsp;&nbsp;&nbsp;public&nbsp;Person(string&nbsp;name)&nbsp;=&gt;&nbsp;Name&nbsp;=&nbsp;name;<br>}</code></pre>
     </div>
     <p class="paragraph">La definirea unei structuri record, trebuie folosit cuvântul cheie struct:</p>
     <div class="code-inline">
      <pre><code>public&nbsp;record&nbsp;struct&nbsp;Person<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}<br>&nbsp;&nbsp;&nbsp;public&nbsp;Person(string&nbsp;name)&nbsp;=&gt;&nbsp;Name&nbsp;=&nbsp;name;<br>}</code></pre>
     </div>
     <p class="paragraph">Deși recordurile sunt destinate creării tipurilor imuabile, folosirea simplă a cuvântului cheie record nu garantează imuabilitatea obiectelor record. Ele sunt imuabile doar în anumite condiții. De exemplu, putem scrie astfel:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;person&nbsp;=&nbsp;new&nbsp;Person("Tom");<br>person.Name&nbsp;=&nbsp;"Bob";<br>Console.WriteLine(person.Name);&nbsp;//&nbsp;Bob&nbsp;-&nbsp;datele&nbsp;au&nbsp;fost&nbsp;modificate<br><br>public&nbsp;record&nbsp;Person<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}<br>&nbsp;&nbsp;&nbsp;public&nbsp;Person(string&nbsp;name)&nbsp;=&gt;&nbsp;Name&nbsp;=&nbsp;name;<br>}</code></pre>
     </div>
     <p class="paragraph">La executarea acestui cod nu va apărea nicio eroare, putem modifica valorile proprietăților obiectului Person. Pentru a-l face cu adevărat imuabil, trebuie să folosim modificatorul init în loc de setterele obișnuite pentru proprietăți.</p>
     <div class="code-inline">
      <pre><code>var&nbsp;person&nbsp;=&nbsp;new&nbsp;Person("Tom");<br>person.Name&nbsp;=&nbsp;"Bob";&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;!&nbsp;eroare&nbsp;-&nbsp;proprietatea&nbsp;nu&nbsp;poate&nbsp;fi&nbsp;modificată<br><br>public&nbsp;record&nbsp;Person<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;init;&nbsp;}<br>&nbsp;&nbsp;&nbsp;public&nbsp;Person(string&nbsp;name)&nbsp;=&gt;&nbsp;Name&nbsp;=&nbsp;name;<br>}</code></pre>
     </div>
     <p class="paragraph">În acest caz, vom primi o eroare la încercarea de a modifica valorile proprietăților obiectului Person.</p>
     <p class="paragraph">Recordurile sunt similare cu clasele și structurile obișnuite în multe privințe, de exemplu, pot fi abstracte, pot fi moștenite sau putem interzice moștenirea cu ajutorul operatorului sealed. Cu toate acestea, există și diferențe. Să examinăm câteva dintre principalele diferențe între recorduri și clasele și structurile standard.</p>
     <h2 class="subtitle">Compararea pentru egalitate</h2>
     <p class="paragraph">La definirea unui record, compilatorul generează metoda Equals() pentru compararea cu alt obiect. Compararea a două recorduri se face pe baza valorilor acestora. De exemplu:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;person1&nbsp;=&nbsp;new&nbsp;Person("Tom");<br>var&nbsp;person2&nbsp;=&nbsp;new&nbsp;Person("Tom");<br>Console.WriteLine(person1.Equals(person2));&nbsp;//&nbsp;true<br><br>var&nbsp;user1&nbsp;=&nbsp;new&nbsp;User("Tom");<br>var&nbsp;user2&nbsp;=&nbsp;new&nbsp;User("Tom");<br>Console.WriteLine(user1.Equals(user2));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;false<br><br>public&nbsp;record&nbsp;Person<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;init;&nbsp;}<br>&nbsp;&nbsp;&nbsp;public&nbsp;Person(string&nbsp;name)&nbsp;=&gt;&nbsp;Name&nbsp;=&nbsp;name;<br>}<br><br>public&nbsp;class&nbsp;User<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;init;&nbsp;}<br>&nbsp;&nbsp;&nbsp;public&nbsp;User(string&nbsp;name)&nbsp;=&gt;&nbsp;Name&nbsp;=&nbsp;name;<br>}</code></pre>
     </div>
     <p class="paragraph">În acest caz, la compararea a două obiecte record Person, vom vedea că acestea sunt egale, deoarece valorile lor (proprietatea Name) sunt egale. Însă, în cazul obiectelor clasei User, care au aceleași valori, vom vedea că nu sunt egale, deoarece compararea recordurilor se face pe baza valorii.</p>
     <p class="paragraph">În plus, pentru recorduri sunt implementați implicit operatorii == și !=, care compară două recorduri pe baza valorii:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;person1&nbsp;=&nbsp;new&nbsp;Person("Tom");<br>var&nbsp;person2&nbsp;=&nbsp;new&nbsp;Person("Tom");<br>Console.WriteLine(person1&nbsp;==&nbsp;person2);&nbsp;//&nbsp;true<br><br>var&nbsp;user1&nbsp;=&nbsp;new&nbsp;User("Tom");<br>var&nbsp;user2&nbsp;=&nbsp;new&nbsp;User("Tom");<br>Console.WriteLine(user1&nbsp;==&nbsp;user2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;false</code></pre>
     </div>
     <h2 class="subtitle">Operatorul with</h2>
     <p class="paragraph">Spre deosebire de clase, recordurile suportă inițializarea folosind operatorul with. Acesta permite crearea unui record pe baza altui record:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;tom&nbsp;=&nbsp;new&nbsp;Person("Tom",&nbsp;37);<br>var&nbsp;sam&nbsp;=&nbsp;tom&nbsp;with&nbsp;{&nbsp;Name&nbsp;=&nbsp;"Sam"&nbsp;};<br>Console.WriteLine($"{sam.Name}&nbsp;-&nbsp;{sam.Age}");&nbsp;//&nbsp;Sam&nbsp;-&nbsp;37<br><br>public&nbsp;record&nbsp;Person<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;init;&nbsp;}<br>&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;Age&nbsp;{&nbsp;get;&nbsp;init;&nbsp;}<br>&nbsp;&nbsp;&nbsp;public&nbsp;Person(string&nbsp;name,&nbsp;int&nbsp;age)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;=&nbsp;name;&nbsp;Age&nbsp;=&nbsp;age;<br>&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">După recordul ale cărui valori dorim să le copiem, se utilizează operatorul with, după care, între acolade, se specifică valorile pentru proprietățile pe care dorim să le modificăm. În acest caz, variabila sam primește valoarea proprietății Age din tom, iar proprietatea Name este modificată.</p>
     <p class="paragraph">Această caracteristică poate fi deosebit de utilă dacă recordul pe care dorim să-l copiem are multe proprietăți, dintre care dorim să schimbăm una-două.</p>
     <p class="paragraph">Dacă trebuie să copiem valorile tuturor proprietăților, putem lăsa acoladele goale:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;person1&nbsp;=&nbsp;new&nbsp;Person("Tom",&nbsp;37);<br>var&nbsp;person2&nbsp;=&nbsp;person1&nbsp;with&nbsp;{&nbsp;};</code></pre>
     </div>
     <h2 class="subtitle">Recorduri pozițional</h2>
     <p class="paragraph">Recordurile pot primi date pentru proprietăți prin constructor, și în acest caz putem scurta definiția lor. De exemplu, să presupunem că avem următorul record Person:</p>
     <div class="code-inline">
      <pre><code>public&nbsp;record&nbsp;Person<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Name&nbsp;{&nbsp;get;&nbsp;init;&nbsp;}<br>&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;Age&nbsp;{&nbsp;get;&nbsp;init;&nbsp;}<br>&nbsp;&nbsp;&nbsp;public&nbsp;Person(string&nbsp;name,&nbsp;int&nbsp;age)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;=&nbsp;name;&nbsp;Age&nbsp;=&nbsp;age;<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Deconstruct(out&nbsp;string&nbsp;name,&nbsp;out&nbsp;int&nbsp;age)&nbsp;=&gt;&nbsp;(name,&nbsp;age)&nbsp;=&nbsp;(Name,&nbsp;Age);<br>}</code></pre>
     </div>
     <p class="paragraph">Pe lângă constructor, aici este implementat și un deconstructor, care permite descompunerea obiectului Person într-un tuple de valori. Am putea folosi aceasta, de exemplu, astfel:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;person&nbsp;=&nbsp;new&nbsp;Person("Tom",&nbsp;37);<br>Console.WriteLine(person.Name);&nbsp;//&nbsp;Tom<br><br>var&nbsp;(personName,&nbsp;personAge)&nbsp;=&nbsp;person;<br><br>Console.WriteLine(personAge);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;37<br>Console.WriteLine(personName);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Tom</code></pre>
     </div>
     <p class="paragraph">Recordul Person definit mai sus poate fi redus la un record pozițional:</p>
     <div class="code-inline">
      <pre><code>public&nbsp;record&nbsp;Person(string&nbsp;Name,&nbsp;int&nbsp;Age);</code></pre>
     </div>
     <p class="paragraph">Aceasta este toată definiția tipului. Adică, spunem că pentru tipul Person va fi creat un constructor care primește doi parametri și le atribuie valorile corespunzătoare proprietăților Name și Age, și că va fi creat automat și un deconstructor. Utilizarea sa va fi similară:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;person&nbsp;=&nbsp;new&nbsp;Person("Tom",&nbsp;37);<br>Console.WriteLine(person);&nbsp;//&nbsp;Tom<br><br>var&nbsp;(personName,&nbsp;personAge)&nbsp;=&nbsp;person;<br><br>Console.WriteLine(personAge);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;37<br>Console.WriteLine(personName);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Tom<br><br>public&nbsp;record&nbsp;Person(string&nbsp;Name,&nbsp;int&nbsp;Age);</code></pre>
     </div>
     <p class="paragraph">Dacă este necesar, putem combina definiția standard a proprietăților cu definiția proprietăților prin constructor:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;person&nbsp;=&nbsp;new&nbsp;Person("Tom",&nbsp;37)&nbsp;{&nbsp;Company&nbsp;=&nbsp;"Google"&nbsp;};<br>Console.WriteLine(person.Company);&nbsp;//&nbsp;Google<br>person.Company&nbsp;=&nbsp;"Microsoft";<br>Console.WriteLine(person.Company);&nbsp;//&nbsp;Microsoft<br><br>public&nbsp;record&nbsp;Person(string&nbsp;Name,&nbsp;int&nbsp;Age)<br>{<br>&nbsp;&nbsp;&nbsp;public&nbsp;string&nbsp;Company&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}&nbsp;=&nbsp;"";<br>}</code></pre>
     </div>
     <h2 class="subtitle">Structuri poziționale pentru citire</h2>
     <p class="paragraph">Este important să menționăm diferența dintre clasele și structurile record poziționale. Proprietățile clasei record, care sunt setate prin parametrii constructorului, vor avea implicit modificatorul init.</p>
     <p class="paragraph">Adică, după setarea valorilor prin constructor, nu vom mai putea modifica aceste valori:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;person&nbsp;=&nbsp;new&nbsp;Person("Tom",&nbsp;37);<br>person.Name&nbsp;=&nbsp;"Bob";&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;!&nbsp;Eroare&nbsp;-&nbsp;valoarea&nbsp;nu&nbsp;poate&nbsp;fi&nbsp;modificată<br><br>public&nbsp;record&nbsp;Person(string&nbsp;Name,&nbsp;int&nbsp;Age);</code></pre>
     </div>
     <p class="paragraph">Este de menționat că acest lucru se aplică doar proprietăților care sunt setate prin constructor.</p>
     <p class="paragraph">Totuși, pentru structurile record poziționale, proprietățile vor avea setterele standard, permițând modificarea valorilor:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;person&nbsp;=&nbsp;new&nbsp;Person("Tom",&nbsp;37);<br>person.Name&nbsp;=&nbsp;"Bob";<br>Console.WriteLine(person.Name);&nbsp;//&nbsp;Bob&nbsp;-&nbsp;valoarea&nbsp;a&nbsp;fost&nbsp;modificată<br><br>//&nbsp;structura&nbsp;record<br>public&nbsp;record&nbsp;struct&nbsp;Person(string&nbsp;Name,&nbsp;int&nbsp;Age);</code></pre>
     </div>
     <p class="paragraph">Pentru a folosi modificatorul init în locul setterelor standard pentru astfel de proprietăți ale structurii record, trebuie să definim structura cu cuvântul cheie readonly:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;person&nbsp;=&nbsp;new&nbsp;Person("Tom",&nbsp;37);<br>person.Name&nbsp;=&nbsp;"Bob";&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;!&nbsp;Eroare&nbsp;-&nbsp;valoarea&nbsp;proprietății&nbsp;nu&nbsp;poate&nbsp;fi&nbsp;modificată<br><br>//&nbsp;structura&nbsp;record&nbsp;doar&nbsp;pentru&nbsp;citire<br>public&nbsp;readonly&nbsp;record&nbsp;struct&nbsp;Person(string&nbsp;Name,&nbsp;int&nbsp;Age);</code></pre>
     </div>
     <h2 class="subtitle">Metoda ToString()</h2>
     <p class="paragraph">Un mic avantaj al tipurilor record este că pentru ele este implementată implicit metoda ToString(), care afișează starea obiectului într-un format structurat:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;person&nbsp;=&nbsp;new&nbsp;Person("Tom",&nbsp;37);<br>Console.WriteLine(person);&nbsp;//&nbsp;Person&nbsp;{&nbsp;Name&nbsp;=&nbsp;Tom,&nbsp;Age&nbsp;=&nbsp;37&nbsp;}<br><br>public&nbsp;record&nbsp;Person(string&nbsp;Name,&nbsp;int&nbsp;Age);</code></pre>
     </div>
     <h2 class="subtitle">Moștenirea</h2>
     <p class="paragraph">Ca și clasele obișnuite, recordurile pot fi moștenite:</p>
     <div class="code-inline">
      <pre><code>var&nbsp;tom&nbsp;=&nbsp;new&nbsp;Person("Tom",&nbsp;37);<br>var&nbsp;bob&nbsp;=&nbsp;new&nbsp;Employee("Bob",&nbsp;41,&nbsp;"Microsoft");<br>Console.WriteLine(tom);&nbsp;//&nbsp;Person&nbsp;{&nbsp;Name&nbsp;=&nbsp;Tom,&nbsp;Age&nbsp;=&nbsp;37&nbsp;}<br>Console.WriteLine(bob);&nbsp;//&nbsp;Person&nbsp;{&nbsp;Name&nbsp;=&nbsp;Bob,&nbsp;Age&nbsp;=&nbsp;41,&nbsp;Company&nbsp;=&nbsp;Microsoft&nbsp;}<br><br>public&nbsp;record&nbsp;Person(string&nbsp;Name,&nbsp;int&nbsp;Age);<br>public&nbsp;record&nbsp;Employee(string&nbsp;Name,&nbsp;int&nbsp;Age,&nbsp;string&nbsp;Company)&nbsp;:&nbsp;Person(Name,&nbsp;Age);</code></pre>
     </div>
     <p class="paragraph">În acest caz, clasa record Employee moștenește de la Person.</p>
    </div>
   </main>
   <aside class="ad-section">
    <div class="ad-box">
     <p>Google Ad Here</p>
    </div>
    <div class="ad-box">
     <p>Promo: SQL Beginner Guide</p>
    </div>
   </aside>
  </div>
  <div class="lesson-navigation">
   <th:block th:if="${previousLesson != null}">
    <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția anterioară</a>
   </th:block> <th:block th:if="${nextLesson != null}">
    <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția următoare →</a>
   </th:block>
  </div>
  <div th:replace="~{fragments/footer :: footer}"></div>
  <script th:src="@{/js/script.js}" defer></script>
 </body>
</html>
