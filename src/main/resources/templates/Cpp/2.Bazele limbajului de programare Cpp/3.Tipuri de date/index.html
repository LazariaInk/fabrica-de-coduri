<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">
 <head>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4253419731329045" crossorigin="anonymous"></script>
  <link rel="canonical" th:href="${canonicalUrl}">
  <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
  <script>
        window.dataLayer = window.dataLayer || [];
        window.gtag = function () { dataLayer.push(arguments); };
        gtag('consent', 'default', {
            'wait_for_update': 500,
            'region': ['RO'],
            'ad_storage': 'denied',
            'analytics_storage': 'denied',
            'ad_user_data': 'denied',
            'ad_personalization': 'denied'
        });
        gtag('js', new Date());
        gtag('config', 'G-7Q2536ZKL2');
    </script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title th:text="${lesson.title}">Lesson</title>
  <link rel="stylesheet" th:href="@{/css/styles.css}">
  <style>
        body {
            background: #ffffff;
        }
    </style>
 </head>
 <body th:with="activeTopic='C-sharp', activeChapter='10.Colectii', activeLesson='1.Lista List_T_'">
  <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
  <div th:replace="~{fragments/nav :: nav}"></div>
  <div class="top-nav">
   <th:block th:each="topic : ${topics}"> <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}" th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a> </th:block>
  </div>
  <div class="layout">
   <div class="mobile-sidebar" id="mobileSidebar">
    <button class="close-btn" onclick="toggleSidebar()">✖</button>
    <ul class="chapter-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-title" onclick="toggleChapter(this)">
        <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
       </div>
       <ul class="lesson-list">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul>
      </li>
     </th:block>
    </ul>
   </div>
   <aside class="sidebar">
    <ul class="sidebar-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-toggle" onclick="toggleLessons(this)">
        <span th:text="${chapter.title}">Chapter</span>
       </div>
       <ul class="lesson-list hidden">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul>
      </li>
     </th:block>
    </ul>
   </aside>
   <main class="content">
    <div class="document-container">
     <h1 class="main-title">Tipuri de date</h1>
     <p class="paragraph">Fiecare variabilă are un anumit tip. Și acest tip determină ce valori poate avea variabila, ce operații pot fi efectuate asupra ei și câți octeți va ocupa în memorie. În limbajul C++ sunt definite următoarele tipuri de date de bază: tipul logic bool, tipurile întregi, tipurile de numere cu virgulă mobilă, tipurile de caractere. Să analizăm aceste grupuri separat.</p>
     <h2 class="subtitle">Tipul logic</h2>
     <p class="paragraph">Tipul logic bool poate stoca una dintre cele două valori: true (adevărat, corect) și false (fals, incorect). De exemplu, să definim o pereche de variabile de acest tip și să le afișăm valorile în consolă:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;isAlive&nbsp;{true};<br>&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;isDead&nbsp;{false};<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"isAlive:&nbsp;"&nbsp;&lt;&lt;&nbsp;isAlive&nbsp;&lt;&lt;&nbsp;"\n";&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"isDead:&nbsp;"&nbsp;&lt;&lt;&nbsp;isDead&nbsp;&lt;&lt;&nbsp;"\n";&nbsp;<br>}</code></pre>
     </div>
     <p class="paragraph">La afișarea valorii de tip bool, aceasta este convertită în 1 (dacă este true) și 0 (dacă este false). De regulă, acest tip este utilizat în principal în expresii condiționale, care vor fi analizate mai târziu.</p>
     <p class="paragraph">Valoarea implicită pentru variabilele de acest tip este false.</p>
     <h2 class="subtitle">Tipuri întregi</h2>
     <p class="paragraph">Numerele întregi în limbajul C++ sunt reprezentate prin următoarele tipuri:</p>
     <ul class="enumeration">
      <li>signed char: reprezintă un singur caracter. Ocupă în memorie 1 byte (8 biți). Poate stoca orice valoare din intervalul de la -128 până la 127</li>
      <li>unsigned char: reprezintă un singur caracter. Ocupă 1 byte (8 biți). Interval: de la 0 până la 255</li>
      <li>char: reprezintă un caracter în codificarea ASCII. Ocupă 1 byte (8 biți). Poate stoca o valoare între -128 și 127 sau 0 și 255, în funcție de compilator. Deși are același interval ca signed char, nu este echivalent — poate fi tratat ca signed sau unsigned în funcție de compilator. Este destinat stocării codului numeric al unui caracter</li>
      <li>short: număr întreg între –32.768 și 32.767. Ocupă 2 bytes (16 biți). Sinonime: short int, signed short int, signed short</li>
      <li>unsigned short: număr întreg între 0 și 65.535. Ocupă 2 bytes. Sinonim: unsigned short int</li>
      <li>int: număr întreg. Pe arhitecturi de 16 biți: 2 bytes → interval: –32.768 până la 32.767. Pe arhitecturi de 32 biți: 4 bytes → interval: –2.147.483.648 până la 2.147.483.647. Dimensiunea trebuie să fie ≥ short și ≤ long. Sinonime: signed int, signed</li>
      <li>unsigned int: număr întreg pozitiv. 2 bytes → 0 – 65.535, 4 bytes → 0 – 4.294.967.295, Sinonim: unsigned.</li>
      <li>long: 4 bytes → interval: –2.147.483.648 până la 2.147.483.647, 8 bytes (pe unele arhitecturi) → –9.223.372.036.854.775.808 până la +9.223.372.036.854.775.807, Sinonime: long int, signed long int, signed long.</li>
      <li>unsigned long: Interval: 0 – 4.294.967.295, 4 bytes, Sinonim: unsigned long int</li>
      <li>long long: Interval: –9.223.372.036.854.775.808 până la +9.223.372.036.854.775.807, 8 bytes, Sinonime: long long int, signed long long int, signed long long</li>
      <li>unsigned long long: Interval: 0 – 18.446.744.073.709.551.615, De obicei, 8 bytes, Sinonim: unsigned long long int</li>
     </ul>
     <p class="paragraph">Pentru reprezentarea numerelor în C++ se folosesc literali întregi cu sau fără semn, cum ar fi -10 sau 10. De exemplu, să definim o serie de variabile de tipuri întregi și să le afișăm în consolă:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;signed&nbsp;char&nbsp;num1{&nbsp;-64&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;num2{&nbsp;64&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;num3{&nbsp;-88&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;short&nbsp;num4{&nbsp;88&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;num5{&nbsp;-1024&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;num6{&nbsp;1024&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;num7{&nbsp;-2048&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;num8{&nbsp;2048&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;long&nbsp;num9{&nbsp;-4096&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;long&nbsp;num10{&nbsp;4096&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"num1&nbsp;=&nbsp;"&nbsp;&lt;&lt;&nbsp;num1&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"num2&nbsp;=&nbsp;"&nbsp;&lt;&lt;&nbsp;num2&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"num3&nbsp;=&nbsp;"&nbsp;&lt;&lt;&nbsp;num3&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"num4&nbsp;=&nbsp;"&nbsp;&lt;&lt;&nbsp;num4&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"num5&nbsp;=&nbsp;"&nbsp;&lt;&lt;&nbsp;num5&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"num6&nbsp;=&nbsp;"&nbsp;&lt;&lt;&nbsp;num6&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"num7&nbsp;=&nbsp;"&nbsp;&lt;&lt;&nbsp;num7&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"num8&nbsp;=&nbsp;"&nbsp;&lt;&lt;&nbsp;num8&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"num9&nbsp;=&nbsp;"&nbsp;&lt;&lt;&nbsp;num9&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"num10&nbsp;=&nbsp;"&nbsp;&lt;&lt;&nbsp;num10&nbsp;&lt;&lt;&nbsp;std::endl;<br>}</code></pre>
     </div>
     <p class="paragraph">Dar merită menționat că toți literalii întregi, în mod implicit, au tipul int. Astfel, în exemplele de mai sus, variabilelor de diferite tipuri li s-au atribuit diverse valori — 64, -64, 88, -88, 1024 ș.a.m.d. Însă toți acești literali întregi au, în esență, tipul int.</p>
     <p class="paragraph">Totuși, putem folosi și literali întregi de alte tipuri. Literalii întregi fără semn (care corespund tipurilor unsigned) au sufixul u sau U. Literalii de tipurile long și long long au sufixele L/l și LL/ll, respectiv:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;num6{&nbsp;1024U&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;U&nbsp;-&nbsp;unsigned&nbsp;int<br>&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;num7{&nbsp;-2048L&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;L&nbsp;-&nbsp;long<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;num8{&nbsp;2048UL&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;UL&nbsp;-&nbsp;unsigned&nbsp;long<br>&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;long&nbsp;num9{&nbsp;-4096LL&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;LL&nbsp;-&nbsp;long&nbsp;long<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;long&nbsp;num10{&nbsp;4096ULL&nbsp;};//&nbsp;ULL&nbsp;-&nbsp;unsigned&nbsp;long&nbsp;long<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"num6&nbsp;=&nbsp;"&nbsp;&lt;&lt;&nbsp;num6&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"num7&nbsp;=&nbsp;"&nbsp;&lt;&lt;&nbsp;num7&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"num8&nbsp;=&nbsp;"&nbsp;&lt;&lt;&nbsp;num8&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"num9&nbsp;=&nbsp;"&nbsp;&lt;&lt;&nbsp;num9&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"num10&nbsp;=&nbsp;"&nbsp;&lt;&lt;&nbsp;num10&nbsp;&lt;&lt;&nbsp;std::endl;<br>}</code></pre>
     </div>
     <p class="paragraph">Totuși, utilizarea sufixelor nu este obligatorie, deoarece, de regulă, compilatorul poate converti cu succes un literal întreg (care, tehnic, are tipul int) în tipul necesar, fără pierdere de informație.</p>
     <p class="paragraph">Dacă numărul este mare, ne putem înșela ușor la introducerea lui. Pentru a îmbunătăți lizibilitatea numerelor, începând cu standardul C++14, în limbaj a fost adăugată posibilitatea de a separa cifrele unui număr folosind apostroful simplu '.</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;num{&nbsp;1'234'567'890&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"num&nbsp;=&nbsp;"&nbsp;&lt;&lt;&nbsp;num&nbsp;&lt;&lt;&nbsp;"\n";&nbsp;&nbsp;&nbsp;//&nbsp;num&nbsp;=&nbsp;1234567890<br>}</code></pre>
     </div>
     <h2 class="subtitle">Sisteme de numerație diferite</h2>
     <p class="paragraph">În mod implicit, toți literalii întregi standard reprezintă numere în sistemul zecimal, cu care suntem obișnuiți. Totuși, C++ permite utilizarea numerelor și în alte sisteme de numerație. Pentru a indica faptul că un număr este hexazecimal, se adaugă prefixul 0x sau 0X înaintea valorii. De exemplu:</p>
     <div class="code-inline">
      <pre><code>int&nbsp;num1{&nbsp;0x1A&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;26&nbsp;–&nbsp;în&nbsp;sistem&nbsp;zecimal<br>int&nbsp;num2{&nbsp;0xFF&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;255&nbsp;–&nbsp;în&nbsp;sistem&nbsp;zecimal<br>int&nbsp;num3{&nbsp;0xFFFFFF&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;16777215&nbsp;–&nbsp;în&nbsp;sistem&nbsp;zecimal</code></pre>
     </div>
     <p class="paragraph">Pentru a indica faptul că un număr este octal, se pune un zero (0) înaintea numărului. De exemplu:</p>
     <div class="code-inline">
      <pre><code>int&nbsp;num1{&nbsp;034&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;26&nbsp;–&nbsp;în&nbsp;sistem&nbsp;zecimal<br>int&nbsp;num2{&nbsp;0377&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;255&nbsp;–&nbsp;în&nbsp;sistem&nbsp;zecimal</code></pre>
     </div>
     <p class="paragraph">Literalii binari sunt precedați de prefixul 0b sau 0B:</p>
     <div class="code-inline">
      <pre><code>int&nbsp;num1{&nbsp;0b11010&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;26&nbsp;–&nbsp;în&nbsp;sistem&nbsp;zecimal<br>int&nbsp;num2{&nbsp;0b11111111&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;255&nbsp;–&nbsp;în&nbsp;sistem&nbsp;zecimal</code></pre>
     </div>
     <p class="paragraph">Toate aceste tipuri de literali acceptă, de asemenea, sufixele U / L / LL:</p>
     <div class="code-inline">
      <pre><code>unsigned&nbsp;int&nbsp;num1{&nbsp;0b11010U&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;26&nbsp;–&nbsp;în&nbsp;sistem&nbsp;zecimal<br>long&nbsp;num2{&nbsp;0377L&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;255&nbsp;–&nbsp;în&nbsp;sistem&nbsp;zecimal<br>unsigned&nbsp;long&nbsp;num3{&nbsp;0xFFFFFFULL&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;16777215&nbsp;–&nbsp;în&nbsp;sistem&nbsp;zecimal</code></pre>
     </div>
     <h2 class="subtitle">Numere cu virgulă mobilă</h2>
     <p class="paragraph">Pentru stocarea numerelor zecimale în C++ se folosesc numerele cu virgulă mobilă. Un număr cu virgulă mobilă constă din două părți: mantisa și exponentul. Ambele pot fi atât pozitive, cât și negative. Valoarea numărului este mantisa înmulțită cu zece la puterea exponentului.</p>
     <p class="paragraph">De exemplu, numărul 365 poate fi scris ca număr cu virgulă mobilă în felul următor:</p>
     <div class="code-inline">
      <pre><code>3.650000E02</code></pre>
     </div>
     <p class="paragraph">În calitate de separator între partea întreagă și fracționară se folosește simbolul punctului. Mantisa aici are șapte cifre zecimale – 3.650000, exponentul – două cifre 02. Litera E înseamnă exponent, după ea se indică exponentul (puterea lui zece), cu care se înmulțește partea 3.650000 (mantisa), pentru a obține valoarea dorită. Adică, pentru a reveni la reprezentarea zecimală obișnuită, trebuie să efectuăm următoarea operație:</p>
     <p class="paragraph">3.650000 × 10² = 365</p>
     <p class="paragraph">Alt exemplu – să luăm un număr mic:</p>
     <div class="code-inline">
      <pre><code>-3.650000E-03</code></pre>
     </div>
     <p class="paragraph">În acest caz avem de-a face cu numărul –3.65 × 10⁻³, ceea ce este egal cu –0.00365. Aici observăm că, în funcție de valoarea exponentului, punctul zecimal „plutește”. De fapt, din acest motiv ele se numesc numere cu virgulă mobilă.</p>
     <p class="paragraph">Totuși, deși o astfel de notare permite reprezentarea unui interval foarte mare de valori, nu toate aceste valori pot fi reprezentate cu precizie completă; numerele cu virgulă mobilă sunt, în general, o aproximare a valorii exacte. De exemplu, numărul 1254311179 ar arăta astfel: 1.254311E09. Totuși, dacă îl convertim înapoi în notație zecimală, va deveni 1254311000. Iar asta nu este același lucru cu 1254311179, deoarece am pierdut ultimele trei cifre.</p>
     <script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
     <p class="paragraph">În limbajul C++ există trei tipuri pentru reprezentarea numerelor cu virgulă mobilă:</p>
     <ul class="enumeration">
      <li>float: reprezintă un număr real în precizie simplă cu virgulă mobilă, în intervalul de ±3.4E−38 până la 3.4E+38. Ocupă în memorie 4 bytes (32 biți)</li>
      <li>double: reprezintă un număr real în precizie dublă cu virgulă mobilă, în intervalul de ±1.7E−308 până la 1.7E+308. Ocupă în memorie 8 bytes (64 biți)</li>
      <li>long double: reprezintă un număr real în precizie extinsă, cu virgulă mobilă, de cel puțin 8 bytes (64 biți). În funcție de dimensiunea ocupată în memorie, intervalul valorilor posibile poate varia</li>
     </ul>
     <p class="paragraph">În reprezentarea binară internă, fiecare număr cu virgulă mobilă constă din un bit de semn, urmat de un număr fix de biți pentru exponent și un set de biți pentru stocarea mantisei. În numerele de tip float, 1 bit este pentru semn, 8 biți pentru exponent și 23 pentru mantisă, ceea ce în total oferă 32 de biți. Mantisa permite determinarea preciziei numărului în forma a 7 cifre zecimale.</p>
     <p class="paragraph">În numerele de tip double, 1 bit de semn, 11 biți pentru exponent și 52 biți pentru mantisă, adică în total 64 de biți. O mantisă pe 52 de biți permite determinarea preciziei de până la 16 cifre zecimale.</p>
     <p class="paragraph">Pentru tipul long double, structura depinde de compilatorul concret și implementarea acestui tip de date. Majoritatea compilatoarelor oferă precizie de până la 18–19 cifre zecimale (mantisă pe 64 de biți), în altele (precum Microsoft Visual C++) long double este echivalent cu tipul double.</p>
     <ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-4253419731329045" data-ad-slot="8453761934"></ins>
     <script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
     <p class="paragraph">În C++, literalii numerelor cu virgulă mobilă sunt reprezentate prin numere zecimale, care folosesc punctul ca separator între partea întreagă și fracționară:</p>
     <div class="code-inline">
      <pre><code>double&nbsp;num&nbsp;{10.45};</code></pre>
     </div>
     <p class="paragraph">Chiar și atunci când unei variabile i se atribuie un număr întreg, pentru a indica faptul că atribuim un număr cu virgulă mobilă, se folosește punctul:</p>
     <div class="code-inline">
      <pre><code>double&nbsp;num1{&nbsp;1&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;1&nbsp;–&nbsp;literal&nbsp;întreg&nbsp;&nbsp;<br>double&nbsp;num2{&nbsp;1.&nbsp;};&nbsp;&nbsp;&nbsp;//&nbsp;1.&nbsp;–&nbsp;literal&nbsp;al&nbsp;unui&nbsp;număr&nbsp;cu&nbsp;virgulă&nbsp;mobilă</code></pre>
     </div>
     <p class="paragraph">Așadar, aici numărul 1. reprezintă un literal al unui număr cu virgulă mobilă și, în principiu, este echivalent cu 1.0.</p>
     <p class="paragraph">În mod implicit, toate aceste numere cu punct sunt tratate ca fiind de tip double. Pentru a indica că un număr este de alt tip, se folosește sufixul f / F pentru float și l / L pentru long double:</p>
     <div class="code-inline">
      <pre><code>float&nbsp;num1{&nbsp;10.56f&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;float<br>long&nbsp;double&nbsp;num2{&nbsp;10.56l&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;long&nbsp;double</code></pre>
     </div>
     <p class="paragraph">Ca alternativă, se poate folosi și notația expo­nențială:</p>
     <div class="code-inline">
      <pre><code>double&nbsp;num1{&nbsp;5E3&nbsp;&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;5E3&nbsp;&nbsp;=&nbsp;5000.0<br>double&nbsp;num2{&nbsp;2.5e-3&nbsp;&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;2.5e-3&nbsp;&nbsp;=&nbsp;0.0025</code></pre>
     </div>
     <h2 class="subtitle">Dimensiuni ale tipurilor de date</h2>
     <p class="paragraph">La enumerarea tipurilor de date a fost indicată dimensiunea pe care acestea o ocupă în memorie, însă standardul limbajului stabilește doar valorile minime care trebuie respectate. De exemplu, pentru tipurile int și short, valoarea minimă este 16 biți, pentru long – 32 de biți, iar pentru long double – 64 de biți. În același timp, dimensiunea tipului long nu trebuie să fie mai mică decât cea a lui int, dimensiunea lui int nu trebuie să fie mai mică decât a lui short, iar dimensiunea lui long double trebuie să fie cel puțin egală cu cea a lui double. Producătorii de compilatoare pot alege dimensiunile maxime ale tipurilor în funcție de capabilitățile hardware ale computerului.</p>
     <p class="paragraph">De exemplu, compilatorul g++ pe Windows folosește 16 bytes pentru long double. Compilatorul din Visual Studio, care tot rulează pe Windows, precum și clang++ pe Windows, folosesc 8 bytes pentru long double. Așadar, chiar și pe aceeași platformă, compilatoare diferite pot trata în mod diferit dimensiunile unor tipuri de date. Totuși, în general, se folosesc dimensiunile menționate mai sus în descrierea tipurilor.</p>
     <p class="paragraph">Există însă situații în care trebuie să cunoaștem exact dimensiunea unui anumit tip. Pentru aceasta, în C++ există operatorul sizeof(), care returnează dimensiunea în bytes a memoriei ocupate de o variabilă:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;double&nbsp;number&nbsp;{2};<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"sizeof(number)&nbsp;="&nbsp;&lt;&lt;&nbsp;sizeof(number);<br>}</code></pre>
     </div>
     <p class="paragraph">Ieșirea în consolă la compilare cu g++:</p>
     <div class="code-inline">
      <pre><code>sizeof(number)&nbsp;=&nbsp;16</code></pre>
     </div>
     <h2 class="subtitle">Tipuri de caractere</h2>
     <p class="paragraph">În C++ există următoarele tipuri de date pentru caractere:</p>
     <ul class="enumeration">
      <li>char: reprezintă un singur caracter în codificarea ASCII. Ocupă 1 byte (8 biți) în memorie. Poate stoca orice valoare din intervalul de la -128 la 127 sau de la 0 la 255</li>
      <li>wchar_t: reprezintă un caracter extins. Pe Windows ocupă 2 bytes (16 biți), pe Linux – 4 bytes (32 biți). Poate stoca orice valoare din intervalul de la 0 la 65.535 (la 2 bytes) sau de la 0 la 4.294.967.295 (la 4 bytes)</li>
      <li>char8_t: reprezintă un caracter în codificarea Unicode. Ocupă 1 byte în memorie. Poate stoca orice valoare din intervalul de la 0 la 256</li>
      <li>char16_t: reprezintă un caracter în codificarea Unicode. Ocupă 2 bytes (16 biți). Poate stoca orice valoare din intervalul de la 0 la 65.535</li>
      <li>char32_t: reprezintă un caracter în codificarea Unicode. Ocupă 4 bytes (32 biți). Poate stoca orice valoare din intervalul de la 0 la 4.294.967.295</li>
     </ul>
     <h2 class="subtitle">Variabilă de tip char</h2>
     <p class="paragraph">Variabila de tip char stochează codul numeric al unui singur caracter și ocupă un byte. Standardul limbajului C++ nu specifică ce codificare a caracterelor trebuie folosită pentru caracterele de tip char, așadar producătorii de compilatoare pot alege orice codificare, însă de obicei este folosită ASCII. Ca valoare, o variabilă de tip char poate primi un caracter între ghilimele simple sau codul numeric al caracterului:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;a1&nbsp;{'A'};<br>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;a2&nbsp;{65};<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"a1:&nbsp;"&nbsp;&lt;&lt;&nbsp;a1&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"a2:&nbsp;"&nbsp;&lt;&lt;&nbsp;a2&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;<br>}</code></pre>
     </div>
     <p class="paragraph">În acest caz, variabilele a1 și a2 vor avea aceeași valoare, deoarece 65 este codul numeric al caracterului "A" în tabelul ASCII. La afișarea în consolă cu ajutorul cout, în mod implicit este afișat caracterul.</p>
     <p class="paragraph">În plus, în C++ pot fi folosite secvențe speciale de control, care încep cu o bară oblică (\) și sunt interpretate într-un mod special. De exemplu, "\n" reprezintă un salt de linie, iar "\t" – un tab.</p>
     <p class="paragraph">Totuși, ASCII este de obicei potrivit pentru seturi de caractere ale limbilor care folosesc alfabetul latin. Dacă este necesar să lucrăm cu caractere din mai multe limbi simultan sau din limbi care nu folosesc alfabetul englez, cele 256 de coduri posibile pot să nu fie suficiente. În acest caz se folosește Unicode.</p>
     <p class="paragraph">Unicode este un standard care definește un set de caractere și punctele lor de cod, precum și mai multe codificări diferite pentru aceste puncte de cod. Cele mai utilizate codificări sunt: UTF-8, UTF-16 și UTF-32. Diferența dintre ele constă în modul în care este reprezentat punctul de cod al unui caracter; însă valoarea numerică a codului pentru orice caracter rămâne aceeași în oricare dintre aceste codificări. Principalele diferențe:</p>
     <ul class="enumeration">
      <li>UTF-8 reprezintă un caracter ca o secvență de lungime variabilă, de la unu până la patru bytes. Setul de caractere ASCII apare în UTF-8 ca coduri pe un singur byte, care au aceleași valori ca și în ASCII. UTF-8 este, în prezent, cea mai populară codificare Unicode.</li>
      <li>UTF-16 reprezintă caracterele ca una sau două valori de 16 biți.</li>
      <li>UTF-32 reprezintă toate caracterele ca valori de 32 de biți.</li>
     </ul>
     <p class="paragraph">În C++ există patru tipuri pentru stocarea caracterelor Unicode: wchar_t, char8_t, char16_t și char32_t (char16_t și char32_t au fost adăugate în C++11, iar char8_t – în C++20).</p>
     <h2 class="subtitle">Tipul wchar_t</h2>
     <p class="paragraph">Tipul wchar_t este tipul de bază destinat seturilor de caractere al căror volum depășește un singur byte. De aici provine și denumirea sa: wchar_t – de la wide char („caracter larg”), pentru că acest caracter este „mai larg” decât un caracter obișnuit de un byte. Valorile de tip wchar_t sunt definite la fel ca și caracterele char, cu excepția faptului că ele sunt precedate de caracterul "L":</p>
     <div class="code-inline">
      <pre><code>wchar_t&nbsp;a1&nbsp;{L'A'};</code></pre>
     </div>
     <p class="paragraph">De asemenea, se poate transmite codul caracterului.</p>
     <div class="code-inline">
      <pre><code>wchar_t&nbsp;a1&nbsp;{L'\x41'};</code></pre>
     </div>
     <p class="paragraph">Valoarea încadrată în ghilimele simple reprezintă codul hexazecimal al caracterului. Bara oblică inversă indică începutul unei secvențe de control, iar x după această bară înseamnă că urmează un cod în sistem hexazecimal.</p>
     <p class="paragraph">Trebuie avut în vedere că, pentru a afișa în consolă caractere de tip wchar_t, nu se folosește std::cout, ci fluxul std::wcout:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;h&nbsp;=&nbsp;'H';<br>&nbsp;&nbsp;&nbsp;&nbsp;wchar_t&nbsp;i&nbsp;{L'i'};<br>&nbsp;&nbsp;&nbsp;&nbsp;std::wcout&nbsp;&lt;&lt;&nbsp;h&nbsp;&lt;&lt;&nbsp;i&nbsp;&lt;&lt;'\n';<br>}</code></pre>
     </div>
     <p class="paragraph">În același timp, fluxul std::wcout poate lucra atât cu char, cât și cu wchar_t. Iar fluxul std::cout, pentru o variabilă de tip wchar_t, va afișa codul numeric al caracterului în locul caracterului propriu-zis.</p>
     <p class="paragraph">Problema cu tipul wchar_t constă în faptul că dimensiunea lui depinde foarte mult de implementare și de codificarea utilizată. Codificarea este de obicei aleasă în funcție de codificarea preferată a platformei țintă. Astfel, pe Windows wchar_t are de regulă o lățime de 16 biți și este codificat folosind UTF-16. Majoritatea celorlalte platforme stabilesc dimensiunea la 32 de biți și folosesc UTF-32 ca metodă de codificare. Pe de o parte, acest lucru permite o mai bună integrare cu platforma respectivă. Pe de altă parte, însă, complică scrierea unui cod portabil între platforme. De aceea, în general, este adesea recomandat să se folosească tipurile char8_t, char16_t și char32_t. Valorile acestor tipuri sunt destinate stocării caracterelor în codificările UTF-8, UTF-16 sau UTF-32, respectiv, iar dimensiunile lor sunt aceleași pe toate platformele răspândite.</p>
     <p class="paragraph">Pentru definirea caracterelor de tip char8_t, char16_t și char32_t se folosesc, respectiv, prefixele u8, u și U:</p>
     <div class="code-inline">
      <pre><code>char8_t&nbsp;c{&nbsp;u8'l'&nbsp;};<br>char16_t&nbsp;d{&nbsp;u'l'&nbsp;};<br>char32_t&nbsp;e{&nbsp;U'o'&nbsp;};</code></pre>
     </div>
     <p class="paragraph">Trebuie menționat că, pentru afișarea în consolă a valorilor de tip char8_t / char16_t / char32_t, deocamdată nu există instrumente integrate precum std::cout / std::wcout.</p>
     <h2 class="subtitle">Specificatorul auto</h2>
     <p class="paragraph">Uneori este dificil să determinăm tipul unei expresii. În acest caz, putem lăsa compilatorul să deducă singur tipul obiectului. Pentru aceasta se folosește specificatorul auto. În același timp, dacă definim o variabilă cu specificatorul auto, acea variabilă trebuie neapărat să fie inițializată cu o valoare:</p>
     <div class="code-inline">
      <pre><code>auto&nbsp;number&nbsp;=&nbsp;5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;number&nbsp;are&nbsp;tipul&nbsp;int&nbsp;&nbsp;<br>auto&nbsp;sum&nbsp;{1234.56};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;sum&nbsp;are&nbsp;tipul&nbsp;double&nbsp;&nbsp;<br>auto&nbsp;distance&nbsp;{267UL};&nbsp;&nbsp;&nbsp;//&nbsp;distance&nbsp;are&nbsp;tipul&nbsp;unsigned&nbsp;long</code></pre>
     </div>
     <p class="paragraph">Pe baza valorii atribuite, compilatorul va deduce tipul variabilei. Variabilele neinițializate cu specificatorul auto nu sunt permise:</p>
     <div class="code-inline">
      <pre><code>auto&nbsp;number;</code></pre>
     </div>
    </div>
    <div class="lesson-navigation">
     <th:block th:if="${previousLesson != null}"> <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția anterioară</a> </th:block> <th:block th:if="${nextLesson != null}"> <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția următoare →</a> </th:block>
    </div>
    <div class="discord-banner-section">
     <div class="discord-banner-container">
      <a href="https://discord.com/channels/1168639076098920578/1168646757551443979" target="_blank"> <img th:src="@{/images/cpp_discord.png}" alt="Discord Banner" class="discord-banner-image"> </a>
     </div>
    </div>
   </main>
   <aside class="ad-section">
    <div class="ad-box ad-desktop">
     <ins class="adsbygoogle" style="display:inline-block;width:120px;height:728px" data-ad-client="ca-pub-4253419731329045" data-ad-slot="7123454389"></ins>
    </div>
    <div class="ad-box ad-mobile">
     <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-4253419731329045" data-ad-slot="7123454389"></ins>
    </div>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
   </aside>
  </div>
  <div th:replace="~{fragments/footer :: footer}"></div>
  <script th:src="@{/js/script.js}" defer></script>
 </body>
</html>