<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">
 <head>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4253419731329045" crossorigin="anonymous"></script>
  <link rel="canonical" th:href="${canonicalUrl}">
  <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
  <script>
        window.dataLayer = window.dataLayer || [];
        window.gtag = function () { dataLayer.push(arguments); };
        gtag('consent', 'default', {
            'wait_for_update': 500,
            'region': ['RO'],
            'ad_storage': 'denied',
            'analytics_storage': 'denied',
            'ad_user_data': 'denied',
            'ad_personalization': 'denied'
        });
        gtag('js', new Date());
        gtag('config', 'G-7Q2536ZKL2');
    </script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title th:text="${lesson.title}">Lesson</title>
  <link rel="stylesheet" th:href="@{/css/styles.css}">
  <style>
        body {
            background: #ffffff;
        }
    </style>
 </head>
 <body th:with="activeTopic='C-sharp', activeChapter='10.Colectii', activeLesson='1.Lista List_T_'">
  <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
  <div th:replace="~{fragments/nav :: nav}"></div>
  <div class="top-nav">
   <th:block th:each="topic : ${topics}"> <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}" th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a> </th:block>
  </div>
  <div class="layout">
   <div class="mobile-sidebar" id="mobileSidebar">
    <button class="close-btn" onclick="toggleSidebar()">✖</button>
    <ul class="chapter-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-title" onclick="toggleChapter(this)">
        <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
       </div>
       <ul class="lesson-list">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul>
      </li>
     </th:block>
    </ul>
   </div>
   <aside class="sidebar">
    <ul class="sidebar-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-toggle" onclick="toggleLessons(this)">
        <span th:text="${chapter.title}">Chapter</span>
       </div>
       <ul class="lesson-list hidden">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul>
      </li>
     </th:block>
    </ul>
   </aside>
   <main class="content">
    <div class="document-container">
     <h1 class="main-title">Compararea șirurilor de caractere</h1>
     <p class="paragraph">În limbajul C++ pot fi aplicate operații de comparare pentru șiruri.</p>
     <p class="paragraph">= &lt; &lt;= == != &lt;=&gt; ( Aceste operații compară doi obiecti de tip string sau un obiect string cu un literal de șir de caractere. În toate aceste operații, operanzii sunt comparați caracter cu caracter, până când este găsită o pereche de caractere diferite sau până când se ajunge la sfârșitul unuia sau ambilor operanzi.)</p>
     <p class="paragraph">Când o pereche de caractere este diferită, compararea codurilor numerice ale caracterelor determină care șir este „mai mic” sau „mai mare”. Dacă nu sunt găsite caractere diferite, dar șirurile au lungimi diferite, șirul mai scurt este considerat „mai mic”. Două șiruri sunt egale dacă au același număr de caractere și toate codurile caracterelor corespunzătoare sunt egale.</p>
     <p class="paragraph">Această metodă de comparare se numește și comparare lexicografică. Trebuie remarcat faptul că, întrucât se compară codurile numerice ale caracterelor, rezultatul depinde și de majuscule și minuscule.</p>
     <p class="paragraph">De exemplu, operatorul == returnează true dacă toate caracterele ambelor șiruri sunt egale:</p>
     <div class="code-inline">
      <pre><code>std::string&nbsp;s1&nbsp;{"hello"};<br>bool&nbsp;result&nbsp;{s1&nbsp;==&nbsp;"Hello"};&nbsp;//&nbsp;false&nbsp;-&nbsp;șirurile&nbsp;diferă&nbsp;ca&nbsp;registru<br>result&nbsp;=&nbsp;s1&nbsp;==&nbsp;"hello";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;true</code></pre>
     </div>
     <p class="paragraph">Pentru că „hello” și „Hello” diferă prin registrul primei litere, și codul caracterului este diferit, deci șirurile nu sunt egale.</p>
     <p class="paragraph">Un alt exemplu - operatorul &gt; (mai mare):</p>
     <ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-4253419731329045" data-ad-slot="8453761934"></ins>
     <script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
     <div class="code-inline">
      <pre><code>std::string&nbsp;s1&nbsp;{"helm"};<br>std::string&nbsp;s2&nbsp;{"hello"};<br>bool&nbsp;result&nbsp;{s1&nbsp;&gt;&nbsp;s2};&nbsp;//&nbsp;true</code></pre>
     </div>
     <p class="paragraph">În acest caz, condiția s1 &gt; s2 este adevărată, adică s1 este mai mare decât s2, deoarece primele trei caractere („hel”) sunt identice, dar al patrulea caracter din s1 („m”) urmează în alfabet după caracterul corespondent din s2 („l”), deci „m” este mai mare decât „l” (chiar dacă „hello” are mai multe caractere decât „helm”).</p>
     <p class="paragraph">Să luăm un mic program. De exemplu, avem un tablou de nume și vrem să le sortăm în ordine alfabetică:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>#include&nbsp;&lt;string&gt;<br><br>int&nbsp;main()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;people[]&nbsp;{"Tom",&nbsp;"Alice",&nbsp;"Sam",&nbsp;"Bob",&nbsp;"Kate"};<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;sortăm&nbsp;în&nbsp;ordine&nbsp;crescătoare<br>&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;sorted&nbsp;{};<br>&nbsp;&nbsp;&nbsp;&nbsp;do<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sorted&nbsp;=&nbsp;true;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;rămâne&nbsp;true&nbsp;dacă&nbsp;șirurile&nbsp;sunt&nbsp;sortate<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;temp;&nbsp;&nbsp;&nbsp;//&nbsp;variabilă&nbsp;pentru&nbsp;schimb&nbsp;de&nbsp;valori<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(unsigned&nbsp;i&nbsp;{1};&nbsp;i&nbsp;&lt;&nbsp;std::size(people);&nbsp;i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;dacă&nbsp;șirul&nbsp;anterior&nbsp;este&nbsp;mai&nbsp;mare&nbsp;decât&nbsp;cel&nbsp;următor<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(people[i-1]&nbsp;&gt;&nbsp;people[i])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;facem&nbsp;schimb&nbsp;de&nbsp;valori<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;people[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;people[i]&nbsp;=&nbsp;people[i-1];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;people[i-1]&nbsp;=&nbsp;temp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sorted&nbsp;=&nbsp;false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;while&nbsp;(!sorted);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;afișăm&nbsp;șirurile&nbsp;la&nbsp;consolă<br>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(const&nbsp;auto&nbsp;person:&nbsp;people)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;person&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">Aici este utilizată o sortare tip bubble sort, nu foarte rapidă, dar clară, care compară șirul anterior cu cel următor. Dacă primul este „mai mare” decât al doilea, valorile sunt schimbate printr-o variabilă intermediară temp. Pentru optimizare, a fost adăugată variabila sorted. De fiecare dată când se face un schimb, această variabilă este setată pe false, ceea ce înseamnă că bucla do-while trebuie reluată.</p>
     <p class="paragraph">Afișarea în consolă:</p>
     <div class="code-inline">
      <pre><code>Alice&nbsp;&nbsp;<br>Bob&nbsp;&nbsp;<br>Kate&nbsp;&nbsp;<br>Sam&nbsp;&nbsp;<br>Tom</code></pre>
     </div>
     <h2 class="subtitle">Funcția compare()</h2>
     <p class="paragraph">Pentru compararea șirurilor se poate folosi și funcția compare(). Se transmite un alt șir care se compară cu șirul curent. Funcția compare() returnează:</p>
     <ul class="enumeration">
      <li>0 dacă șirurile sunt egale</li>
      <li>un număr pozitiv dacă șirul curent este mai mare</li>
      <li>un număr negativ dacă șirul curent este mai mic</li>
     </ul>
     <p class="paragraph">Exemplu:</p>
     <div class="code-inline">
      <pre><code>std::string&nbsp;tom&nbsp;{"Tom"};<br>std::string&nbsp;person{"Tom"};<br>int&nbsp;result&nbsp;=&nbsp;tom.compare(person);<br>std::cout&nbsp;&lt;&lt;&nbsp;result&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;//&nbsp;0&nbsp;-&nbsp;șiruri&nbsp;egale</code></pre>
     </div>
     <p class="paragraph">Alt exemplu:</p>
     <div class="code-inline">
      <pre><code>std::string&nbsp;tom&nbsp;{"Tom"};<br>std::string&nbsp;bob{"Bob"};<br>std::string&nbsp;sam&nbsp;{"Sam"};<br><br>int&nbsp;result&nbsp;=&nbsp;sam.compare(bob);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;1&nbsp;-&nbsp;primul&nbsp;șir&nbsp;(sam)&nbsp;&gt;&nbsp;al&nbsp;doilea&nbsp;(bob)<br>std::cout&nbsp;&lt;&lt;&nbsp;result&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;&nbsp;&nbsp;//&nbsp;1<br><br>result&nbsp;=&nbsp;sam.compare(tom);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;-1&nbsp;-&nbsp;primul&nbsp;șir&nbsp;(sam)&nbsp;&lt;&nbsp;al&nbsp;doilea&nbsp;(tom)<br>std::cout&nbsp;&lt;&lt;&nbsp;result&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;&nbsp;&nbsp;//&nbsp;-1</code></pre>
     </div>
     <p class="paragraph">În acest caz, „Sam” este mai mare decât „Bob”, deci funcția returnează 1. În comparația cu „Tom”, „Sam” este mai mic, deci rezultatul este -1.</p>
     <h2 class="subtitle">Versiuni ale funcției compare()</h2>
     <p class="paragraph">Una dintre formele funcției acceptă trei parametri:</p>
     <div class="code-inline">
      <pre><code>int&nbsp;compare(size_t&nbsp;_Off,&nbsp;size_t&nbsp;_Nx,&nbsp;const&nbsp;std::string&nbsp;&amp;_Right)&nbsp;const</code></pre>
     </div>
     <ul class="enumeration">
      <li>Primul parametru: indexul primului caracter din șirul curent de la care începe subșirul</li>
      <li>Al doilea: lungimea subșirului</li>
      <li>Al treilea: șirul cu care se compară subșirul</li>
     </ul>
     <p class="paragraph">Unde putem folosi asta? De exemplu, vrem să găsim indexul de la care un șir apare în altul:</p>
     <script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>#include&nbsp;&lt;string&gt;<br><br>int&nbsp;main()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;text&nbsp;{"Hello&nbsp;world!"};<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;word&nbsp;{"world"};<br>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(unsigned&nbsp;i{};&nbsp;i&nbsp;&lt;&nbsp;text.length()&nbsp;-&nbsp;word.length()&nbsp;+&nbsp;1;&nbsp;i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(text.compare(i,&nbsp;word.length(),&nbsp;word)&nbsp;==&nbsp;0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"text&nbsp;contains&nbsp;"&nbsp;&lt;&lt;&nbsp;word&nbsp;&lt;&lt;&nbsp;"&nbsp;at&nbsp;index&nbsp;"&nbsp;&lt;&lt;&nbsp;i&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">Aici încercăm să găsim șirul word („world”) în șirul text („Hello world!”). În buclă trecem prin caracterele șirului text, până la indexul text.length() - word.length() + 1.</p>
     <p class="paragraph">Comparația se face cu:</p>
     <div class="code-inline">
      <pre><code>if&nbsp;(text.compare(i,&nbsp;word.length(),&nbsp;word)&nbsp;==&nbsp;0)</code></pre>
     </div>
     <p class="paragraph">Adică din text comparăm un subșir care începe de la indexul i și are word.length() caractere, cu șirul word. Dacă este găsită egalitate, se afișează indexul i.</p>
     <p class="paragraph">Ieșire:</p>
     <div class="code-inline">
      <pre><code>text&nbsp;contains&nbsp;world&nbsp;at&nbsp;index&nbsp;6</code></pre>
     </div>
     <h2 class="subtitle">Compararea a două subșiruri</h2>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>#include&nbsp;&lt;string&gt;<br><br>int&nbsp;main()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;text&nbsp;{"Hello&nbsp;world!"};<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;word&nbsp;{"world"};<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;size&nbsp;{2};&nbsp;//&nbsp;număr&nbsp;de&nbsp;caractere&nbsp;din&nbsp;al&nbsp;doilea&nbsp;șir<br>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(unsigned&nbsp;i{};&nbsp;i&nbsp;&lt;&nbsp;text.length()&nbsp;-&nbsp;size&nbsp;+&nbsp;1;&nbsp;i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(text.compare(i,&nbsp;size,&nbsp;word,&nbsp;1,&nbsp;size)&nbsp;==&nbsp;0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"text&nbsp;contains&nbsp;substring&nbsp;at&nbsp;index&nbsp;"&nbsp;&lt;&lt;&nbsp;i&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">Aici algoritmul este același. Doar că acum comparăm un subșir din word de lungime size, începând de la indexul 1 (adică subșirul „or”), cu un subșir din text.</p>
     <p class="paragraph">Ieșire:</p>
     <div class="code-inline">
      <pre><code>text&nbsp;contains&nbsp;substring&nbsp;at&nbsp;index&nbsp;7</code></pre>
     </div>
    </div>
    <div class="lesson-navigation">
     <th:block th:if="${previousLesson != null}"> <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția anterioară</a> </th:block> <th:block th:if="${nextLesson != null}"> <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția următoare →</a> </th:block>
    </div>
    <div class="discord-banner-section">
     <div class="discord-banner-container">
      <a href="https://discord.com/channels/1168639076098920578/1168646757551443979" target="_blank"> <img th:src="@{/images/cpp_discord.png}" alt="Discord Banner" class="discord-banner-image"> </a>
     </div>
    </div>
   </main>
   <aside class="ad-section">
    <div class="ad-box ad-desktop">
     <ins class="adsbygoogle" style="display:inline-block;width:120px;height:728px" data-ad-client="ca-pub-4253419731329045" data-ad-slot="7123454389"></ins>
    </div>
    <div class="ad-box ad-mobile">
     <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-4253419731329045" data-ad-slot="7123454389"></ins>
    </div>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
   </aside>
  </div>
  <div th:replace="~{fragments/footer :: footer}"></div>
  <script th:src="@{/js/script.js}" defer></script>
 </body>
</html>