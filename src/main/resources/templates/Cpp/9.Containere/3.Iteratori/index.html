<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">
 <head>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4253419731329045" crossorigin="anonymous"></script>
  <link rel="canonical" th:href="${canonicalUrl}">
  <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
  <script>
        window.dataLayer = window.dataLayer || [];
        window.gtag = function () { dataLayer.push(arguments); };
        gtag('consent', 'default', {
            'wait_for_update': 500,
            'region': ['RO'],
            'ad_storage': 'denied',
            'analytics_storage': 'denied',
            'ad_user_data': 'denied',
            'ad_personalization': 'denied'
        });
        gtag('js', new Date());
        gtag('config', 'G-7Q2536ZKL2');
    </script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title th:text="${lesson.title}">Lesson</title>
  <link rel="stylesheet" th:href="@{/css/styles.css}">
  <style>
        body {
            background: #ffffff;
        }
    </style>
 </head>
 <body th:with="activeTopic='C-sharp', activeChapter='10.Colectii', activeLesson='1.Lista List_T_'">
  <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
  <div th:replace="~{fragments/nav :: nav}"></div>
  <div class="top-nav">
   <th:block th:each="topic : ${topics}"> <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}" th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a> </th:block>
  </div>
  <div class="layout">
   <div class="mobile-sidebar" id="mobileSidebar">
    <button class="close-btn" onclick="toggleSidebar()">✖</button>
    <ul class="chapter-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-title" onclick="toggleChapter(this)">
        <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
       </div>
       <ul class="lesson-list">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul>
      </li>
     </th:block>
    </ul>
   </div>
   <aside class="sidebar">
    <ul class="sidebar-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-toggle" onclick="toggleLessons(this)">
        <span th:text="${chapter.title}">Chapter</span>
       </div>
       <ul class="lesson-list hidden">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul>
      </li>
     </th:block>
    </ul>
   </aside>
   <main class="content">
    <div class="document-container">
     <h1 class="main-title">Iteratorii</h1>
     <p class="paragraph">Iteratorii oferă acces la elementele unui container și reprezintă o implementare a tiparului binecunoscut în programarea orientată pe obiecte numit „Iterator”. Cu ajutorul iteratorilor este foarte comod să parcurgem elementele. În C++, iteratorii oferă o interfață comună pentru diferite tipuri de containere, ceea ce permite utilizarea unei abordări unificate pentru accesul la elementele acestora.</p>
     <p class="paragraph">Este important de menționat că doar containerele au iteratori. Adaptatorii de containere – tipurile std::stack, std::queue și std::priority_queue – nu dispun de iteratori.</p>
     <p class="paragraph">Un iterator este descris de tipul iterator. Pentru fiecare container, tipul concret de iterator va fi diferit. De exemplu, iteratorul pentru un list&lt;int&gt; este de tipul list&lt;int&gt;::iterator, iar pentru un vector&lt;int&gt; este vector&lt;int&gt;::iterator și așa mai departe. Totuși, funcționalitatea de bază pentru accesarea elementelor este similară.</p>
     <p class="paragraph">Pentru obținerea iteratorilor, containerele din C++ dispun de funcțiile begin() și end(). Funcția begin() returnează un iterator care indică spre primul element al containerului (dacă există elemente). Funcția end() returnează un iterator care indică poziția de după ultimul element – practic, finalul containerului. Dacă containerul este gol, atunci begin() și end() vor returna același iterator. Dacă begin este diferit de end, atunci containerul are cel puțin un element.</p>
     <p class="paragraph">Ambele funcții returnează un iterator specific tipului containerului:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>#include&nbsp;&lt;vector&gt;<br>&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt;&nbsp;numbers{&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt;::iterator&nbsp;iter&nbsp;=&nbsp;numbers.begin();&nbsp;&nbsp;//&nbsp;obținem&nbsp;iteratorul<br>}</code></pre>
     </div>
     <p class="paragraph">În acest exemplu, este creat un vector de tip vector&lt;int&gt; ce conține valorile {1, 2, 3, 4}. Cu ajutorul metodei begin() obținem un iterator pentru acest container. Acest iterator indică către primul element.</p>
     <ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-4253419731329045" data-ad-slot="8453761934"></ins>
     <script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
     <h2 class="subtitle">Operații cu iteratori:</h2>
     <ul class="enumeration">
      <li>*iter: obține elementul indicat de iterator</li>
      <li>++iter: avansează iteratorul către următorul element</li>
      <li>--iter: deplasează iteratorul înapoi (nu este suportat de forward_list)</li>
      <li>iter1 == iter2: cei doi iteratori sunt egali dacă indică același element</li>
      <li>iter1 != iter2: iteratorii sunt diferiți dacă indică elemente diferite</li>
      <li>iter + n: returnează un iterator deplasat cu n poziții înainte</li>
      <li>iter - n: returnează un iterator deplasat cu n poziții înapoi</li>
      <li>iter += n: deplasează iteratorul cu n poziții înainte</li>
      <li>iter -= n: deplasează iteratorul cu n poziții înapoi</li>
      <li>iter1 - iter2: returnează numărul de poziții dintre cei doi iteratori</li>
      <li>&gt;, &gt;=, &lt;, &lt;=: comparații – un iterator este „mai mare” dacă este mai aproape de sfârșitul containerului</li>
     </ul>
     <p class="paragraph">Este de reținut că nu toți iteratorii suportă toate aceste operații.</p>
     <script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
     <p class="paragraph">Iteratorii pentru tipurile std::forward_list, std::unordered_set și std::unordered_map nu acceptă operațiile --, -= și -. (deoarece std::forward_list este o listă înlănțuită unidirecțional, unde fiecare element stochează un pointer doar către elementul următor)</p>
     <p class="paragraph">Iteratorii pentru tipul std::list acceptă operațiile de incrementare și decrementare, dar nu sunt acceptate operațiile +=, -=, + și -. Aceleași limitări le au și iteratorii containerelor std::map și std::set.</p>
     <p class="paragraph">Operațiile +=, -=, +, -, &lt;, &lt;=, &gt;, &gt;= și &lt;=&gt; sunt acceptate doar de iteratorii cu acces aleatoriu (iteratorii containerelor std::vector, array și deque)</p>
     <h2 class="subtitle">Obținerea și modificarea elementului unui container</h2>
     <p class="paragraph">Deoarece iteratorul, în esență, reprezintă un pointer către un anumit element, prin acest pointer putem obține elementul curent indicat de iterator și îi putem modifica valoarea:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>#include&nbsp;&lt;vector&gt;<br>&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt;&nbsp;numbers{&nbsp;1,2,3,4&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;auto&nbsp;iter&nbsp;{&nbsp;numbers.begin()&nbsp;};&nbsp;&nbsp;//&nbsp;obținem&nbsp;iteratorul<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;obținem&nbsp;elementul&nbsp;indicat&nbsp;de&nbsp;iterator<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;*iter&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;1<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;modificăm&nbsp;elementul<br>&nbsp;&nbsp;&nbsp;&nbsp;*iter&nbsp;=&nbsp;125;<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;verificăm&nbsp;modificarea&nbsp;elementului<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;numbers[0]&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;125<br>}</code></pre>
     </div>
     <p class="paragraph">După obținerea iteratorului, acesta va indica spre primul element al containerului. Astfel, expresia *iter va returna primul element al vectorului.</p>
     <p class="paragraph">Adunând sau scăzând o anumită valoare, putem deplasa iteratorul înainte sau înapoi cu un anumit număr de elemente:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>#include&nbsp;&lt;vector&gt;<br>&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt;&nbsp;numbers{&nbsp;10,&nbsp;20,&nbsp;30,&nbsp;40&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;auto&nbsp;iter&nbsp;{&nbsp;numbers.begin()&nbsp;};&nbsp;&nbsp;//&nbsp;obținem&nbsp;iteratorul<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;trecem&nbsp;un&nbsp;element&nbsp;înainte,&nbsp;spre&nbsp;al&nbsp;doilea&nbsp;element<br>&nbsp;&nbsp;&nbsp;&nbsp;++iter;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;*iter&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;20<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;trecem&nbsp;două&nbsp;elemente&nbsp;înainte,&nbsp;spre&nbsp;al&nbsp;patrulea&nbsp;element<br>&nbsp;&nbsp;&nbsp;&nbsp;iter&nbsp;+=&nbsp;2;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;*iter&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;40<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;mergem&nbsp;înapoi&nbsp;cu&nbsp;trei&nbsp;elemente,&nbsp;spre&nbsp;primul&nbsp;element<br>&nbsp;&nbsp;&nbsp;&nbsp;iter&nbsp;=&nbsp;iter&nbsp;-&nbsp;3;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;*iter&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;10<br>}</code></pre>
     </div>
     <p class="paragraph">Reamintim că nu toate operațiile sunt suportate de toți iteratorii tuturor containerelor.</p>
     <h2 class="subtitle">Parcurgerea containerului</h2>
     <p class="paragraph">De exemplu, putem folosi iteratorii pentru a parcurge elementele unui vector:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>#include&nbsp;&lt;vector&gt;<br>&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt;&nbsp;numbers{&nbsp;10,&nbsp;20,&nbsp;30,&nbsp;40&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;auto&nbsp;iter&nbsp;{&nbsp;numbers.begin()&nbsp;};&nbsp;&nbsp;//&nbsp;obținem&nbsp;iteratorul<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;while(iter&nbsp;!=&nbsp;numbers.end())&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;până&nbsp;ajungem&nbsp;la&nbsp;final<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;*iter&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;//&nbsp;obținem&nbsp;elementele&nbsp;prin&nbsp;iterator<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++iter;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;ne&nbsp;deplasăm&nbsp;înainte&nbsp;cu&nbsp;un&nbsp;element<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;exemplu&nbsp;echivalent&nbsp;cu&nbsp;bucla&nbsp;for<br>&nbsp;&nbsp;&nbsp;&nbsp;for(auto&nbsp;start&nbsp;{numbers.begin()};&nbsp;start&nbsp;!=&nbsp;numbers.end();&nbsp;start++)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;*start&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">Când lucrăm cu containere, trebuie avut în vedere că adăugarea sau ștergerea elementelor dintr-un container poate face ca toți iteratorii curenți pentru acel container, precum și referințele și pointerii către elementele sale, să devină invalizi. Prin urmare, după adăugarea sau eliminarea elementelor din container, în general nu ar trebui să se mai folosească iteratorii existenți pentru acel container.</p>
     <h2 class="subtitle">Iteratori constanți</h2>
     <p class="paragraph">Dacă un container este declarat ca constant, atunci pentru a accesa elementele acestuia pot fi folosiți doar iteratori constanți (tipul const_iterator). Un astfel de iterator permite citirea elementelor, dar nu și modificarea acestora:</p>
     <div class="code-inline">
      <pre><code>const&nbsp;vector&lt;int&gt;&nbsp;numbers{1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5};<br>for(auto&nbsp;iter&nbsp;{numbers.begin()};&nbsp;iter&nbsp;!=&nbsp;numbers.end();&nbsp;++iter)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;*iter&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;acest&nbsp;lucru&nbsp;nu&nbsp;este&nbsp;permis<br>&nbsp;&nbsp;&nbsp;&nbsp;//*iter&nbsp;=&nbsp;(*iter)&nbsp;*&nbsp;(*iter);<br>}</code></pre>
     </div>
     <p class="paragraph">În acest caz, iteratorul iter va avea tipul std::vector&lt;int&gt;::const_iterator.</p>
     <p class="paragraph">Pentru a obține un iterator constant se pot folosi funcțiile cbegin() și cend(). Chiar dacă containerul nu este constant, dar la parcurgerea lui se utilizează un iterator constant, atunci valorile elementelor nu pot fi modificate:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>#include&nbsp;&lt;vector&gt;<br>&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt;&nbsp;numbers&nbsp;{&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(auto&nbsp;iter&nbsp;{numbers.cbegin()};&nbsp;iter&nbsp;!=&nbsp;numbers.cend();&nbsp;++iter)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;*iter&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;modificarea&nbsp;nu&nbsp;este&nbsp;permisă<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//*iter&nbsp;=&nbsp;(*iter)&nbsp;*&nbsp;(*iter);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">Este de menționat că pentru tipurile std::set și std::map sunt disponibili doar iteratori constanți.</p>
     <h2 class="subtitle">Iteratori inversați</h2>
     <p class="paragraph">Iteratorii inversați permit parcurgerea elementelor containerului în ordine inversă. Pentru obținerea unui iterator inversat se folosesc funcțiile rbegin() și rend(), iar tipul iteratorului este reverse_iterator:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>#include&nbsp;&lt;vector&gt;<br>&nbsp;&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt;&nbsp;numbers&nbsp;{&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(auto&nbsp;iter&nbsp;{numbers.rbegin()};&nbsp;iter&nbsp;!=&nbsp;numbers.rend();&nbsp;++iter)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;*iter&nbsp;&lt;&lt;&nbsp;"\t";<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;std::endl;<br>}</code></pre>
     </div>
     <p class="paragraph">În acest caz, iteratorul este de tip std::vector&lt;int&gt;::reverse_iterator. Ieșirea în consolă:</p>
     <div class="code-inline">
      <pre><code>5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</code></pre>
     </div>
     <p class="paragraph">Pentru a proteja valorile containerului împotriva modificării, putem folosi un iterator inversat constant, reprezentat prin tipul const_reverse_iterator și obținut cu ajutorul funcțiilor crbegin() și crend():</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>#include&nbsp;&lt;vector&gt;<br>&nbsp;&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt;&nbsp;numbers&nbsp;{&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(auto&nbsp;iter&nbsp;{numbers.crbegin()};&nbsp;iter&nbsp;!=&nbsp;numbers.crend();&nbsp;++iter)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;*iter&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;modificarea&nbsp;nu&nbsp;este&nbsp;permisă<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//*iter&nbsp;=&nbsp;(*iter)&nbsp;*&nbsp;(*iter);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <h2 class="subtitle">Iteratori pentru tablouri</h2>
     <p class="paragraph">Pentru tablouri (array-uri) în C++ există suport pentru iteratori. În biblioteca standard C++ sunt definite funcțiile std::begin() (returnează iteratorul de început) și std::end() (returnează iteratorul de final):</p>
     <div class="code-inline">
      <pre><code>int&nbsp;data[]{4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8};<br>//&nbsp;obținem&nbsp;iteratorul&nbsp;de&nbsp;început<br>auto&nbsp;iter&nbsp;=&nbsp;std::begin(data);<br>//&nbsp;obținem&nbsp;iteratorul&nbsp;de&nbsp;final<br>auto&nbsp;end&nbsp;=&nbsp;std::end(data);</code></pre>
     </div>
     <p class="paragraph">La fel ca în cazul containerelor, și tablourile pot fi parcurse folosind iteratori:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>&nbsp;&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;data[]{4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8};<br>&nbsp;&nbsp;&nbsp;&nbsp;for(auto&nbsp;iter&nbsp;{std::begin(data)};&nbsp;iter&nbsp;!=&nbsp;std::end(data);&nbsp;iter++)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;*iter&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">Totuși, parcurgerea unui tablou se poate realiza și în alte moduri – prin indici sau pointeri simpli. Însă iteratorii pot fi utili atunci când manipulăm containere. De exemplu, funcția insert() disponibilă în unele containere permite adăugarea unei porțiuni dintr-un alt container. Pentru a delimita această porțiune pot fi folosiți iteratorii. Astfel, putem adăuga într-un container (de exemplu, un vector) o porțiune dintr-un alt container:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>#include&nbsp;&lt;vector&gt;<br>&nbsp;&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;data[]{4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8};<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;int&gt;&nbsp;numbers&nbsp;{&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;adăugăm&nbsp;la&nbsp;sfârșitul&nbsp;vectorului&nbsp;numbers&nbsp;elementele&nbsp;de&nbsp;la&nbsp;al&nbsp;doilea&nbsp;la&nbsp;penultimul&nbsp;din&nbsp;data<br>&nbsp;&nbsp;&nbsp;&nbsp;numbers.insert(numbers.end(),&nbsp;std::begin(data)&nbsp;+&nbsp;1,&nbsp;std::end(data)&nbsp;-&nbsp;1);<br>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(auto&nbsp;iter&nbsp;{numbers.begin()};&nbsp;iter&nbsp;!=&nbsp;numbers.end();&nbsp;++iter)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;*iter&nbsp;&lt;&lt;&nbsp;"\t";<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;std::endl;<br>}</code></pre>
     </div>
     <p class="paragraph">Aici linia:</p>
     <div class="code-inline">
      <pre><code>numbers.insert(numbers.end(),&nbsp;std::begin(data)&nbsp;+&nbsp;1,&nbsp;std::end(data)-1);</code></pre>
     </div>
     <p class="paragraph">Adaugă în vectorul numbers, începând de la poziția indicată de numbers.end() (adică la sfârșit), elementele din intervalul definit de std::begin(data) + 1 (al doilea element) și std::end(data) - 1 (penultimul element). Ieșirea în consolă:</p>
     <div class="code-inline">
      <pre><code>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7</code></pre>
     </div>
    </div>
    <div class="lesson-navigation">
     <th:block th:if="${previousLesson != null}"> <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția anterioară</a> </th:block> <th:block th:if="${nextLesson != null}"> <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția următoare →</a> </th:block>
    </div>
    <div class="discord-banner-section">
     <div class="discord-banner-container">
      <a href="https://discord.com/channels/1168639076098920578/1168646757551443979" target="_blank"> <img th:src="@{/images/cpp_discord.png}" alt="Discord Banner" class="discord-banner-image"> </a>
     </div>
    </div>
   </main>
   <aside class="ad-section">
    <div class="ad-box ad-desktop">
     <ins class="adsbygoogle" style="display:inline-block;width:120px;height:728px" data-ad-client="ca-pub-4253419731329045" data-ad-slot="7123454389"></ins>
    </div>
    <div class="ad-box ad-mobile">
     <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-4253419731329045" data-ad-slot="7123454389"></ins>
    </div>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
   </aside>
  </div>
  <div th:replace="~{fragments/footer :: footer}"></div>
  <script th:src="@{/js/script.js}" defer></script>
 </body>
</html>