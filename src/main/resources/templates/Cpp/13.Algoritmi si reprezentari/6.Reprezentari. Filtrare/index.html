<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">

<head>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4253419731329045"
        crossorigin="anonymous"></script>

    <link rel="canonical" th:href="${canonicalUrl}" />
    <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        window.gtag = function () { dataLayer.push(arguments); };
        gtag('consent', 'default', {
            'wait_for_update': 500,
            'region': ['RO'],
            'ad_storage': 'denied',
            'analytics_storage': 'denied',
            'ad_user_data': 'denied',
            'ad_personalization': 'denied'
        });
        gtag('js', new Date());
        gtag('config', 'G-7Q2536ZKL2');
    </script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title th:text="${lesson.title}">Lesson</title>
    <link rel="stylesheet" th:href="@{/css/styles.css}">
    <style>
        body {
            background: #ffffff;
        }
    </style>
</head>

<body th:with="activeTopic='C-sharp', activeChapter='10.Colectii', activeLesson='1.Lista List_T_'">
    <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
    <div th:replace="~{fragments/nav :: nav}"></div>
    <div class="top-nav">
        <th:block th:each="topic : ${topics}">
            <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}"
                th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a>
        </th:block>
    </div>
    <div class="layout">
        <div class="mobile-sidebar" id="mobileSidebar">
            <button class="close-btn" onclick="toggleSidebar()">✖</button>
            <ul class="chapter-list">
                <th:block th:each="chapter : ${chapters}">
                    <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
                        <div class="chapter-title" onclick="toggleChapter(this)">
                            <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
                        </div>
                        <ul class="lesson-list">
                            <th:block th:each="lesson : ${chapter.lessons}">
                                <li><a th:href="@{'/lectii/' +
${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}"
                                        th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
                            </th:block>
                        </ul>
                    </li>
                </th:block>
            </ul>
        </div>
        <aside class="sidebar">
            <ul class="sidebar-list">
                <th:block th:each="chapter : ${chapters}">
                    <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
                        <div class="chapter-toggle" onclick="toggleLessons(this)">
                            <span th:text="${chapter.title}">Chapter</span>
                        </div>
                        <ul class="lesson-list hidden">
                            <th:block th:each="lesson : ${chapter.lessons}">
                                <li><a th:href="@{'/lectii/' +
${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}"
                                        th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
                            </th:block>
                        </ul>
                    </li>
                </th:block>
            </ul>
        </aside>
        <main class="content">
            <div class="document-container">

<h1 class="main-title">Reprezentări - Filtrare</h1>
<p class="paragraph">O reprezentare sau view este un interval ușor care face referire la elemente, dar nu le deține. Reprezentările sunt, de obicei, bazate pe alte intervale și oferă o metodă specifică de a lucra cu acest interval, cum ar fi transformarea sau filtrarea. Există un container care stochează efectiv elementele și o reprezentare care face referire la aceste elemente.</p>
<p class="paragraph">Reprezentările sunt mai eficiente din punct de vedere al performanței decât intervalele standard bazate pe iteratori, deoarece reprezentarea nu deține elementele la care face referire, astfel încât nu trebuie să facă o copie a acestora. Prin urmare, se pot crea reprezentări fără pierderi de performanță.</p>
<p class="paragraph">Pentru a crea reprezentări se folosesc adaptatori de intervale (range adapter). Există două moduri de a defini o reprezentare:</p>
<ul class="enumeration">
<li>Utilizarea constructorului de reprezentare std::ranges::xxx_view, unde xxx este numele reprezentării:</li>
</ul>
<div class="code-inline"><pre><code>auto&nbsp;view&nbsp;=&nbsp;std::ranges::xxx_view{&nbsp;range,&nbsp;args&nbsp;}&nbsp;//&nbsp;constructorul&nbsp;de&nbsp;reprezentare</code></pre></div>
<p class="paragraph">Primul parametru este containerul pentru care se creează reprezentarea, iar al doilea parametru definește funcția aplicată pentru crearea reprezentării.</p>
<ul class="enumeration">
<li>Utilizarea operatorului | pe container și funcția std::views::xxx, unde xxx este numele reprezentării:</li>
</ul>
<div class="code-inline"><pre><code>auto&nbsp;view&nbsp;=&nbsp;range&nbsp;|&nbsp;std::views::xxx(args)</code></pre></div>
<p class="paragraph">Aici, range este și el un container, iar funcția std::views::xxx() primește un parametru care definește funcția utilizată pentru crearea reprezentării.</p>
<h2 class="subtitle">Filtrare</h2>
<p class="paragraph">Pentru filtrare se folosește reprezentarea std::ranges::filter_view. Al doilea parametru al constructorului reprezintă condiția – o funcție care primește un obiect și returnează un rezultat de tip bool: true dacă obiectul satisface condiția și false dacă nu o satisface.</p>
<p class="paragraph">De exemplu, să filtrăm elementele unui vector:</p>
<div class="code-inline"><pre><code>#include&nbsp;&lt;iostream&gt;<br>#include&nbsp;&lt;vector&gt;<br>#include&nbsp;&lt;ranges&gt;<br><br>class&nbsp;Person<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;Person(std::string&nbsp;name,&nbsp;unsigned&nbsp;age)&nbsp;:&nbsp;name{name},&nbsp;age{age}&nbsp;{}<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;getName()&nbsp;const&nbsp;{&nbsp;return&nbsp;name;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;getAge()&nbsp;const&nbsp;{&nbsp;return&nbsp;age;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;print()&nbsp;const&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;name&nbsp;&lt;&lt;&nbsp;&quot;\t&quot;&nbsp;&lt;&lt;&nbsp;age&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>private:<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;name;<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;age;<br>};<br><br>bool&nbsp;ageMoreThan33(const&nbsp;Person&amp;&nbsp;person)&nbsp;<br>{&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;person.getAge()&nbsp;&gt;&nbsp;33;&nbsp;<br>}<br><br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Person&gt;&nbsp;people&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person{&quot;Tom&quot;,&nbsp;38},&nbsp;Person{&quot;Kate&quot;,&nbsp;31},&nbsp;Person{&quot;Bob&quot;,&nbsp;42},&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person{&quot;Alice&quot;,&nbsp;34},&nbsp;Person{&quot;Sam&quot;,&nbsp;25}<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;auto&nbsp;filter_view&nbsp;=&nbsp;std::ranges::filter_view{people,&nbsp;ageMoreThan33};<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(const&nbsp;auto&amp;&nbsp;person&nbsp;:&nbsp;filter_view)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;person.print();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</code></pre></div>
<p class="paragraph">În acest exemplu, vectorul stochează obiecte de tip Person, fiecare având un nume și o vârstă. Folosind std::ranges::filter_view, obținem toate obiectele Person din vectorul people care au vârsta mai mare de 33:</p>
<div class="code-inline"><pre><code>auto&nbsp;filter_view&nbsp;=&nbsp;std::ranges::filter_view{people,&nbsp;ageMoreThan33};</code></pre></div>
<p class="paragraph">Funcția ageMoreThan33() este folosită pentru a verifica dacă vârsta este mai mare de 33. Se putea folosi și un lambda în locul acestei funcții. Rezultatul filtrării va fi un interval de obiecte Person care îndeplinesc această condiție. Programul va afișa:</p>
<div class="code-inline"><pre><code>Tom&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;38<br>Bob&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;42<br>Alice&nbsp;&nbsp;&nbsp;34</code></pre></div>
<p class="paragraph">Aceleași rezultate se pot obține folosind un lambda pentru condiție:</p>
<div class="code-inline"><pre><code>std::vector&lt;Person&gt;&nbsp;people&nbsp;<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;Person{&quot;Tom&quot;,&nbsp;38},&nbsp;Person{&quot;Kate&quot;,&nbsp;31},&nbsp;Person{&quot;Bob&quot;,&nbsp;42},&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;Person{&quot;Alice&quot;,&nbsp;34},&nbsp;Person{&quot;Sam&quot;,&nbsp;25}<br>};<br><br>auto&nbsp;ageMoreThan33&nbsp;=&nbsp;[](const&nbsp;Person&amp;&nbsp;p)&nbsp;{&nbsp;return&nbsp;p.getAge()&nbsp;&gt;&nbsp;33;&nbsp;};<br>auto&nbsp;filter_view&nbsp;=&nbsp;std::ranges::filter_view{people,&nbsp;ageMoreThan33};<br>&nbsp;<br>for&nbsp;(const&nbsp;auto&amp;&nbsp;person&nbsp;:&nbsp;filter_view)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;person.print();<br>}</code></pre></div>
<p class="paragraph">Al doilea mod de a crea o reprezentare pentru filtrare folosește funcția std::views::filter(), la care se transmite o funcție de filtrare.</p>
<div class="code-inline"><pre><code>#include&nbsp;&lt;iostream&gt;<br>#include&nbsp;&lt;vector&gt;<br>#include&nbsp;&lt;ranges&gt;<br><br>class&nbsp;Person<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;Person(std::string&nbsp;name,&nbsp;unsigned&nbsp;age)&nbsp;:&nbsp;name{name},&nbsp;age{age}&nbsp;{}<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;getName()&nbsp;const&nbsp;{&nbsp;return&nbsp;name;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;getAge()&nbsp;const&nbsp;{&nbsp;return&nbsp;age;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;print()&nbsp;const&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;name&nbsp;&lt;&lt;&nbsp;&quot;\t&quot;&nbsp;&lt;&lt;&nbsp;age&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>private:<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;name;<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;age;<br>};<br><br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Person&gt;&nbsp;people&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person{&quot;Tom&quot;,&nbsp;38},&nbsp;Person{&quot;Kate&quot;,&nbsp;31},&nbsp;Person{&quot;Bob&quot;,&nbsp;42},&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person{&quot;Alice&quot;,&nbsp;34},&nbsp;Person{&quot;Sam&quot;,&nbsp;25}<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br><br>&nbsp;&nbsp;&nbsp;&nbsp;auto&nbsp;ageMoreThan33&nbsp;=&nbsp;[](const&nbsp;Person&amp;&nbsp;p)&nbsp;{&nbsp;return&nbsp;p.getAge()&nbsp;&gt;&nbsp;33;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;auto&nbsp;filter_view&nbsp;=&nbsp;people&nbsp;|&nbsp;std::views::filter(ageMoreThan33);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(const&nbsp;auto&amp;&nbsp;person&nbsp;:&nbsp;filter_view)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;person.print();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</code></pre></div>
<p class="paragraph">Pentru a crea reprezentarea pentru filtrare, folosim operatorul |, unde operanzii sunt containerul de date și funcția std::views::filter:</p>
<div class="code-inline"><pre><code>auto&nbsp;filter_view&nbsp;=&nbsp;people&nbsp;|&nbsp;std::views::filter(ageMoreThan33);</code></pre></div>
<p class="paragraph">Rezultatul va fi același ca în cazul folosirii constructorului de reprezentare.</p>
            </div>
        </main>
        <aside class="ad-section">
            <div class="ad-box">
                <p>Google Ad Here</p>
            </div>
            <div class="ad-box">
                <p>Promo: SQL Beginner Guide</p>
            </div>
        </aside>
    </div>
    <div class="lesson-navigation">
        <th:block th:if="${previousLesson != null}">
            <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția
                anterioară</a>
        </th:block>
        <th:block th:if="${nextLesson != null}">
            <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția
                următoare →</a>
        </th:block>
    </div>
    <div th:replace="~{fragments/footer :: footer}"></div>
    <script th:src="@{/js/script.js}" defer></script>
</body>
</html>
