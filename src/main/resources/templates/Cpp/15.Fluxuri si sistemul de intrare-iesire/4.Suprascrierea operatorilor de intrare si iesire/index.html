<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">
 <head>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4253419731329045" crossorigin="anonymous"></script>
  <link rel="canonical" th:href="${canonicalUrl}">
  <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
  <script>
        window.dataLayer = window.dataLayer || [];
        window.gtag = function () { dataLayer.push(arguments); };
        gtag('consent', 'default', {
            'wait_for_update': 500,
            'region': ['RO'],
            'ad_storage': 'denied',
            'analytics_storage': 'denied',
            'ad_user_data': 'denied',
            'ad_personalization': 'denied'
        });
        gtag('js', new Date());
        gtag('config', 'G-7Q2536ZKL2');
    </script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title th:text="${lesson.title}">Lesson</title>
  <link rel="stylesheet" th:href="@{/css/styles.css}">
  <style>
        body {
            background: #ffffff;
        }
    </style>
 </head>
 <body th:with="activeTopic='C-sharp', activeChapter='10.Colectii', activeLesson='1.Lista List_T_'">
  <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
  <div th:replace="~{fragments/nav :: nav}"></div>
  <div class="top-nav">
   <th:block th:each="topic : ${topics}"> <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}" th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a> </th:block>
  </div>
  <div class="layout">
   <div class="mobile-sidebar" id="mobileSidebar">
    <button class="close-btn" onclick="toggleSidebar()">✖</button>
    <ul class="chapter-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-title" onclick="toggleChapter(this)">
        <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
       </div>
       <ul class="lesson-list">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul>
      </li>
     </th:block>
    </ul>
   </div>
   <aside class="sidebar">
    <ul class="sidebar-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-toggle" onclick="toggleLessons(this)">
        <span th:text="${chapter.title}">Chapter</span>
       </div>
       <ul class="lesson-list hidden">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul>
      </li>
     </th:block>
    </ul>
   </aside>
   <main class="content">
    <div class="document-container">
     <h1 class="main-title">Suprascrierea operatorilor de intrare și ieșire</h1>
     <p class="paragraph">Operatorii de intrare &gt;&gt; și ieșire &lt;&lt; funcționează perfect pentru tipurile primitive de date, cum ar fi int sau double. În schimb, pentru a-i utiliza cu obiecte de tipul claselor, este necesar să suprascriem acești operatori.</p>
     <h2 class="subtitle">Operatorul &lt;&lt;</h2>
     <p class="paragraph">Fluxul standard de ieșire cout are tipul std::ostream. De aceea, primul parametru (operandul din stânga) al operației &lt;&lt; reprezintă o referință la un obiect non-constant de tip ostream. Acest obiect nu trebuie să fie constant, deoarece scrierea în flux modifică starea sa. De asemenea, parametrul reprezintă o referință, deoarece nu se poate copia un obiect de tipul ostream.</p>
     <p class="paragraph">Al doilea parametru al operatorului este definit ca o referință la un obiect constant al clasei care trebuie să fie afișat în flux.</p>
     <p class="paragraph">Pentru compatibilitate cu alți operatori, operatorul suprascris trebuie să returneze valoarea parametrului std::ostream.</p>
     <script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
     <p class="paragraph">De asemenea, trebuie menționat că operatorii de intrare și ieșire nu trebuie să fie membri ai clasei, ci sunt definiți în afara clasei, ca funcții obișnuite.</p>
     <ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-4253419731329045" data-ad-slot="8453761934"></ins>
     <script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>&nbsp;&nbsp;<br>class&nbsp;Person&nbsp;<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;Person(std::string&nbsp;name,&nbsp;unsigned&nbsp;age):&nbsp;name{name},&nbsp;age{age}&nbsp;{}<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;getName()&nbsp;const&nbsp;{return&nbsp;name;}<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;getAge()&nbsp;const&nbsp;{return&nbsp;age;}<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;setName(std::string&nbsp;personName){&nbsp;name&nbsp;=&nbsp;personName;}<br>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;setAge(unsigned&nbsp;personAge){&nbsp;age&nbsp;=&nbsp;personAge;}<br>private:<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;name;<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;age;<br>};<br><br>std::ostream&amp;&nbsp;operator&nbsp;&lt;&lt;&nbsp;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;Person&nbsp;&amp;person)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;os&nbsp;&lt;&lt;&nbsp;person.getName()&nbsp;&lt;&lt;&nbsp;"&nbsp;"&nbsp;&lt;&lt;&nbsp;person.getAge();<br>}<br><br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;Person&nbsp;tom{"Tom",&nbsp;38};<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;tom&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;Person&nbsp;bob{"Bob",&nbsp;42};<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;bob&nbsp;&lt;&lt;&nbsp;std::endl;<br>}</code></pre>
     </div>
     <p class="paragraph">În acest caz, operatorul de ieșire este definit pentru obiectele structurii Person. Operatorul, de fapt, pur și simplu afișează numele și vârsta utilizatorului, separate printr-un spațiu. Iată rezultatul pe consolă:</p>
     <div class="code-inline">
      <pre><code>Tom&nbsp;38<br>Bob&nbsp;42</code></pre>
     </div>
     <h2 class="subtitle">Operatorul &gt;&gt;</h2>
     <p class="paragraph">Primul parametru al operatorului &gt;&gt; reprezintă o referință la un obiect istream, din care se face citirea. Al doilea parametru reprezintă o referință la un obiect non-constant, în care se vor citi datele. Ca rezultat, operatorul returnează o referință la fluxul de intrare istream din primul parametru.</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>&nbsp;&nbsp;<br>class&nbsp;Person&nbsp;<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;Person(std::string&nbsp;name,&nbsp;unsigned&nbsp;age):&nbsp;name{name},&nbsp;age{age}&nbsp;{}<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;getName()&nbsp;const&nbsp;{return&nbsp;name;}<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;getAge()&nbsp;const&nbsp;{return&nbsp;age;}<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;setName(std::string&nbsp;personName){&nbsp;name&nbsp;=&nbsp;personName;}<br>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;setAge(unsigned&nbsp;personAge){&nbsp;age&nbsp;=&nbsp;personAge;}<br>private:<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;name;<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;age{};<br>};&nbsp;<br><br>std::istream&amp;&nbsp;operator&nbsp;&gt;&gt;&nbsp;(std::istream&amp;&nbsp;in,&nbsp;Person&amp;&nbsp;person)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;name;<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;age;<br>&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;&gt;&gt;&nbsp;name&nbsp;&gt;&gt;&nbsp;age;<br>&nbsp;&nbsp;&nbsp;&nbsp;person.setName(name);<br>&nbsp;&nbsp;&nbsp;&nbsp;person.setAge(age);<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;in;<br>}<br><br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;Person&nbsp;bob{"",&nbsp;0};<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Input&nbsp;name&nbsp;and&nbsp;age:&nbsp;";<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cin&nbsp;&gt;&gt;&nbsp;bob;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Name:&nbsp;"&nbsp;&lt;&lt;&nbsp;bob.getName()&nbsp;&lt;&lt;&nbsp;"\tAge:&nbsp;"&nbsp;&lt;&lt;&nbsp;bob.getAge()&nbsp;&lt;&lt;&nbsp;std::endl;<br>}</code></pre>
     </div>
     <p class="paragraph">Operatorul de intrare citește succesiv din flux datele în variabilele name și age, iar apoi le folosește pentru a seta numele și vârsta utilizatorului.</p>
     <div class="code-inline">
      <pre><code>std::istream&amp;&nbsp;operator&nbsp;&gt;&gt;&nbsp;(std::istream&amp;&nbsp;in,&nbsp;Person&amp;&nbsp;person)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;name;<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;age;<br>&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;&gt;&gt;&nbsp;name&nbsp;&gt;&gt;&nbsp;age;<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(in)&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;person.setName(name);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;person.setAge(age);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;in;<br>}</code></pre>
     </div>
     <p class="paragraph">În acest caz, se presupune că numele reprezintă un singur cuvânt. Dacă dorim să citim un nume complex, care conține mai multe cuvinte sau un nume și un prenume, atunci, desigur, trebuie să definim o logică mai complexă.</p>
     <p class="paragraph">Exemplu de lucru al programului:</p>
     <div class="code-inline">
      <pre><code>Input&nbsp;name&nbsp;and&nbsp;age:&nbsp;Bob&nbsp;42<br>Name:&nbsp;Bob&nbsp;&nbsp;&nbsp;&nbsp;Age:&nbsp;42</code></pre>
     </div>
     <p class="paragraph">Totuși, ce se întâmplă dacă pentru vârstă se introduce un șir de caractere în loc de un număr? În acest caz, variabila age va primi o valoare nedefinită. Există diverse moduri de a trata aceste situații, dar ca exemplu, putem seta o valoare implicită în caz de intrare incorectă:</p>
     <div class="code-inline">
      <pre><code>std::istream&amp;&nbsp;operator&nbsp;&gt;&gt;&nbsp;(std::istream&amp;&nbsp;in,&nbsp;Person&amp;&nbsp;person)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;name;<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;age;<br>&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;&gt;&gt;&nbsp;name&nbsp;&gt;&gt;&nbsp;age;<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(in)&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;person.setName(name);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;person.setAge(age);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;in;<br>}</code></pre>
     </div>
     <p class="paragraph">Folosind expresia if(in), verificăm dacă intrarea a avut loc cu succes. Dacă a fost un succes, setăm valorile introduse. Dacă intrarea nu a reușit, obiectul Person va păstra valorile pe care le avea înainte de introducere.</p>
     <h2 class="subtitle">Citirea și scrierea fișierelor</h2>
     <p class="paragraph">După ce am definit operatorii de intrare și ieșire, îi putem folosi și pentru citirea și scrierea fișierelor:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>#include&nbsp;&lt;fstream&gt;<br>#include&nbsp;&lt;vector&gt;<br>&nbsp;<br>class&nbsp;Person&nbsp;<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;Person(std::string&nbsp;name,&nbsp;unsigned&nbsp;age):&nbsp;name{name},&nbsp;age{age}&nbsp;{}<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;getName()&nbsp;const&nbsp;{return&nbsp;name;}<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;getAge()&nbsp;const&nbsp;{return&nbsp;age;}<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;setName(std::string&nbsp;personName){&nbsp;name&nbsp;=&nbsp;personName;}<br>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;setAge(unsigned&nbsp;personAge){&nbsp;age&nbsp;=&nbsp;personAge;}<br>private:<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;name;<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;age{};<br>};<br><br>std::ostream&amp;&nbsp;operator&nbsp;&lt;&lt;&nbsp;(std::ostream&nbsp;&amp;os,&nbsp;const&nbsp;Person&nbsp;&amp;person)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;os&nbsp;&lt;&lt;&nbsp;person.getName()&nbsp;&lt;&lt;&nbsp;"&nbsp;"&nbsp;&lt;&lt;&nbsp;person.getAge();<br>}<br><br>std::istream&amp;&nbsp;operator&nbsp;&gt;&gt;&nbsp;(std::istream&amp;&nbsp;in,&nbsp;Person&amp;&nbsp;person)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;name;<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;age;<br>&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;&gt;&gt;&nbsp;name&nbsp;&gt;&gt;&nbsp;age;<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(in)&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;person.setName(name);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;person.setAge(age);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;in;<br>}<br><br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;date&nbsp;inițiale&nbsp;-&nbsp;vector&nbsp;de&nbsp;obiecte&nbsp;Person<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Person&gt;&nbsp;people&nbsp;=<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person{"Tom",&nbsp;23},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person{"Bob",&nbsp;25},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person{"Alice",&nbsp;22},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person{"Kate",&nbsp;31}<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;scrierea&nbsp;datelor&nbsp;într-un&nbsp;fișier<br>&nbsp;&nbsp;&nbsp;&nbsp;std::ofstream&nbsp;out("people.txt");<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(out.is_open())<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(const&nbsp;Person&amp;&nbsp;person:&nbsp;people)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out&nbsp;&lt;&lt;&nbsp;person&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;out.close();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;vector&nbsp;pentru&nbsp;datele&nbsp;citite<br>&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Person&gt;&nbsp;new_people;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;citirea&nbsp;datelor&nbsp;din&nbsp;fișier<br>&nbsp;&nbsp;&nbsp;&nbsp;std::ifstream&nbsp;in("people.txt");<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(in.is_open())<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person&nbsp;person{"",&nbsp;0};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(in&nbsp;&gt;&gt;&nbsp;person)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new_people.push_back(person);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;in.close();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;afișarea&nbsp;datelor&nbsp;citite&nbsp;pe&nbsp;consolă<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"All&nbsp;users:"&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(const&nbsp;Person&amp;&nbsp;person:&nbsp;new_people)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;person&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</code></pre>
     </div>
     <p class="paragraph">Aici, pentru clasa Person sunt definite operatorii de intrare și ieșire. Cu ajutorul operatorului de ieșire, datele vor fi scrise într-un fișier people.txt, iar cu ajutorul operatorului de intrare vor fi citite din fișier. La final, datele citite sunt afișate pe consolă.</p>
     <p class="paragraph">Rezultatul programului:</p>
     <div class="code-inline">
      <pre><code>All&nbsp;users:<br>Tom&nbsp;23<br>Bob&nbsp;25<br>Alice&nbsp;22<br>Kate&nbsp;31</code></pre>
     </div>
    </div>
    <div class="lesson-navigation">
     <th:block th:if="${previousLesson != null}"> <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția anterioară</a> </th:block> <th:block th:if="${nextLesson != null}"> <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția următoare →</a> </th:block>
    </div>
    <div class="discord-banner-section">
     <div class="discord-banner-container">
      <a href="https://discord.com/channels/1168639076098920578/1168646757551443979" target="_blank"> <img th:src="@{/images/cpp_discord.png}" alt="Discord Banner" class="discord-banner-image"> </a>
     </div>
    </div>
   </main>
   <aside class="ad-section">
    <div class="ad-box ad-desktop">
     <ins class="adsbygoogle" style="display:inline-block;width:120px;height:728px" data-ad-client="ca-pub-4253419731329045" data-ad-slot="7123454389"></ins>
    </div>
    <div class="ad-box ad-mobile">
     <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-4253419731329045" data-ad-slot="7123454389"></ins>
    </div>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
   </aside>
  </div>
  <div th:replace="~{fragments/footer :: footer}"></div>
  <script th:src="@{/js/script.js}" defer></script>
 </body>
</html>