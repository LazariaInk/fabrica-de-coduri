<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">

<head>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4253419731329045"
        crossorigin="anonymous"></script>

    <link rel="canonical" th:href="${canonicalUrl}" />
    <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        window.gtag = function () { dataLayer.push(arguments); };
        gtag('consent', 'default', {
            'wait_for_update': 500,
            'region': ['RO'],
            'ad_storage': 'denied',
            'analytics_storage': 'denied',
            'ad_user_data': 'denied',
            'ad_personalization': 'denied'
        });
        gtag('js', new Date());
        gtag('config', 'G-7Q2536ZKL2');
    </script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title th:text="${lesson.title}">Lesson</title>
    <link rel="stylesheet" th:href="@{/css/styles.css}">
    <style>
        body {
            background: #ffffff;
        }
    </style>
</head>

<body th:with="activeTopic='C-sharp', activeChapter='10.Colectii', activeLesson='1.Lista List_T_'">
    <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
    <div th:replace="~{fragments/nav :: nav}"></div>
    <div class="top-nav">
        <th:block th:each="topic : ${topics}">
            <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}"
                th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a>
        </th:block>
    </div>
    <div class="layout">
        <div class="mobile-sidebar" id="mobileSidebar">
            <button class="close-btn" onclick="toggleSidebar()">✖</button>
            <ul class="chapter-list">
                <th:block th:each="chapter : ${chapters}">
                    <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
                        <div class="chapter-title" onclick="toggleChapter(this)">
                            <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
                        </div>
                        <ul class="lesson-list">
                            <th:block th:each="lesson : ${chapter.lessons}">
                                <li><a th:href="@{'/lectii/' +
${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}"
                                        th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
                            </th:block>
                        </ul>
                    </li>
                </th:block>
            </ul>
        </div>
        <aside class="sidebar">
            <ul class="sidebar-list">
                <th:block th:each="chapter : ${chapters}">
                    <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
                        <div class="chapter-toggle" onclick="toggleLessons(this)">
                            <span th:text="${chapter.title}">Chapter</span>
                        </div>
                        <ul class="lesson-list hidden">
                            <th:block th:each="lesson : ${chapter.lessons}">
                                <li><a th:href="@{'/lectii/' +
${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}"
                                        th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
                            </th:block>
                        </ul>
                    </li>
                </th:block>
            </ul>
        </aside>
        <main class="content">
            <div class="document-container">

<h1 class="main-title">Operatorul de atribuire prin mutare</h1>
<p class="paragraph">Operatorul de atribuire prin mutare (move assignment operator) are rolul de a rezolva aceleași probleme ca și constructorul de mutare. Acest operator are următoarea formă:</p>
<div class="code-inline"><pre><code>MyClass&amp;&nbsp;operator=(MyClass&amp;&amp;&nbsp;moved)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;codul&nbsp;operatorului<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;*this;&nbsp;//&nbsp;returnăm&nbsp;obiectul&nbsp;curent<br>}</code></pre></div>


<p class="paragraph">Ca parametru, primește obiectul care urmează să fie mutat, printr-o referință rvalue. În codul operatorului se realizează operațiile necesare.</p>
<p class="paragraph">Să definim și să folosim operatorul de atribuire prin mutare:</p>
<div class="code-inline"><pre><code>#include&nbsp;&lt;iostream&gt;<br>&nbsp;&nbsp;<br>//&nbsp;clasa&nbsp;mesaj<br>class&nbsp;Message<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;constructor&nbsp;normal<br>&nbsp;&nbsp;&nbsp;&nbsp;Message(const&nbsp;char*&nbsp;data,&nbsp;unsigned&nbsp;count)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size&nbsp;=&nbsp;count;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text&nbsp;=&nbsp;new&nbsp;char[size];&nbsp;&nbsp;//&nbsp;alocăm&nbsp;memorie<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(unsigned&nbsp;i{};&nbsp;i&nbsp;&lt;&nbsp;size;&nbsp;i++)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;copiem&nbsp;datele<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text[i]&nbsp;=&nbsp;data[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;=&nbsp;++counter;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;Create&nbsp;Message&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;id&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;operator&nbsp;normal&nbsp;de&nbsp;atribuire<br>&nbsp;&nbsp;&nbsp;&nbsp;Message&amp;&nbsp;operator=(const&nbsp;Message&amp;&nbsp;copy)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;Copy&nbsp;assign&nbsp;message&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;copy.id&nbsp;&lt;&lt;&nbsp;&quot;&nbsp;to&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;id&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&amp;copy&nbsp;!=&nbsp;this)&nbsp;&nbsp;//&nbsp;evităm&nbsp;auto-atribuirea<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete[]&nbsp;text;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;eliberăm&nbsp;memoria&nbsp;obiectului&nbsp;curent<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;copiem&nbsp;datele&nbsp;din&nbsp;obiectul&nbsp;sursă&nbsp;în&nbsp;obiectul&nbsp;curent<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size&nbsp;=&nbsp;copy.size;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text&nbsp;=&nbsp;new&nbsp;char[size];&nbsp;&nbsp;//&nbsp;alocăm&nbsp;memorie<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(unsigned&nbsp;i{};&nbsp;i&nbsp;&lt;&nbsp;size;&nbsp;i++)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;copiem&nbsp;datele<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text[i]&nbsp;=&nbsp;copy.text[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;*this;&nbsp;//&nbsp;returnăm&nbsp;obiectul&nbsp;curent<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;operator&nbsp;de&nbsp;atribuire&nbsp;prin&nbsp;mutare<br>&nbsp;&nbsp;&nbsp;&nbsp;Message&amp;&nbsp;operator=(Message&amp;&amp;&nbsp;moved)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;Move&nbsp;assign&nbsp;message&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;moved.id&nbsp;&lt;&lt;&nbsp;&quot;&nbsp;to&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;id&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&amp;moved&nbsp;!=&nbsp;this)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;evităm&nbsp;auto-atribuirea<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete[]&nbsp;text;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;eliberăm&nbsp;memoria&nbsp;obiectului&nbsp;curent<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text&nbsp;=&nbsp;moved.text;&nbsp;&nbsp;//&nbsp;copiem&nbsp;pointerul&nbsp;din&nbsp;obiectul&nbsp;mutat&nbsp;în&nbsp;cel&nbsp;curent<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size&nbsp;=&nbsp;moved.size;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moved.text&nbsp;=&nbsp;nullptr;&nbsp;//&nbsp;resetăm&nbsp;pointerul&nbsp;din&nbsp;obiectul&nbsp;mutat<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moved.size&nbsp;=&nbsp;0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;*this;&nbsp;//&nbsp;returnăm&nbsp;obiectul&nbsp;curent<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;destructor<br>&nbsp;&nbsp;&nbsp;&nbsp;~Message()<br>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;Delete&nbsp;Message&nbsp;&quot;&nbsp;&nbsp;&lt;&lt;&nbsp;id&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete[]&nbsp;text;&nbsp;&nbsp;//&nbsp;eliberăm&nbsp;memoria<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;char*&nbsp;getText()&nbsp;const&nbsp;{&nbsp;return&nbsp;text;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;getSize()&nbsp;const&nbsp;{&nbsp;return&nbsp;size;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;getId()&nbsp;const&nbsp;{return&nbsp;id;}<br>private:<br>&nbsp;&nbsp;&nbsp;&nbsp;char*&nbsp;text{};&nbsp;&nbsp;//&nbsp;textul&nbsp;mesajului<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;size{};&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;dimensiunea&nbsp;mesajului<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;id{};&nbsp;&nbsp;//&nbsp;numărul&nbsp;mesajului<br>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;inline&nbsp;unsigned&nbsp;counter{};&nbsp;&nbsp;&nbsp;//&nbsp;contor&nbsp;static&nbsp;pentru&nbsp;generarea&nbsp;numărului&nbsp;obiectului<br>};<br>&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;text1[]&nbsp;{&quot;Hello&nbsp;Word&quot;};<br>&nbsp;&nbsp;&nbsp;&nbsp;Message&nbsp;hello{text1,&nbsp;std::size(text1)};<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;text2[]&nbsp;{&quot;Hi&nbsp;World!&quot;};<br>&nbsp;&nbsp;&nbsp;&nbsp;hello&nbsp;=&nbsp;Message{text2,&nbsp;std::size(text2)};&nbsp;&nbsp;&nbsp;//&nbsp;atribuirea&nbsp;obiectului<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;Message&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;&nbsp;hello.getId()&nbsp;&lt;&lt;&nbsp;&quot;:&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;hello.getText()&nbsp;&lt;&lt;&nbsp;std::endl;<br>}</code></pre></div>
<p class="paragraph">Explicații succinte:</p>
<ul class="enumeration">
<li>Operatorul normal de atribuire copiază conținutul obiectului sursă în obiectul curent, alocând memorie nouă și copierea datelor</li>
<li>Operatorul de atribuire prin mutare &quot;mută&quot; datele, preluând pointerul la memorie din obiectul sursă și resetând pointerul din sursă pentru a evita eliberarea dublă a memoriei</li>
<li>Astfel se evită costurile copieri inutile și alocarea repetată a memoriei</li>
</ul>
<p class="paragraph">În operatorul de atribuire, primim obiectul mutabil Message, eliberăm memoria alocată anterior și copiem valoarea pointerului din obiectul mutat:</p>
<div class="code-inline"><pre><code>Message&amp;&nbsp;operator=(Message&amp;&amp;&nbsp;moved)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;Move&nbsp;assign&nbsp;message&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;moved.id&nbsp;&lt;&lt;&nbsp;&quot;&nbsp;to&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;id&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&amp;moved&nbsp;!=&nbsp;this)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;evităm&nbsp;auto-atribuirea<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete[]&nbsp;text;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;eliberăm&nbsp;memoria&nbsp;obiectului&nbsp;curent<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text&nbsp;=&nbsp;moved.text;&nbsp;&nbsp;//&nbsp;copiem&nbsp;pointerul&nbsp;din&nbsp;obiectul&nbsp;mutat&nbsp;în&nbsp;cel&nbsp;curent<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size&nbsp;=&nbsp;moved.size;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moved.text&nbsp;=&nbsp;nullptr;&nbsp;//&nbsp;resetăm&nbsp;pointerul&nbsp;din&nbsp;obiectul&nbsp;mutat<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moved.size&nbsp;=&nbsp;0;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;*this;&nbsp;//&nbsp;returnăm&nbsp;obiectul&nbsp;curent<br>}</code></pre></div>
<p class="paragraph">În funcția main atribuim variabilei hello un obiect Message:</p>
<div class="code-inline"><pre><code>char&nbsp;text2[]&nbsp;{&quot;Hi&nbsp;World!&quot;};<br>hello&nbsp;=&nbsp;Message{text2,&nbsp;std::size(text2)};</code></pre></div>
<p class="paragraph">Trebuie remarcat că, la fel ca și în cazul constructorului de mutare, valoarea atribuită este un rvalue — un obiect temporar în memorie (Message{text2, std::size(text2)}), care după operația de atribuire nu mai este necesar. Acesta este tocmai cazul ideal pentru aplicarea operatorului de atribuire prin mutare. Output-ul programului este:</p>
<div class="code-inline"><pre><code>Create&nbsp;message&nbsp;1<br>Create&nbsp;message&nbsp;2<br>Move&nbsp;assign&nbsp;message&nbsp;2&nbsp;to&nbsp;1<br>Delete&nbsp;message&nbsp;2<br>Message&nbsp;1:&nbsp;Hi&nbsp;World!<br>Delete&nbsp;message&nbsp;1</code></pre></div>
<p class="paragraph">După cum se vede, variabila hello reprezintă obiectul Message cu numărul 1. Dacă în clasă sunt definiți mai mulți operatori de atribuire (cel standard și cel prin mutare), implicit pentru rvalue va fi folosit operatorul de atribuire prin mutare. La atribuirea unui lvalue se va folosi operatorul standard (fără mutare):</p>
<div class="code-inline"><pre><code>Message&nbsp;hello{&quot;Hello&nbsp;Word&quot;,&nbsp;11};<br>Message&nbsp;hi{&quot;Hi&nbsp;World!&quot;,&nbsp;10};<br>hello&nbsp;=&nbsp;hi;&nbsp;//&nbsp;atribuirea&nbsp;lvalue&nbsp;-&nbsp;operatorul&nbsp;standard&nbsp;de&nbsp;atribuire<br>hello&nbsp;=&nbsp;Message{&quot;Hi&nbsp;World!&quot;,&nbsp;10};&nbsp;//&nbsp;atribuirea&nbsp;rvalue&nbsp;-&nbsp;operatorul&nbsp;de&nbsp;atribuire&nbsp;prin&nbsp;mutare</code></pre></div>
<p class="paragraph">De asemenea, putem folosi funcția std::move() pentru a transforma un lvalue în rvalue:</p>
<div class="code-inline"><pre><code>Message&nbsp;hello{&quot;Hello&nbsp;Word&quot;,&nbsp;11};<br>Message&nbsp;hi{&quot;Hi&nbsp;World!&quot;,&nbsp;10};<br>hello&nbsp;=&nbsp;std::move(hi);&nbsp;//&nbsp;transformare&nbsp;lvalue&nbsp;în&nbsp;rvalue&nbsp;-&nbsp;operatorul&nbsp;de&nbsp;atribuire&nbsp;prin&nbsp;mutare</code></pre></div>
<p class="paragraph">Aici variabila hi este transformată în rvalue, deci operatorul de atribuire prin mutare va fi apelat.</p>
<p class="paragraph">Compilatorul generează implicit operatorul de atribuire prin mutare, care mută valorile tuturor variabilelor nestatice. Însă dacă definim manual destructorul, constructorul de copiere, constructorul de mutare sau operatorul de atribuire, compilatorul nu mai generează operatorul de atribuire prin mutare implicit.</p>
<h2 class="subtitle">std::unique_ptr și mutarea valorilor</h2>
<p class="paragraph">Pentru că pointerul inteligent std::unique_ptr indică în mod unic o adresă de memorie, nu pot exista două sau mai multe pointere std::unique_ptr care să indice aceeași zonă de memorie. Din acest motiv, tipul unique_ptr nu are constructor de copiere și operator de atribuire prin copiere. Dacă încercăm să le folosim, vom primi erori de compilare:</p>
<div class="code-inline"><pre><code>#include&nbsp;&lt;iostream&gt;&nbsp;<br>#include&nbsp;&lt;memory&gt;<br>&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::unique_ptr&lt;int&gt;&nbsp;one{&nbsp;std::make_unique&lt;int&gt;(123)&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;std::unique_ptr&lt;int&gt;&nbsp;other;<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;other&nbsp;=&nbsp;one;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Eroare!&nbsp;operatorul&nbsp;de&nbsp;atribuire&nbsp;prin&nbsp;copiere&nbsp;nu&nbsp;există<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;std::unique_ptr&lt;int&gt;&nbsp;another{&nbsp;other&nbsp;};&nbsp;//&nbsp;Eroare!&nbsp;constructorul&nbsp;de&nbsp;copiere&nbsp;nu&nbsp;există<br>}</code></pre></div>
<p class="paragraph">În schimb, unique_ptr are constructor de mutare și operator de atribuire prin mutare, pe care le putem folosi pentru a muta datele dintr-un pointer în altul:</p>
<div class="code-inline"><pre><code>#include&nbsp;&lt;iostream&gt;&nbsp;<br>#include&nbsp;&lt;memory&gt;<br>&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;std::unique_ptr&lt;int&gt;&nbsp;one{&nbsp;std::make_unique&lt;int&gt;(123)&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;std::unique_ptr&lt;int&gt;&nbsp;other;<br>&nbsp;&nbsp;&nbsp;&nbsp;other&nbsp;=&nbsp;std::move(one);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;operator&nbsp;de&nbsp;atribuire&nbsp;prin&nbsp;mutare<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;*one&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;&nbsp;//&nbsp;datele&nbsp;din&nbsp;&#x27;one&#x27;&nbsp;au&nbsp;fost&nbsp;mutate&nbsp;în&nbsp;&#x27;other&#x27;,&nbsp;deci&nbsp;aici&nbsp;ar&nbsp;fi&nbsp;invalid<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;*other&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;&nbsp;&nbsp;//&nbsp;123<br>&nbsp;&nbsp;&nbsp;&nbsp;std::unique_ptr&lt;int&gt;&nbsp;another{&nbsp;std::move(other)&nbsp;};&nbsp;//&nbsp;constructor&nbsp;de&nbsp;mutare<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;*another&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;//&nbsp;123<br>}</code></pre></div>
<p class="paragraph">După mutarea valorii dintr-un pointer, nu mai putem accesa valoarea prin pointerul inițial.</p>
            </div>
        
<div class="lesson-navigation">
        <th:block th:if="${previousLesson != null}">
            <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția
                anterioară</a>
        </th:block>
        <th:block th:if="${nextLesson != null}">
            <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția
                următoare →</a>
        </th:block>
    </div>
                <div class="discord-banner-section">
                    <div class="discord-banner-container">
                        <a href="https://discord.com/channels/1168639076098920578/1168646757551443979" target="_blank">
                            <img th:src="@{/images/cpp_discord.png}" alt="Discord Banner" class="discord-banner-image">
                        </a>
                    </div>
                </div>

</main>
        <aside class="ad-section">
            <div class="ad-box">
                <p>Google Ad Here</p>
            </div>
            <div class="ad-box">
                <p>Promo: SQL Beginner Guide</p>
            </div>
        </aside>
    </div>
    
    <div th:replace="~{fragments/footer :: footer}"></div>
    <script th:src="@{/js/script.js}" defer></script>
</body>
</html>
