<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">
 <head>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4253419731329045" crossorigin="anonymous"></script>
  <link rel="canonical" th:href="${canonicalUrl}">
  <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
  <script>
        window.dataLayer = window.dataLayer || [];
        window.gtag = function () { dataLayer.push(arguments); };
        gtag('consent', 'default', {
            'wait_for_update': 500,
            'region': ['RO'],
            'ad_storage': 'denied',
            'analytics_storage': 'denied',
            'ad_user_data': 'denied',
            'ad_personalization': 'denied'
        });
        gtag('js', new Date());
        gtag('config', 'G-7Q2536ZKL2');
    </script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title th:text="${lesson.title}">Lesson</title>
  <link rel="stylesheet" th:href="@{/css/styles.css}">
  <style>
        body {
            background: #ffffff;
        }
    </style>
 </head>
 <body th:with="activeTopic='C-sharp', activeChapter='10.Colectii', activeLesson='1.Lista List_T_'">
  <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
  <div th:replace="~{fragments/nav :: nav}"></div>
  <div class="top-nav">
   <th:block th:each="topic : ${topics}"> <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}" th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a> </th:block>
  </div>
  <div class="layout">
   <div class="mobile-sidebar" id="mobileSidebar">
    <button class="close-btn" onclick="toggleSidebar()">✖</button>
    <ul class="chapter-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-title" onclick="toggleChapter(this)">
        <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
       </div>
       <ul class="lesson-list">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul>
      </li>
     </th:block>
    </ul>
   </div>
   <aside class="sidebar">
    <ul class="sidebar-list">
     <th:block th:each="chapter : ${chapters}">
      <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
       <div class="chapter-toggle" onclick="toggleLessons(this)">
        <span th:text="${chapter.title}">Chapter</span>
       </div>
       <ul class="lesson-list hidden">
        <th:block th:each="lesson : ${chapter.lessons}">
         <li><a th:href="@{'/lectii/' +
${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}" th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
        </th:block>
       </ul>
      </li>
     </th:block>
    </ul>
   </aside>
   <main class="content">
    <div class="document-container">
     <h1 class="main-title">Supraincărcarea operatorilor</h1>
     <p class="paragraph">Supraincărcarea operatorilor (operator overloading) permite definirea pentru obiectele claselor a operatorilor încorporați, precum +, -, * etc. Pentru a defini un operator pentru obiectele propriei clase, este necesar să se definească o funcție al cărei nume conține cuvântul operator și simbolul operatorului suprascris. Funcția operatorului poate fi definită fie ca membru al clasei, fie în afara clasei.</p>
     <p class="paragraph">Se pot suprascrie doar acei operatori care sunt deja definiți în C++. Nu pot fi creați operatori noi. De asemenea, nu se poate modifica numărul de operanzi, asociativitatea sau prioritatea acestora.</p>
     <p class="paragraph">Dacă funcția operatorului este definită ca o funcție separată și nu este membru al clasei, atunci numărul de parametri al acestei funcții coincide cu numărul de operanzi ai operatorului. De exemplu, o funcție care reprezintă un operator unar va avea un parametru, iar o funcție care reprezintă un operator binar - doi parametri. Dacă operatorul are doi operanzi, atunci primul operand este transmis primului parametru al funcției, iar al doilea operand - celui de-al doilea parametru. În același timp, cel puțin unul dintre parametri trebuie să reprezinte tipul clasei.</p>
     <p class="paragraph">Definirea formală a operatorilor ca funcții-membru ale clasei:</p>
     <div class="code-inline">
      <pre><code>//&nbsp;operator&nbsp;binar<br>ReturnType&nbsp;operator&nbsp;Op(Type&nbsp;right_operand);<br><br>//&nbsp;operator&nbsp;unar<br>ClassType&amp;&nbsp;operator&nbsp;Op();</code></pre>
     </div>
     <p class="paragraph">Definirea formală a operatorilor sub formă de funcții care nu sunt membri ai clasei:</p>
     <script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
     <div class="code-inline">
      <pre><code>//&nbsp;operator&nbsp;binar<br>ReturnType&nbsp;operator&nbsp;Op(const&nbsp;ClassType&amp;&nbsp;left_operand,&nbsp;Type&nbsp;right_operand);<br>//&nbsp;definiție&nbsp;alternativă,&nbsp;unde&nbsp;clasa&nbsp;pentru&nbsp;care&nbsp;se&nbsp;creează&nbsp;operatorul&nbsp;este&nbsp;operandul&nbsp;din&nbsp;dreapta<br>ReturnType&nbsp;operator&nbsp;Op(Type&nbsp;left_operand,&nbsp;const&nbsp;ClassType&amp;&nbsp;right_operand);<br>//&nbsp;operator&nbsp;unar<br>ClassType&amp;&nbsp;operator&nbsp;Op(ClassType&amp;&nbsp;obj);</code></pre>
     </div>
     <p class="paragraph">Aici ClassType reprezintă tipul pentru care este definit operatorul. Type este tipul celuilalt operand, care poate coincide sau nu cu primul. ReturnType este tipul rezultatului returnat, care de asemenea poate coincide cu unul dintre tipurile operanzilor sau poate fi diferit. Op reprezintă operatorul propriu-zis.</p>
     <p class="paragraph">Să analizăm un exemplu cu clasa Counter, care stochează un număr:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>&nbsp;&nbsp;<br>class&nbsp;Counter<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter(int&nbsp;val)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;=&nbsp;val;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;print()&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Value:&nbsp;"&nbsp;&lt;&lt;&nbsp;value&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;operator&nbsp;+&nbsp;(const&nbsp;Counter&amp;&nbsp;counter)&nbsp;const<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Counter{value&nbsp;+&nbsp;counter.value};<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>private:<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;value;<br>};<br>&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;c1{20};<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;c2{10};<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;c3&nbsp;=&nbsp;c1&nbsp;+&nbsp;c2;<br>&nbsp;&nbsp;&nbsp;&nbsp;c3.print();&nbsp;&nbsp;&nbsp;//&nbsp;Value:&nbsp;30<br>}</code></pre>
     </div>
     <p class="paragraph">Aici, în clasa Counter este definit operatorul de adunare, al cărui scop este să adune două obiecte de tip Counter:</p>
     <ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-4253419731329045" data-ad-slot="8453761934"></ins>
     <script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
     <div class="code-inline">
      <pre><code>Counter&nbsp;operator&nbsp;+&nbsp;(const&nbsp;Counter&amp;&nbsp;counter)&nbsp;const<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Counter{value&nbsp;+&nbsp;counter.value};<br>}</code></pre>
     </div>
     <p class="paragraph">Obiectul curent va reprezenta operandul din stânga al operației. Obiectul transmis funcției prin parametrul counter va reprezenta operandul din dreapta. Aici parametrul funcției este definit ca referință constantă, dar nu este obligatoriu. De asemenea, funcția operatorului este marcată ca const, dar nici asta nu este obligatoriu.</p>
     <p class="paragraph">Rezultatul operatorului de adunare este un nou obiect Counter, în care valoarea value este egală cu suma valorilor value ale ambilor operanzi.</p>
     <p class="paragraph">După definirea operatorului, putem aduna două obiecte de tip Counter:</p>
     <div class="code-inline">
      <pre><code>Counter&nbsp;c1{20};<br>Counter&nbsp;c2{10};<br>Counter&nbsp;c3&nbsp;{c1&nbsp;+&nbsp;c2};<br>c3.print();&nbsp;&nbsp;&nbsp;//&nbsp;Value:&nbsp;30</code></pre>
     </div>
     <p class="paragraph">În mod similar, putem defini funcția operatorului în afara clasei:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>&nbsp;&nbsp;<br>class&nbsp;Counter<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter(int&nbsp;val)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;=&nbsp;val;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;print()&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Value:&nbsp;"&nbsp;&lt;&lt;&nbsp;value&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;value;&nbsp;&nbsp;//&nbsp;funcția&nbsp;externă&nbsp;a&nbsp;operatorului&nbsp;nu&nbsp;poate&nbsp;accesa&nbsp;membrii&nbsp;privați<br>};<br><br>//&nbsp;definim&nbsp;operatorul&nbsp;de&nbsp;adunare&nbsp;în&nbsp;afara&nbsp;clasei<br>Counter&nbsp;operator&nbsp;+&nbsp;(const&nbsp;Counter&amp;&nbsp;c1,&nbsp;const&nbsp;Counter&amp;&nbsp;c2)&nbsp;<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Counter{c1.value&nbsp;+&nbsp;c2.value};<br>}<br>&nbsp;&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;c1{20};<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;c2{10};<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;c3&nbsp;{c1&nbsp;+&nbsp;c2};<br>&nbsp;&nbsp;&nbsp;&nbsp;c3.print();&nbsp;&nbsp;&nbsp;//&nbsp;Value:&nbsp;30<br>}</code></pre>
     </div>
     <p class="paragraph">Dacă operatorul binar este definit ca funcție externă, ca în acest caz, atunci el primește doi parametri. Primul parametru va reprezenta operandul din stânga al operației, iar al doilea parametru — operandul din dreapta.</p>
     <p class="paragraph">Însă, în comparație cu codul precedent, aici s-au făcut câteva modificări suplimentare. În primul rând, o funcție externă, desigur, nu poate accesa membrii privați ai clasei, așa că pentru a accesa acești membri va trebui să creăm funcții speciale care returnează valorile membrilor. Eu, pentru simplitate, am făcut ca variabila value să fie publică. O altă soluție în acest caz ar fi putut fi definirea funcției operatorului ca funcție prietenă (friend).</p>
     <p class="paragraph">Al doilea aspect este că funcțiile externe ale operatorilor nu pot fi constante. De aceea, definirea operatorilor în interiorul clasei are anumite avantaje.</p>
     <p class="paragraph">Merită menționat că nu este obligatoriu să returnăm un obiect al clasei. Se poate returna orice alt tip de obiect, în funcție de situație. De asemenea, putem defini funcții de operatori suprasolicitați suplimentare.</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>&nbsp;&nbsp;<br>class&nbsp;Counter<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter(int&nbsp;val)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;=val;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;print()&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Value:&nbsp;"&nbsp;&lt;&lt;&nbsp;value&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;operator&nbsp;+&nbsp;(const&nbsp;Counter&amp;&nbsp;counter)&nbsp;const<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Counter{value&nbsp;+&nbsp;counter.value};<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;operator&nbsp;+&nbsp;(int&nbsp;number)&nbsp;const<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;value&nbsp;+&nbsp;number;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>private:<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;value;<br>};<br>&nbsp;<br>&nbsp;&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;counter{20};<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;number&nbsp;=&nbsp;counter&nbsp;+&nbsp;30;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;number&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;&nbsp;&nbsp;//&nbsp;50<br>}</code></pre>
     </div>
     <p class="paragraph">Aici este definită a doua versiune a operatorului de adunare, care adună obiectul Counter cu un număr și returnează tot un număr. De aceea, operandul din stânga al operației trebuie să fie de tipul Counter, iar operandul din dreapta - de tip int.</p>
     <p class="paragraph">Ce operatori unde trebuie suprascrişi? Operatorii de atribuire, indexare ([]), apelare (()), acces la membru prin pointer (-&gt;) trebuie definiţi ca funcţii-membru ale clasei. Operatorii care modifică starea obiectului sau sunt direct legaţi de obiect (increment, decrement), de obicei se definesc tot ca funcţii-membru ale clasei. Operatorii de alocare şi dealocare a memoriei (new new[] delete delete[]) se definesc doar ca funcţii care nu sunt membri ai clasei. Toţi ceilalţi operatori pot fi definiţi ca funcţii separate, şi nu ca membri ai clasei.</p>
     <h2 class="subtitle">Operatorii de comparaţie</h2>
     <p class="paragraph">Rezultatul operatorilor de comparaţie (==, !=, &lt;, &gt;), de regulă, este o valoare de tip bool. De exemplu, vom suprascrie aceşti operatori pentru tipul Counter:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>&nbsp;&nbsp;<br>class&nbsp;Counter<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter(int&nbsp;val)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;=val;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;print()&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Value:&nbsp;"&nbsp;&lt;&lt;&nbsp;value&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;operator&nbsp;==&nbsp;(const&nbsp;Counter&amp;&nbsp;counter)&nbsp;const<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;value&nbsp;==&nbsp;counter.value;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;operator&nbsp;!=&nbsp;(const&nbsp;Counter&amp;&nbsp;counter)&nbsp;const<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;value&nbsp;!=&nbsp;counter.value;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;operator&nbsp;&gt;&nbsp;(const&nbsp;Counter&amp;&nbsp;counter)&nbsp;const<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;value&nbsp;&gt;&nbsp;counter.value;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;operator&nbsp;&lt;&nbsp;(const&nbsp;Counter&amp;&nbsp;counter)&nbsp;const<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;value&nbsp;&lt;&nbsp;counter.value;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>private:<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;value;<br>};<br>&nbsp;<br>&nbsp;&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;c1(20);<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;c2(10);<br>&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;b1&nbsp;=&nbsp;c1&nbsp;==&nbsp;c2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;false<br>&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;b2&nbsp;=&nbsp;c1&nbsp;&gt;&nbsp;c2;&nbsp;&nbsp;&nbsp;//&nbsp;true<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"c1&nbsp;==&nbsp;c2&nbsp;=&nbsp;"&nbsp;&lt;&lt;&nbsp;std::boolalpha&nbsp;&lt;&lt;&nbsp;b1&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;c1&nbsp;==&nbsp;c2&nbsp;=&nbsp;false<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"c1&nbsp;&gt;&nbsp;c2&nbsp;=&nbsp;"&nbsp;&lt;&lt;&nbsp;std::boolalpha&nbsp;&lt;&lt;&nbsp;b2&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;c1&nbsp;&gt;&nbsp;c2&nbsp;=&nbsp;true<br>}</code></pre>
     </div>
     <p class="paragraph">Dacă este vorba despre o comparație simplă pe baza câmpurilor clasei, atunci pentru operatorii == și != este mai simplu să folosim operatorul special default:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br>&nbsp;&nbsp;<br>class&nbsp;Counter<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter(int&nbsp;val)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;=val;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;print()&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Value:&nbsp;"&nbsp;&lt;&lt;&nbsp;value&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;operator&nbsp;==&nbsp;(const&nbsp;Counter&amp;&nbsp;counter)&nbsp;const&nbsp;=&nbsp;default;<br>&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;operator&nbsp;!=&nbsp;(const&nbsp;Counter&amp;&nbsp;counter)&nbsp;const&nbsp;=&nbsp;default;<br>private:<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;value;<br>};<br>&nbsp;<br>&nbsp;&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;c1(20);<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;c2(10);<br>&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;b1&nbsp;=&nbsp;c1&nbsp;==&nbsp;c2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;false<br>&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;b2&nbsp;=&nbsp;c1&nbsp;!=&nbsp;c2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;true<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"c1&nbsp;==&nbsp;c2&nbsp;=&nbsp;"&nbsp;&lt;&lt;&nbsp;std::boolalpha&nbsp;&lt;&lt;&nbsp;b1&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;c1&nbsp;==&nbsp;c2&nbsp;=&nbsp;false<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"c1&nbsp;!=&nbsp;c2&nbsp;=&nbsp;"&nbsp;&lt;&lt;&nbsp;std::boolalpha&nbsp;&lt;&lt;&nbsp;b2&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;c1&nbsp;!=&nbsp;c2&nbsp;=&nbsp;true<br>}</code></pre>
     </div>
     <p class="paragraph">De exemplu, în cazul operatorului ==:</p>
     <div class="code-inline">
      <pre><code>bool&nbsp;operator&nbsp;==&nbsp;(const&nbsp;Counter&amp;&nbsp;counter)&nbsp;const&nbsp;=&nbsp;default;</code></pre>
     </div>
     <p class="paragraph">În mod implicit vor fi comparate toate câmpurile clasei, pentru care este definit operatorul ==. Dacă valorile tuturor câmpurilor sunt egale, atunci operatorul va returna true.</p>
     <h2 class="subtitle">Operatorii de atribuire</h2>
     <p class="paragraph">Operatorul de atribuire, de obicei, returnează o referință către operandul din stânga al expresiei:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br><br>class&nbsp;Counter<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter(int&nbsp;val)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;=&nbsp;val;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;print()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Value:&nbsp;"&nbsp;&lt;&lt;&nbsp;value&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;operatorul&nbsp;de&nbsp;atribuire<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&amp;&nbsp;operator&nbsp;+=&nbsp;(const&nbsp;Counter&amp;&nbsp;counter)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;+=&nbsp;counter.value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;*this;&nbsp;&nbsp;&nbsp;//&nbsp;returnăm&nbsp;referința&nbsp;la&nbsp;obiectul&nbsp;curent<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>private:<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;value;<br>};<br><br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;c1{20};<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;c2{50};<br>&nbsp;&nbsp;&nbsp;&nbsp;c1&nbsp;+=&nbsp;c2;<br>&nbsp;&nbsp;&nbsp;&nbsp;c1.print();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Value:&nbsp;70<br>}</code></pre>
     </div>
     <h2 class="subtitle">Operațiile unare</h2>
     <p class="paragraph">Operațiile unare returnează de obicei un nou obiect creat pe baza celui existent. De exemplu, să luăm operația minus unar:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br><br>class&nbsp;Counter<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter(int&nbsp;val)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;=&nbsp;val;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;print()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Value:&nbsp;"&nbsp;&lt;&lt;&nbsp;value&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;operatorul&nbsp;minus&nbsp;unar<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;operator&nbsp;-&nbsp;()&nbsp;const<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Counter{-value};<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>private:<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;value;<br>};<br><br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;c1{20};<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;c2&nbsp;=&nbsp;-c1;&nbsp;&nbsp;&nbsp;//&nbsp;aplicăm&nbsp;operatorul&nbsp;minus&nbsp;unar<br>&nbsp;&nbsp;&nbsp;&nbsp;c2.print();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Value:&nbsp;-20<br>}</code></pre>
     </div>
     <p class="paragraph">Aici operația minus unar returnează un nou obiect Counter, a cărui valoare value este egală cu valoarea obiectului curent înmulțită cu -1.</p>
     <h2 class="subtitle">Operațiile de incrementare și decrementare</h2>
     <p class="paragraph">O dificultate aparte o reprezintă suprascrierea operatorilor de incrementare și decrementare, deoarece trebuie să definim atât forma prefixată, cât și forma postfixată a acestor operatori. Vom defini astfel de operatori pentru tipul Counter:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br><br>class&nbsp;Counter<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter(int&nbsp;val)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;=&nbsp;val;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;print()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"Value:&nbsp;"&nbsp;&lt;&lt;&nbsp;value&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;operatori&nbsp;prefixați<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&amp;&nbsp;operator++&nbsp;()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;+=&nbsp;1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;*this;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&amp;&nbsp;operator--&nbsp;()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;-=&nbsp;1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;*this;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;operatori&nbsp;postfixați<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;operator++&nbsp;(int)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;copy{*this};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++(*this);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;copy;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;operator--&nbsp;(int)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;copy{*this};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--(*this);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;copy;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>private:<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;value;<br>};<br><br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;c1{20};<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;c2&nbsp;=&nbsp;c1++;<br>&nbsp;&nbsp;&nbsp;&nbsp;c2.print();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Value:&nbsp;20<br>&nbsp;&nbsp;&nbsp;&nbsp;c1.print();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Value:&nbsp;21<br>&nbsp;&nbsp;&nbsp;&nbsp;--c1;<br>&nbsp;&nbsp;&nbsp;&nbsp;c1.print();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Value:&nbsp;20<br>}</code></pre>
     </div>
     <p class="paragraph">Operatorii prefixați trebuie să returneze o referință la obiectul curent, care poate fi obținută cu ajutorul pointerului this:</p>
     <div class="code-inline">
      <pre><code>Counter&amp;&nbsp;operator++&nbsp;()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;+=&nbsp;1;<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;*this;<br>}</code></pre>
     </div>
     <p class="paragraph">În interiorul funcției putem defini logica de incrementare a valorii. În acest caz, valoarea value este mărită cu 1.</p>
     <p class="paragraph">Operatorii postfixați trebuie să returneze valoarea obiectului înainte de incrementare, adică starea anterioară a obiectului. De aceea, forma postfixată returnează o copie a obiectului înainte de incrementare:</p>
     <div class="code-inline">
      <pre><code>Counter&nbsp;operator++&nbsp;(int)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;copy{*this};<br>&nbsp;&nbsp;&nbsp;&nbsp;++(*this);<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;copy;<br>}<br></code></pre>
     </div>
     <p class="paragraph">Pentru ca forma postfixată să se distingă de cea prefixată, versiunile postfixate primesc un parametru suplimentar de tip int, care nu este folosit. Deși, în principiu, l-am putea folosi.</p>
     <h2 class="subtitle">Suprascrierea operatorului &lt;&lt;</h2>
     <p class="paragraph">Operatorul &lt;&lt; acceptă doi parametri: o referință la un obiect de flux (operandul din stânga) și o valoare care trebuie afișată (operandul din dreapta). Apoi, el returnează o referință la același flux, ceea ce permite apeluri în lanț ale operatorului &lt;&lt;.</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br><br>class&nbsp;Counter<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter(int&nbsp;val)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;=&nbsp;val;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;getValue()&nbsp;const&nbsp;{&nbsp;return&nbsp;value;&nbsp;}<br>private:<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;value;<br>};<br><br>std::ostream&amp;&nbsp;operator&lt;&lt;(std::ostream&amp;&nbsp;stream,&nbsp;const&nbsp;Counter&amp;&nbsp;counter)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;stream&nbsp;&lt;&lt;&nbsp;"Value:&nbsp;";<br>&nbsp;&nbsp;&nbsp;&nbsp;stream&nbsp;&lt;&lt;&nbsp;counter.getValue();<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;stream;<br>}<br><br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;counter1{20};<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;counter2{50};<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;counter1&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Value:&nbsp;20<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;counter2&nbsp;&lt;&lt;&nbsp;std::endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Value:&nbsp;50<br>}</code></pre>
     </div>
     <p class="paragraph">Fluxul standard de ieșire cout are tipul std::ostream. Prin urmare, primul parametru (operandul din stânga) reprezintă un obiect de tip ostream, iar al doilea (operandul din dreapta) — un obiect de tip Counter. Deoarece nu putem modifica definiția clasei std::ostream, trebuie să definim operatorul ca o funcție externă clasei Counter.</p>
     <div class="code-inline">
      <pre><code>std::ostream&amp;&nbsp;operator&lt;&lt;(std::ostream&amp;&nbsp;stream,&nbsp;const&nbsp;Counter&amp;&nbsp;counter)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;stream&nbsp;&lt;&lt;&nbsp;"Value:&nbsp;";<br>&nbsp;&nbsp;&nbsp;&nbsp;stream&nbsp;&lt;&lt;&nbsp;counter.getValue();<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;stream;<br>}</code></pre>
     </div>
     <p class="paragraph">În acest caz, afișăm valoarea membrului value. Pentru a obține această valoare din afara clasei, am adăugat metoda getValue().</p>
     <p class="paragraph">Valoarea returnată trebuie întotdeauna să fie o referință la același flux primit ca parametru (pentru a permite apeluri în lanț).</p>
     <h2 class="subtitle">Exprimarea unui operator prin altul</h2>
     <p class="paragraph">Uneori este mai eficient să exprimăm un operator prin intermediul altuia, în loc să duplicăm logica. De exemplu:</p>
     <div class="code-inline">
      <pre><code>#include&nbsp;&lt;iostream&gt;<br><br>class&nbsp;Counter<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter(int&nbsp;n)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;=&nbsp;n;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;print()&nbsp;const<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;"value:&nbsp;"&nbsp;&lt;&lt;&nbsp;value&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&amp;&nbsp;operator+=(const&nbsp;Counter&amp;&nbsp;counter)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;+=&nbsp;counter.value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;*this;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;operator+(const&nbsp;Counter&amp;&nbsp;counter)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;copy{&nbsp;value&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy&nbsp;+=&nbsp;counter;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;copy;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>private:<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;value;<br>};<br><br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;counter1{20};<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;counter2{10};<br><br>&nbsp;&nbsp;&nbsp;&nbsp;counter1&nbsp;+=&nbsp;counter2;<br>&nbsp;&nbsp;&nbsp;&nbsp;counter1.print();&nbsp;&nbsp;&nbsp;//&nbsp;value:&nbsp;30<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;counter3{counter1&nbsp;+&nbsp;counter2};<br>&nbsp;&nbsp;&nbsp;&nbsp;counter3.print();&nbsp;&nbsp;&nbsp;//&nbsp;value:&nbsp;40<br>}</code></pre>
     </div>
     <p class="paragraph">Mai întâi definim operatorul +=:</p>
     <div class="code-inline">
      <pre><code>Counter&amp;&nbsp;operator+=(const&nbsp;Counter&amp;&nbsp;counter)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;+=&nbsp;counter.value;<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;*this;<br>}</code></pre>
     </div>
     <p class="paragraph">Apoi, în operatorul +, copiem obiectul curent și aplicăm asupra copiei operatorul +=:</p>
     <div class="code-inline">
      <pre><code>Counter&nbsp;operator+(const&nbsp;Counter&amp;&nbsp;counter)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;Counter&nbsp;copy{&nbsp;value&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;copy&nbsp;+=&nbsp;counter;<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;copy;<br>}</code></pre>
     </div>
     <p class="paragraph">Astfel, evităm duplicarea logicii și centralizăm implementarea într-o singură funcție.</p>
    </div>
    <div class="lesson-navigation">
     <th:block th:if="${previousLesson != null}"> <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția anterioară</a> </th:block> <th:block th:if="${nextLesson != null}"> <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția următoare →</a> </th:block>
    </div>
    <div class="discord-banner-section">
     <div class="discord-banner-container">
      <a href="https://discord.com/channels/1168639076098920578/1168646757551443979" target="_blank"> <img th:src="@{/images/cpp_discord.png}" alt="Discord Banner" class="discord-banner-image"> </a>
     </div>
    </div>
   </main>
   <aside class="ad-section">
    <div class="ad-box ad-desktop">
     <ins class="adsbygoogle" style="display:inline-block;width:120px;height:728px" data-ad-client="ca-pub-4253419731329045" data-ad-slot="7123454389"></ins>
    </div>
    <div class="ad-box ad-mobile">
     <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-4253419731329045" data-ad-slot="7123454389"></ins>
    </div>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
   </aside>
  </div>
  <div th:replace="~{fragments/footer :: footer}"></div>
  <script th:src="@{/js/script.js}" defer></script>
 </body>
</html>