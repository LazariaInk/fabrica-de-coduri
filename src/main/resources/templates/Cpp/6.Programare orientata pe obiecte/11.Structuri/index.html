<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">

<head>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4253419731329045"
        crossorigin="anonymous"></script>

    <link rel="canonical" th:href="${canonicalUrl}" />
    <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        window.gtag = function () { dataLayer.push(arguments); };
        gtag('consent', 'default', {
            'wait_for_update': 500,
            'region': ['RO'],
            'ad_storage': 'denied',
            'analytics_storage': 'denied',
            'ad_user_data': 'denied',
            'ad_personalization': 'denied'
        });
        gtag('js', new Date());
        gtag('config', 'G-7Q2536ZKL2');
    </script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title th:text="${lesson.title}">Lesson</title>
    <link rel="stylesheet" th:href="@{/css/styles.css}">
    <style>
        body {
            background: #ffffff;
        }
    </style>
</head>

<body th:with="activeTopic='C-sharp', activeChapter='10.Colectii', activeLesson='1.Lista List_T_'">
    <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
    <div th:replace="~{fragments/nav :: nav}"></div>
    <div class="top-nav">
        <th:block th:each="topic : ${topics}">
            <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}"
                th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a>
        </th:block>
    </div>
    <div class="layout">
        <div class="mobile-sidebar" id="mobileSidebar">
            <button class="close-btn" onclick="toggleSidebar()">✖</button>
            <ul class="chapter-list">
                <th:block th:each="chapter : ${chapters}">
                    <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
                        <div class="chapter-title" onclick="toggleChapter(this)">
                            <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
                        </div>
                        <ul class="lesson-list">
                            <th:block th:each="lesson : ${chapter.lessons}">
                                <li><a th:href="@{'/lectii/' +
${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}"
                                        th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
                            </th:block>
                        </ul>
                    </li>
                </th:block>
            </ul>
        </div>
        <aside class="sidebar">
            <ul class="sidebar-list">
                <th:block th:each="chapter : ${chapters}">
                    <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
                        <div class="chapter-toggle" onclick="toggleLessons(this)">
                            <span th:text="${chapter.title}">Chapter</span>
                        </div>
                        <ul class="lesson-list hidden">
                            <th:block th:each="lesson : ${chapter.lessons}">
                                <li><a th:href="@{'/lectii/' +
${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}"
                                        th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
                            </th:block>
                        </ul>
                    </li>
                </th:block>
            </ul>
        </aside>
        <main class="content">
            <div class="document-container">

<h1 class="main-title">Structuri</h1>
<p class="paragraph">Pe lângă clase, pentru a crea tipuri de date proprii, se pot folosi structuri, care sunt moștenite de C++ din limbajul C. Structura în C++ reprezintă un tip derivat de date care definește o anumită entitate, la fel ca și clasa. Adesea, structurile în contextul C++ sunt numite și clase. Și în realitate, diferențele dintre ele nu sunt foarte mari. Structura poate de asemenea să definească variabile, funcții, constructori, destructori. Totuși, de obicei, structurile sunt utilizate pentru stocarea unor date accesibile public sub formă de variabile publice. Pentru celelalte scenarii se folosesc clasele.</p>
<p class="paragraph">Pentru definirea unei structuri se utilizează cuvântul cheie struct, iar formatul de definire arată astfel:</p>
<div class="code-inline"><pre><code>struct&nbsp;nume_structura<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;componente_structura<br>};</code></pre></div>
<p class="paragraph">nume_structura este un identificator arbitrar, căruia i se aplică aceleași reguli ca și la denumirea variabilelor. După numele structurii, în acolade sunt plasate componentele structurii – variabile și funcții.</p>
<p class="paragraph">De exemplu, să definim o structură simplă:</p>
<div class="code-inline"><pre><code>#include&nbsp;&lt;iostream&gt;<br>&nbsp;<br>struct&nbsp;person<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;age;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;name;<br>};<br>&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;person&nbsp;tom;<br>&nbsp;&nbsp;&nbsp;&nbsp;tom.name&nbsp;=&nbsp;&quot;Tom&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;tom.age&nbsp;=&nbsp;34;<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;Name:&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;tom.name&nbsp;&lt;&lt;&nbsp;&quot;\tAge:&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;tom.age&nbsp;&lt;&lt;&nbsp;std::endl;<br>}</code></pre></div>
<p class="paragraph">Aici este definită structura person, care are două variabile: name (de tip string) și age (de tip unsigned).</p>
<p class="paragraph">După definirea structurii o putem folosi. Mai întâi putem defini un obiect al structurii – practic o variabilă obișnuită, care va reprezenta tipul creat. După crearea variabilei de tip structură, putem accesa elementele acesteia – să obținem valorile lor sau, dimpotrivă, să le atribuim alte valori. Pentru a accesa elementele structurii se utilizează operatorul punct:</p>
<div class="code-inline"><pre><code>nume_variabilă_structură.element</code></pre></div>
<p class="paragraph">În esență, o structură este similară unei clase, adică prin structuri putem defini entități pentru utilizare în program. În același timp, toți membrii unei structuri pentru care nu este utilizat un specificator de acces (public, private) sunt în mod implicit publici (public). În timp ce într-o clasă, toți membrii pentru care nu este specificat un acces sunt privați (private).</p>
<p class="paragraph">De asemenea, putem inițializa o structură atribuind valorile variabilelor sale prin sintaxa de inițializare:</p>
<div class="code-inline"><pre><code>person&nbsp;tom{&nbsp;34,&nbsp;&quot;Tom&quot;&nbsp;};</code></pre></div>
<p class="paragraph">Inițializarea structurilor este similară cu inițializarea array-urilor: între acolade se transmit valorile pentru membrii structurii, în ordine. Deoarece în structura person prima variabilă definită este de tip unsigned – un număr, în acolade mai întâi este plasat numărul. Și așa mai departe, pentru toți membrii, în ordine.</p>
<p class="paragraph">De fapt, orice clasă poate fi reprezentată sub forma unei structuri și invers. Să luăm, de exemplu, următoarea clasă:</p>
<div class="code-inline"><pre><code>#include&nbsp;&lt;iostream&gt;<br>&nbsp;&nbsp;<br>class&nbsp;Person<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;Person(std::string&nbsp;name,&nbsp;unsigned&nbsp;age):&nbsp;name{name},&nbsp;age{age}<br>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;print()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;Name:&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;name&nbsp;&lt;&lt;&nbsp;&quot;\tAge:&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;age&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>private:<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;name;<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;age;<br>};<br>&nbsp;&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;Person&nbsp;bob{&quot;Bob&quot;,&nbsp;42};<br>&nbsp;&nbsp;&nbsp;&nbsp;bob.print();<br>}</code></pre></div>
<p class="paragraph">Această clasă definește entitatea „persoană” și conține un set de variabile și funcții publice și private. În locul clasei, pentru a defini aceeași entitate, am fi putut folosi o structură:</p>
<div class="code-inline"><pre><code>#include&nbsp;&lt;iostream&gt;<br>&nbsp;&nbsp;<br>struct&nbsp;person<br>{<br>public:<br>&nbsp;&nbsp;&nbsp;&nbsp;person(std::string&nbsp;name,&nbsp;unsigned&nbsp;age):&nbsp;name{name},&nbsp;age{age}<br>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;print()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;Name:&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;name&nbsp;&lt;&lt;&nbsp;&quot;\tAge:&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;age&nbsp;&lt;&lt;&nbsp;std::endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>private:<br>&nbsp;&nbsp;&nbsp;&nbsp;std::string&nbsp;name;<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;age;<br>};<br>&nbsp;&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;person&nbsp;bob{&quot;Bob&quot;,&nbsp;42};<br>&nbsp;&nbsp;&nbsp;&nbsp;bob.print();<br>}</code></pre></div>
<p class="paragraph">Și în ceea ce privește rezultatul final al programului, nu am observa nicio diferență.</p>
<h2 class="subtitle">Când se folosesc structurile?</h2>
<p class="paragraph">De regulă, structurile sunt folosite pentru a descrie date care conțin doar un set de atribute publice – variabile deschise. De exemplu, precum structura person definită la începutul articolului. Uneori astfel de entități sunt numite și clase agregate (aggregate classes).</p>
            </div>
        </main>
        <aside class="ad-section">
            <div class="ad-box">
                <p>Google Ad Here</p>
            </div>
            <div class="ad-box">
                <p>Promo: SQL Beginner Guide</p>
            </div>
        </aside>
    </div>
    <div class="lesson-navigation">
        <th:block th:if="${previousLesson != null}">
            <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția
                anterioară</a>
        </th:block>
        <th:block th:if="${nextLesson != null}">
            <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția
                următoare →</a>
        </th:block>
    </div>
    <div th:replace="~{fragments/footer :: footer}"></div>
    <script th:src="@{/js/script.js}" defer></script>
</body>
</html>
