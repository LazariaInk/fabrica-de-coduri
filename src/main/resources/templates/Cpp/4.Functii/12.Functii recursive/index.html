<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">

<head>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4253419731329045"
        crossorigin="anonymous"></script>

    <link rel="canonical" th:href="${canonicalUrl}" />
    <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        window.gtag = function () { dataLayer.push(arguments); };
        gtag('consent', 'default', {
            'wait_for_update': 500,
            'region': ['RO'],
            'ad_storage': 'denied',
            'analytics_storage': 'denied',
            'ad_user_data': 'denied',
            'ad_personalization': 'denied'
        });
        gtag('js', new Date());
        gtag('config', 'G-7Q2536ZKL2');
    </script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title th:text="${lesson.title}">Lesson</title>
    <link rel="stylesheet" th:href="@{/css/styles.css}">
    <style>
        body {
            background: #ffffff;
        }
    </style>
</head>

<body th:with="activeTopic='C-sharp', activeChapter='10.Colectii', activeLesson='1.Lista List_T_'">
    <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
    <div th:replace="~{fragments/nav :: nav}"></div>
    <div class="top-nav">
        <th:block th:each="topic : ${topics}">
            <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}"
                th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a>
        </th:block>
    </div>
    <div class="layout">
        <div class="mobile-sidebar" id="mobileSidebar">
            <button class="close-btn" onclick="toggleSidebar()">✖</button>
            <ul class="chapter-list">
                <th:block th:each="chapter : ${chapters}">
                    <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
                        <div class="chapter-title" onclick="toggleChapter(this)">
                            <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
                        </div>
                        <ul class="lesson-list">
                            <th:block th:each="lesson : ${chapter.lessons}">
                                <li><a th:href="@{'/lectii/' +
${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}"
                                        th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
                            </th:block>
                        </ul>
                    </li>
                </th:block>
            </ul>
        </div>
        <aside class="sidebar">
            <ul class="sidebar-list">
                <th:block th:each="chapter : ${chapters}">
                    <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
                        <div class="chapter-toggle" onclick="toggleLessons(this)">
                            <span th:text="${chapter.title}">Chapter</span>
                        </div>
                        <ul class="lesson-list hidden">
                            <th:block th:each="lesson : ${chapter.lessons}">
                                <li><a th:href="@{'/lectii/' +
${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}"
                                        th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
                            </th:block>
                        </ul>
                    </li>
                </th:block>
            </ul>
        </aside>
        <main class="content">
            <div class="document-container">

<h1 class="main-title">Funcții recursive</h1>
<p class="paragraph">Funcțiile recursive sunt funcții care se apelează pe ele însele. Astfel de funcții sunt adesea utilizate pentru a parcurge diverse structuri. De exemplu, dacă trebuie să găsim un anumit fișier într-un dosar, mai întâi verificăm toate fișierele din acel dosar, apoi toate subdosarele sale.</p>
<p class="paragraph">De exemplu, să definim calculul factorialului sub forma unei funcții recursive:</p>
<div class="code-inline"><pre><code>#include&nbsp;&lt;iostream&gt;<br>&nbsp;&nbsp;<br>unsigned&nbsp;long&nbsp;long&nbsp;factorial(unsigned);<br>&nbsp;&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;n&nbsp;{5};<br>&nbsp;&nbsp;&nbsp;&nbsp;auto&nbsp;result&nbsp;{&nbsp;factorial(n)};<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;Factorial&nbsp;of&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;n&nbsp;&lt;&lt;&nbsp;&quot;&nbsp;is&nbsp;equal&nbsp;to&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;result&nbsp;&lt;&lt;&nbsp;std::endl;<br>}<br>&nbsp;&nbsp;<br>unsigned&nbsp;long&nbsp;long&nbsp;factorial(unsigned&nbsp;n)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;if(n&nbsp;&gt;&nbsp;1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;n&nbsp;*&nbsp;factorial(n-1);<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br>}</code></pre></div>
<p class="paragraph">În funcția factorial este definită condiția că, dacă numărul n este mai mare ca 1, atunci acest număr este înmulțit cu rezultatul aceleași funcții, în care se transmite ca parametru numărul n-1. Adică are loc o coborâre recursivă. Și așa mai departe, până când ajungem la momentul în care valoarea parametrului este egală cu 1. În acest caz, funcția returnează 1.</p>
<p class="paragraph">O funcție recursivă trebuie neapărat să aibă un caz de bază, care folosește operatorul return și către care converg toate celelalte apeluri ale funcției. În cazul factorialului, cazul de bază este situația în care n = 1. În acest caz se execută instrucțiunea return 1;.</p>
<p class="paragraph">De exemplu, pentru apelul factorial(5) se obține următorul lanț de apeluri:</p>
<div class="code-inline"><pre><code>5&nbsp;*&nbsp;factorial(4)<br>5&nbsp;*&nbsp;4&nbsp;*&nbsp;factorial(3)<br>5&nbsp;*&nbsp;4&nbsp;*&nbsp;3&nbsp;*&nbsp;factorial(2)<br>5&nbsp;*&nbsp;4&nbsp;*&nbsp;3&nbsp;*&nbsp;2&nbsp;*&nbsp;factorial(1)<br>5&nbsp;*&nbsp;4&nbsp;*&nbsp;3&nbsp;*&nbsp;2&nbsp;*&nbsp;1<br></code></pre></div>
<p class="paragraph">Un alt exemplu frecvent și ilustrativ de funcție recursivă este funcția care calculează numerele Fibonacci. Al n-lea termen din șirul Fibonacci se definește prin formula:</p>
<p class="paragraph">f(n) = f(n - 1) + f(n - 2), cu condițiile f(0) = 0 și f(1) = 1.</p>
<p class="paragraph">Valorile f(0) = 0 și f(1) = 1 definesc cazurile de bază pentru această funcție:</p>
<div class="code-inline"><pre><code>#include&nbsp;&lt;iostream&gt;<br>&nbsp;&nbsp;<br>unsigned&nbsp;long&nbsp;long&nbsp;fib(unsigned);<br>&nbsp;&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;for(unsigned&nbsp;i{};&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auto&nbsp;n&nbsp;=&nbsp;fib(i);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;n&nbsp;&lt;&lt;&nbsp;&quot;\t&quot;;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;std::endl;<br>}<br>unsigned&nbsp;long&nbsp;long&nbsp;fib(unsigned&nbsp;n)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(n&nbsp;==&nbsp;0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(n&nbsp;==&nbsp;1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;fib(n&nbsp;-&nbsp;1)&nbsp;+&nbsp;fib(n&nbsp;-&nbsp;2);<br>}</code></pre></div>
<p class="paragraph">Rezultatul execuției programului – afișarea în consolă a primelor 10 numere din șirul Fibonacci:</p>
<p class="paragraph">În exemplele de mai sus, funcția își apelează direct propria definiție. Însă apelul recursiv poate fi și indirect. De exemplu, funcția fun1() apelează altă funcție fun2(), care la rândul ei o apelează din nou pe fun1(). În acest caz, funcțiile fun1() și fun2() sunt numite funcții recursiv mutuale.</p>
<p class="paragraph">Trebuie menționat că deseori funcțiile recursive pot fi rescrise sub forma unor cicluri. De exemplu, pentru calculul factorialului, putem folosi un ciclu în locul recursiei:</p>
<div class="code-inline"><pre><code>#include&nbsp;&lt;iostream&gt;<br>&nbsp;&nbsp;<br>unsigned&nbsp;long&nbsp;long&nbsp;factorial(unsigned);<br>&nbsp;&nbsp;<br>int&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;n&nbsp;{6};<br>&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;Factorial&nbsp;of&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;n&nbsp;&lt;&lt;&nbsp;&quot;&nbsp;:&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;factorial(n)&nbsp;&lt;&lt;&nbsp;std::endl;<br>}<br>&nbsp;&nbsp;<br>unsigned&nbsp;long&nbsp;long&nbsp;factorial(unsigned&nbsp;n)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;long&nbsp;result{1};<br>&nbsp;&nbsp;&nbsp;&nbsp;for(unsigned&nbsp;i{1};&nbsp;i&nbsp;&lt;=&nbsp;n;&nbsp;i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;*=&nbsp;i;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;<br>}</code></pre></div>
<p class="paragraph">Și deseori structurile iterative sunt mai eficiente decât recursia. De exemplu, dacă o funcție se apelează pe sine de mii de ori, este necesară o cantitate mare de memorie de stivă pentru a stoca copii ale valorilor parametrilor și adresele de revenire pentru fiecare apel, ceea ce poate duce la epuizarea rapidă a memoriei de stivă alocate programului, deoarece această memorie este, de obicei, fixă și limitată. Acest lucru poate duce la închiderea neașteptată a programului.</p>
<p class="paragraph">Din acest motiv, în astfel de cazuri este de preferat să folosim soluții alternative, cum ar fi ciclurile. Cu toate acestea, în ciuda costurilor suplimentare, utilizarea recursiei poate simplifica considerabil scrierea programului.</p>
            </div>
        </main>
        <aside class="ad-section">
            <div class="ad-box">
                <p>Google Ad Here</p>
            </div>
            <div class="ad-box">
                <p>Promo: SQL Beginner Guide</p>
            </div>
        </aside>
    </div>
    <div class="lesson-navigation">
        <th:block th:if="${previousLesson != null}">
            <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția
                anterioară</a>
        </th:block>
        <th:block th:if="${nextLesson != null}">
            <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția
                următoare →</a>
        </th:block>
    </div>
    <div th:replace="~{fragments/footer :: footer}"></div>
    <script th:src="@{/js/script.js}" defer></script>
</body>
</html>
