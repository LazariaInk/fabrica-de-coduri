<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">

<head>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4253419731329045"
        crossorigin="anonymous"></script>

    <link rel="canonical" th:href="${canonicalUrl}" />
    <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        window.gtag = function () { dataLayer.push(arguments); };
        gtag('consent', 'default', {
            'wait_for_update': 500,
            'region': ['RO'],
            'ad_storage': 'denied',
            'analytics_storage': 'denied',
            'ad_user_data': 'denied',
            'ad_personalization': 'denied'
        });
        gtag('js', new Date());
        gtag('config', 'G-7Q2536ZKL2');
    </script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title th:text="${lesson.title}">Lesson</title>
    <link rel="stylesheet" th:href="@{/css/styles.css}">
    <style>
        body {
            background: #ffffff;
        }
    </style>
</head>

<body th:with="activeTopic='C-sharp', activeChapter='10.Colectii', activeLesson='1.Lista List_T_'">
    <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
    <div th:replace="~{fragments/nav :: nav}"></div>
    <div class="top-nav">
        <th:block th:each="topic : ${topics}">
            <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}"
                th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a>
        </th:block>
    </div>
    <div class="layout">
        <div class="mobile-sidebar" id="mobileSidebar">
            <button class="close-btn" onclick="toggleSidebar()">✖</button>
            <ul class="chapter-list">
                <th:block th:each="chapter : ${chapters}">
                    <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
                        <div class="chapter-title" onclick="toggleChapter(this)">
                            <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
                        </div>
                        <ul class="lesson-list">
                            <th:block th:each="lesson : ${chapter.lessons}">
                                <li><a th:href="@{'/lectii/' +
${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}"
                                        th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
                            </th:block>
                        </ul>
                    </li>
                </th:block>
            </ul>
        </div>
        <aside class="sidebar">
            <ul class="sidebar-list">
                <th:block th:each="chapter : ${chapters}">
                    <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
                        <div class="chapter-toggle" onclick="toggleLessons(this)">
                            <span th:text="${chapter.title}">Chapter</span>
                        </div>
                        <ul class="lesson-list hidden">
                            <th:block th:each="lesson : ${chapter.lessons}">
                                <li><a th:href="@{'/lectii/' +
${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}"
                                        th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
                            </th:block>
                        </ul>
                    </li>
                </th:block>
            </ul>
        </aside>
        <main class="content">
            <div class="document-container">

<h1 class="main-title">Funcții și parametrii lor</h1>
<p class="paragraph">O funcție reprezintă un bloc de instrucțiuni care, împreună, realizează o anumită sarcină. Cu ajutorul funcțiilor, putem apela de mai multe ori acest bloc de instrucțiuni ca un întreg în diferite părți ale programului.</p>
<p class="paragraph">O funcție se declară astfel:</p>
<div class="code-inline"><pre><code>func&nbsp;nume_funcție&nbsp;(listă_parametri)&nbsp;(tipuri_valori_returnate)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;instrucțiuni_de_executat<br>}</code></pre></div>
<p class="paragraph">Funcția este definită folosind cuvântul cheie func, urmat de numele funcției. Apoi, între paranteze, se află lista de parametri. După lista de parametri, se definesc tipurile valorilor returnate de funcție (dacă funcția returnează valori). După aceea, între acolade se află instrucțiunile care formează funcția.</p>
<p class="paragraph">Numele funcției, împreună cu tipurile parametrilor săi și tipurile valorilor returnate, este cunoscut și sub denumirea de semnătură a funcției.</p>
<p class="paragraph">Implicit, fiecare program Go trebuie să conțină cel puțin o funcție – funcția main, care reprezintă punctul de intrare în aplicație:</p>
<div class="code-inline"><pre><code>package&nbsp;main<br>import&nbsp;&quot;fmt&quot;<br><br>func&nbsp;main()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&quot;Hello&nbsp;Go&quot;)<br>}</code></pre></div>
<p class="paragraph">Funcția main începe cu cuvântul cheie func, urmat de numele main. Funcția nu acceptă parametri, așa că după nume urmează paranteze goale. Funcția main nu returnează niciun rezultat, astfel că după parantezele goale nu se specifică tipul valorii returnate. Corpul funcției, între acolade, constă în apelul unei alte funcții – fmt.Println(), care afișează un șir pe consolă.</p>
<p class="paragraph">Acum să definim o altă funcție:</p>
<div class="code-inline"><pre><code>package&nbsp;main<br>import&nbsp;&quot;fmt&quot;<br><br>func&nbsp;main()&nbsp;{<br><br>}<br><br>func&nbsp;hello()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&quot;Hello&nbsp;World&quot;)<br>}</code></pre></div>
<p class="paragraph">În acest caz, am definit funcția hello, care nu acceptă parametri, nu returnează nimic și pur și simplu afișează un șir pe consolă. O funcție poate fi definită în același fișier în care se află funcția main. Totuși, dacă rulăm acest program, nu vom vedea nimic pe consolă, deoarece programul execută doar acțiunile definite în cadrul funcției main. Funcția main este punctul de intrare în aplicație. Dacă dorim să executăm funcția noastră hello, trebuie să o apelăm în cadrul funcției main:</p>
<div class="code-inline"><pre><code>package&nbsp;main<br>import&nbsp;&quot;fmt&quot;<br><br>func&nbsp;main()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;hello()<br>&nbsp;&nbsp;&nbsp;&nbsp;hello()<br>&nbsp;&nbsp;&nbsp;&nbsp;hello()<br>}<br><br>func&nbsp;hello()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&quot;Hello&nbsp;World&quot;)<br>}</code></pre></div>
<p class="paragraph">Pentru a apela o funcție, scriem numele acesteia, urmat de paranteze în care se indică valorile pentru parametrii funcției. Deoarece funcția hello nu are parametri, vom scrie doar paranteze goale. Astfel, când programul este executat, șirul &quot;Hello World&quot; va fi afișat de trei ori pe consolă:</p>
<div class="code-inline"><pre><code>Hello&nbsp;World<br>Hello&nbsp;World<br>Hello&nbsp;World</code></pre></div>
<p class="paragraph">Astfel, definirea unui grup de instrucțiuni sub forma unei funcții ne permite să nu scriem de fiecare dată întregul grup de instrucțiuni, ci să facem referire la el prin numele funcției.</p>
<h2 class="subtitle">Parametrii funcției</h2>
<p class="paragraph">Prin parametri, o funcție primește date de intrare. Parametrii sunt specificați între paranteze, după numele funcției. Pentru fiecare parametru, se indică numele și tipul acestuia (ca la o variabilă). Parametrii sunt separați prin virgule. La apelarea funcției, trebuie să transmitem valori pentru toți parametrii acesteia. De exemplu, să presupunem că dorim să folosim o funcție care adună două numere:</p>
<div class="code-inline"><pre><code>package&nbsp;main<br>import&nbsp;&quot;fmt&quot;<br><br>func&nbsp;main()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;add(4,&nbsp;5)&nbsp;&nbsp;&nbsp;//&nbsp;x&nbsp;+&nbsp;y&nbsp;=&nbsp;9<br>&nbsp;&nbsp;&nbsp;&nbsp;add(20,&nbsp;6)&nbsp;&nbsp;//&nbsp;x&nbsp;+&nbsp;y&nbsp;=&nbsp;26<br>}<br><br>func&nbsp;add(x&nbsp;int,&nbsp;y&nbsp;int)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;z&nbsp;=&nbsp;x&nbsp;+&nbsp;y<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&quot;x&nbsp;+&nbsp;y&nbsp;=&nbsp;&quot;,&nbsp;z)<br>}</code></pre></div>
<p class="paragraph">Funcția add are doi parametri: x și y. Ambii parametri sunt de tipul int, adică numere întregi. În cadrul funcției, se definește o variabilă care stochează suma acestor numere. Apoi, suma numerelor este afișată pe consolă.</p>
<p class="paragraph">În funcția main este apelată funcția add. Deoarece funcția primește doi parametri, trebuie să-i transmitem acestei funcții două argumente, iar valorile transmise trebuie să corespundă tipului parametrilor. Adică, dacă un parametru este de tipul int, trebuie să-i transmitem un număr.</p>
<p class="paragraph">Valorile sunt transmise în funcție de poziție. Adică, primul parametru va primi primul argument, al doilea parametru va primi al doilea argument și așa mai departe. În rezultat, vom obține următorul output pe consolă:</p>
<div class="code-inline"><pre><code>x&nbsp;+&nbsp;y&nbsp;=&nbsp;9<br>x&nbsp;+&nbsp;y&nbsp;=&nbsp;26</code></pre></div>
<p class="paragraph">Dacă mai mulți parametri succesivi au același tip, putem să indicăm tipul doar pentru ultimul parametru, iar ceilalți parametri vor avea același tip:</p>
<div class="code-inline"><pre><code>package&nbsp;main<br>import&nbsp;&quot;fmt&quot;<br>&nbsp;<br>func&nbsp;main()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;add(1,&nbsp;2,&nbsp;3.4,&nbsp;5.6,&nbsp;1.2)<br>}<br>func&nbsp;add(x,&nbsp;y&nbsp;int,&nbsp;a,&nbsp;b,&nbsp;c&nbsp;float32){<br>&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;z&nbsp;=&nbsp;x&nbsp;+&nbsp;y<br>&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;d&nbsp;=&nbsp;a&nbsp;+&nbsp;b&nbsp;+&nbsp;c<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&quot;x&nbsp;+&nbsp;y&nbsp;=&nbsp;&quot;,&nbsp;z)<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&quot;a&nbsp;+&nbsp;b&nbsp;+&nbsp;c&nbsp;=&nbsp;&quot;,&nbsp;d)<br>}<br></code></pre></div>
<p class="paragraph">La apelarea funcției, ca argumente, pot fi transmise și valori de variabile, rezultate ale operațiunilor sau ale altor funcții, dar trebuie avut în vedere că argumentele sunt întotdeauna transmise prin valoare:</p>
<div class="code-inline"><pre><code>package&nbsp;main<br>import&nbsp;&quot;fmt&quot;<br>&nbsp;<br>func&nbsp;main()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;a&nbsp;=&nbsp;8<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&quot;a&nbsp;before:&nbsp;&quot;,&nbsp;a)<br>&nbsp;&nbsp;&nbsp;&nbsp;increment(a)<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&quot;a&nbsp;after:&nbsp;&quot;,&nbsp;a)<br>}<br>func&nbsp;increment(x&nbsp;int){<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&quot;x&nbsp;before:&nbsp;&quot;,&nbsp;x)<br>&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;x&nbsp;+&nbsp;20<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&quot;x&nbsp;after:&nbsp;&quot;,&nbsp;x)<br>}</code></pre></div>
<p class="paragraph">Ieșirea pe consolă:</p>
<div class="code-inline"><pre><code>a&nbsp;before:&nbsp;8<br>x&nbsp;before:&nbsp;8<br>x&nbsp;after:&nbsp;28<br>a&nbsp;after:&nbsp;8</code></pre></div>
<p class="paragraph">În acest caz, ca argument pentru funcția increment, se transmite valoarea variabilei a. Parametrul x primește această valoare și aceasta este crescută cu 20. Cu toate acestea, chiar dacă valoarea parametrului x a fost mărită, valoarea variabilei a nu s-a schimbat. Acest lucru se întâmplă pentru că, la apelarea funcției, se transmite o copie a valorii variabilei.</p>
<h2 class="subtitle">Număr nelimitat de parametri</h2>
<p class="paragraph">În Go, o funcție poate accepta un număr nelimitat de parametri de același tip. De exemplu, să presupunem că trebuie să obținem suma unor numere, dar nu știm exact câte numere vor fi transmise funcției:</p>
<div class="code-inline"><pre><code>package&nbsp;main<br>import&nbsp;&quot;fmt&quot;<br>&nbsp;<br>func&nbsp;main()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;add(1,&nbsp;2,&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;sum&nbsp;=&nbsp;6<br>&nbsp;&nbsp;&nbsp;&nbsp;add(1,&nbsp;2,&nbsp;3,&nbsp;4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;sum&nbsp;=&nbsp;10<br>&nbsp;&nbsp;&nbsp;&nbsp;add(5,&nbsp;6,&nbsp;7,&nbsp;2,&nbsp;3)&nbsp;&nbsp;//&nbsp;sum&nbsp;=&nbsp;23<br>}<br>&nbsp;<br>func&nbsp;add(numbers&nbsp;...int){<br>&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;sum&nbsp;=&nbsp;0<br>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;_,&nbsp;number&nbsp;:=&nbsp;range&nbsp;numbers{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;+=&nbsp;number<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&quot;sum&nbsp;=&nbsp;&quot;,&nbsp;sum)<br>}</code></pre></div>
<p class="paragraph">Pentru a defini un parametru care acceptă un număr nelimitat de valori, punem trei puncte înainte de tipul acestora: numbers ...int. Astfel, prin acest tip de parametru, obținem mai multe valori de tip int.</p>
<p class="paragraph">La apelarea funcției, putem transmite un număr variabil de numere:</p>
<div class="code-inline"><pre><code>add(1,&nbsp;2,&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;sum&nbsp;=&nbsp;6<br>add(1,&nbsp;2,&nbsp;3,&nbsp;4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;sum&nbsp;=&nbsp;10<br>add(5,&nbsp;6,&nbsp;7,&nbsp;2,&nbsp;3)&nbsp;&nbsp;//&nbsp;sum&nbsp;=&nbsp;23</code></pre></div>
<p class="paragraph">Acesta trebuie să fie diferențiat de transmiterea unui slice ca parametru:</p>
<div class="code-inline"><pre><code>add([]int{1,&nbsp;2,&nbsp;3})<br>add([]int{1,&nbsp;2,&nbsp;3,&nbsp;4})<br>add([]int{5,&nbsp;6,&nbsp;7,&nbsp;2,&nbsp;3})</code></pre></div>
<p class="paragraph">În acest caz, vom obține o eroare, deoarece transmiterea unui slice nu este echivalentă cu transmiterea unui număr nelimitat de parametri de același tip. Dacă dorim să transmitem un slice, trebuie să indicăm trei puncte după argumentul array-ului:</p>
<div class="code-inline"><pre><code>add([]int{1,&nbsp;2,&nbsp;3}...)<br>&nbsp;<br>add([]int{1,&nbsp;2,&nbsp;3,&nbsp;4}...)<br>&nbsp;<br>var&nbsp;nums&nbsp;=&nbsp;[]int{5,&nbsp;6,&nbsp;7,&nbsp;2,&nbsp;3}<br>add(nums...)</code></pre></div>
            </div>
        </main>
        <aside class="ad-section">
            <div class="ad-box">
                <p>Google Ad Here</p>
            </div>
            <div class="ad-box">
                <p>Promo: SQL Beginner Guide</p>
            </div>
        </aside>
    </div>
    <div class="lesson-navigation">
        <th:block th:if="${previousLesson != null}">
            <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția
                anterioară</a>
        </th:block>
        <th:block th:if="${nextLesson != null}">
            <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția
                următoare →</a>
        </th:block>
    </div>
    <div th:replace="~{fragments/footer :: footer}"></div>
    <script th:src="@{/js/script.js}" defer></script>
</body>
</html>
