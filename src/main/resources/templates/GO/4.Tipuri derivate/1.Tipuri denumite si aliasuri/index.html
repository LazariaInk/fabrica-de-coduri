<!doctype html>
<html lang="ro" xmlns:th="http://www.w3.org/1999/xhtml">

<head>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4253419731329045"
        crossorigin="anonymous"></script>

    <link rel="canonical" th:href="${canonicalUrl}" />
    <link rel="icon" type="image/png" href="/nume-aplicatie/images/favicon.png">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7Q2536ZKL2"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        window.gtag = function () { dataLayer.push(arguments); };
        gtag('consent', 'default', {
            'wait_for_update': 500,
            'region': ['RO'],
            'ad_storage': 'denied',
            'analytics_storage': 'denied',
            'ad_user_data': 'denied',
            'ad_personalization': 'denied'
        });
        gtag('js', new Date());
        gtag('config', 'G-7Q2536ZKL2');
    </script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title th:text="${lesson.title}">Lesson</title>
    <link rel="stylesheet" th:href="@{/css/styles.css}">
    <style>
        body {
            background: #ffffff;
        }
    </style>
</head>

<body th:with="activeTopic='C-sharp', activeChapter='10.Colectii', activeLesson='1.Lista List_T_'">
    <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()">☰</button>
    <div th:replace="~{fragments/nav :: nav}"></div>
    <div class="top-nav">
        <th:block th:each="topic : ${topics}">
            <a th:href="@{'/lectii/topic/' + ${topic.id}}" th:text="${topic.name}"
                th:classappend="${topic.id} == ${activeTopicId} ? 'active' : ''"> </a>
        </th:block>
    </div>
    <div class="layout">
        <div class="mobile-sidebar" id="mobileSidebar">
            <button class="close-btn" onclick="toggleSidebar()">✖</button>
            <ul class="chapter-list">
                <th:block th:each="chapter : ${chapters}">
                    <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
                        <div class="chapter-title" onclick="toggleChapter(this)">
                            <strong th:text="${chapter.title}"></strong> <span class="arrow">▼</span>
                        </div>
                        <ul class="lesson-list">
                            <th:block th:each="lesson : ${chapter.lessons}">
                                <li><a th:href="@{'/lectii/' +
${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}"
                                        th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
                            </th:block>
                        </ul>
                    </li>
                </th:block>
            </ul>
        </div>
        <aside class="sidebar">
            <ul class="sidebar-list">
                <th:block th:each="chapter : ${chapters}">
                    <li class="chapter-item" th:classappend="${chapter.id} == ${activeChapterId} ? 'open' : ''">
                        <div class="chapter-toggle" onclick="toggleLessons(this)">
                            <span th:text="${chapter.title}">Chapter</span>
                        </div>
                        <ul class="lesson-list hidden">
                            <th:block th:each="lesson : ${chapter.lessons}">
                                <li><a th:href="@{'/lectii/' +
${#strings.toLowerCase(#strings.replace(chapter.topic.name, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(chapter.title, ' ', '-'))} + '/' +
${#strings.toLowerCase(#strings.replace(lesson.title, ' ', '-'))} }" th:text="${lesson.title}"
                                        th:classappend="${lesson.id} == ${activeLessonId} ? 'active' : ''"> </a></li>
                            </th:block>
                        </ul>
                    </li>
                </th:block>
            </ul>
        </aside>
        <main class="content">
            <div class="document-container">

<h1 class="main-title">Tipuri derivate</h1>
<h2 class="subtitle">Tipuri denumite și aliasuri</h2>
<p class="paragraph">Operatorul type permite definirea unui tip denumit pe baza altuia. De exemplu:</p>
<div class="code-inline"><pre><code>type&nbsp;mile&nbsp;uint</code></pre></div>
<p class="paragraph">În acest caz, se definește tipul denumit mile, care se bazează pe tipul uint. Practic, mile reprezintă tipul uint și lucrul cu acesta va fi realizat la fel ca și cu tipul uint. Totuși, în același timp, acesta este un tip nou.</p>
<p class="paragraph">Putem defini variabile de acest tip și lucra cu ele ca obiecte ale tipului de bază uint:</p>
<div class="code-inline"><pre><code>package&nbsp;main<br>import&nbsp;&quot;fmt&quot;<br>&nbsp;<br>type&nbsp;mile&nbsp;uint<br>&nbsp;<br>func&nbsp;main()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;distance&nbsp;mile&nbsp;=&nbsp;5<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(distance)<br>&nbsp;&nbsp;&nbsp;&nbsp;distance&nbsp;+=&nbsp;5<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(distance)<br>}</code></pre></div>
<p class="paragraph">Dar poate apărea întrebarea: de ce să definim un tip denumit dacă acesta se comportă la fel ca tipul uint? Să analizăm următoarea situație:</p>
<div class="code-inline"><pre><code>package&nbsp;main<br>import&nbsp;&quot;fmt&quot;<br>&nbsp;<br>type&nbsp;mile&nbsp;uint<br>type&nbsp;kilometer&nbsp;uint<br>&nbsp;<br>func&nbsp;distanceToEnemy(distance&nbsp;mile){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&quot;distanta&nbsp;pentru&nbsp;inamic:&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(distance,&nbsp;&quot;mile&quot;)<br>}<br>&nbsp;<br>func&nbsp;main()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;distance&nbsp;mile&nbsp;=&nbsp;5<br>&nbsp;&nbsp;&nbsp;&nbsp;distanceToEnemy(distance)<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;var&nbsp;distance1&nbsp;uint&nbsp;=&nbsp;5<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;distanceToEnemy(distance1)&nbsp;&nbsp;&nbsp;//&nbsp;!Eroare<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;var&nbsp;distance2&nbsp;kilometer&nbsp;=&nbsp;5<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;distanceToEnemy(distance2)&nbsp;&nbsp;&nbsp;//&nbsp;!&nbsp;eroare<br>}</code></pre></div>
<p class="paragraph">Aici sunt definite două tipuri denumite: mile și kilometer, care practic reprezintă tipul uint și care sunt destinate pentru exprimarea distanței în mile și kilometri, respectiv. De asemenea, este definită funcția distanceToEnemy(), care afișează distanța până la un inamic ipotetic. Ca parametru, aceasta primește valoarea de tip mile, și nu de tip uint.</p>
<p class="paragraph">Acest lucru ne permite să reducem riscul de a transmite date incorecte. Astfel, datele transmise trebuie să fie definite explicit în program ca valoare de tip mile, și nu ca valoare de tip uint sau kilometer. Cele două tipuri denumite sunt considerate tipuri diferite, chiar dacă sunt bazate pe un tip comun (precum uint în acest caz).</p>
<p class="paragraph">De asemenea, tipurile denumite permit atribuirea unui sens suplimentar tipului. Astfel, utilizarea tipului „kilometer” sau „mile” în cod indică scopul variabilei sau parametrului și este mult mai descriptivă decât simplul tip uint.</p>
<p class="paragraph">O altă situație în care pot fi folosite tipurile denumite este scurtarea denumirii tipurilor atunci când acestea sunt prea lungi sau complexe. De exemplu, să analizăm următorul exemplu:</p>
<div class="code-inline"><pre><code>package&nbsp;main<br>&nbsp;&nbsp;<br>import&nbsp;&quot;fmt&quot;<br>&nbsp;<br>func&nbsp;action(n1&nbsp;int,&nbsp;n2&nbsp;int,&nbsp;op&nbsp;func(int,&nbsp;int)&nbsp;int){<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;:=&nbsp;op(n1,&nbsp;n2)<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(result)<br>}<br>&nbsp;<br>func&nbsp;add(x&nbsp;int,&nbsp;y&nbsp;int)&nbsp;int&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;x&nbsp;+&nbsp;y<br>}<br>&nbsp;<br>func&nbsp;main()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;myOperation&nbsp;func(int,&nbsp;int)&nbsp;int&nbsp;=&nbsp;add<br>&nbsp;&nbsp;&nbsp;&nbsp;action(10,&nbsp;25,&nbsp;myOperation)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;35<br>}</code></pre></div>
<p class="paragraph">Aici este definită funcția action, care primește două numere și o altă funcție de tipul func(int, int) int - adică o funcție care primește două numere și returnează un număr. În funcția main este definită variabila myOperation, care reprezintă funcția de tipul func(int, int) int, primește referința la funcția add și este transmisă apelului action(10, 25, myOperation).</p>
<p class="paragraph">Acum să definim un tip denumit pentru tipul func(int, int) int:</p>
<div class="code-inline"><pre><code>package&nbsp;main<br>&nbsp;&nbsp;<br>import&nbsp;&quot;fmt&quot;<br>&nbsp;&nbsp;<br>type&nbsp;BinaryOp&nbsp;func(int,&nbsp;int)&nbsp;int<br>&nbsp;<br>func&nbsp;action(n1&nbsp;int,&nbsp;n2&nbsp;int,&nbsp;op&nbsp;BinaryOp){<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;:=&nbsp;op(n1,&nbsp;n2)<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(result)<br>}<br>&nbsp;<br>func&nbsp;add(x&nbsp;int,&nbsp;y&nbsp;int)&nbsp;int&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;x&nbsp;+&nbsp;y<br>}<br>&nbsp;<br>func&nbsp;main()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;myOperation&nbsp;BinaryOp&nbsp;=&nbsp;add<br>&nbsp;&nbsp;&nbsp;&nbsp;action(10,&nbsp;35,&nbsp;myOperation)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;45<br>}</code></pre></div>
<p class="paragraph">Acum tipul funcției func(int, int) int este proiectat pe tipul denumit BinaryOp, care reprezintă o operație binară asupra a două operande:</p>
<div class="code-inline"><pre><code>type&nbsp;BinaryOp&nbsp;func(int,&nbsp;int)&nbsp;int</code></pre></div>
<p class="paragraph">Această denumire este mai scurtă decât definiția originală a tipului și, în același timp, este mai descriptivă (cel puțin pentru mine). Astfel, poate fi utilizată mai departe pentru a specifica tipul unui parametru:</p>
<div class="code-inline"><pre><code>func&nbsp;action(n1&nbsp;int,&nbsp;n2&nbsp;int,&nbsp;op&nbsp;BinaryOp){&nbsp;...&nbsp;}</code></pre></div>
<p class="paragraph">sau al unei variabile:</p>
<div class="code-inline"><pre><code>var&nbsp;myOperation&nbsp;BinaryOp&nbsp;=&nbsp;add</code></pre></div>
<h2 class="subtitle">Aliasuri</h2>
<p class="paragraph">Tipurile denumite sunt similare cu aliasurile. Ele sunt, de asemenea, definite cu ajutorul operatorului type, dar în cazul aliasurilor, se aplică operația de atribuire:</p>
<div class="code-inline"><pre><code>type&nbsp;alias&nbsp;=&nbsp;existing_type</code></pre></div>
<p class="paragraph">Totuși, un alias NU definește un tip nou și toate aliasurile pentru același tip sunt considerate identice. De exemplu:</p>
<div class="code-inline"><pre><code>package&nbsp;main<br>import&nbsp;&quot;fmt&quot;<br>&nbsp;&nbsp;<br>type&nbsp;mile&nbsp;=&nbsp;uint<br>type&nbsp;kilometer&nbsp;=&nbsp;uint<br>&nbsp;&nbsp;<br>func&nbsp;distanceToEnemy(distance&nbsp;mile){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&quot;distanta&nbsp;pentru&nbsp;inamic:&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(distance,&nbsp;&quot;mile&quot;)<br>}<br>&nbsp;&nbsp;<br>func&nbsp;main()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;distance&nbsp;mile&nbsp;=&nbsp;5<br>&nbsp;&nbsp;&nbsp;&nbsp;distanceToEnemy(distance)<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;distance1&nbsp;uint&nbsp;=&nbsp;5<br>&nbsp;&nbsp;&nbsp;&nbsp;distanceToEnemy(distance1)&nbsp;&nbsp;&nbsp;//&nbsp;ok<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;distance2&nbsp;kilometer&nbsp;=&nbsp;5<br>&nbsp;&nbsp;&nbsp;&nbsp;distanceToEnemy(distance2)&nbsp;&nbsp;&nbsp;//&nbsp;ok<br>}</code></pre></div>
<p class="paragraph">Aici pentru tipul uint sunt definite două aliasuri - mile și kilometer. Și, deși parametrul funcției distanceToEnemy este definit ca fiind de tip mile, i se poate transmite atât valoarea de tip uint, cât și valoarea aliasului său kilometer.</p>
<p class="paragraph">În mod obișnuit, aliasurile sunt folosite pentru a scurta denumirile altor tipuri sau pentru a defini un nume mai descriptiv.</p>
            </div>
        </main>
        <aside class="ad-section">
            <div class="ad-box">
                <p>Google Ad Here</p>
            </div>
            <div class="ad-box">
                <p>Promo: SQL Beginner Guide</p>
            </div>
        </aside>
    </div>
    <div class="lesson-navigation">
        <th:block th:if="${previousLesson != null}">
            <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(previousLesson.title, ' ', '-'))} }" class="nav-button">← Lecția
                anterioară</a>
        </th:block>
        <th:block th:if="${nextLesson != null}">
            <a th:href="@{'/lectii/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.topic.name, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.chapter.title, ' ', '-'))} + '/' +
            ${#strings.toLowerCase(#strings.replace(nextLesson.title, ' ', '-'))} }" class="nav-button">Lecția
                următoare →</a>
        </th:block>
    </div>
    <div th:replace="~{fragments/footer :: footer}"></div>
    <script th:src="@{/js/script.js}" defer></script>
</body>
</html>
